---
title: Все, что вы хотели знать о подстановке переменных в строках
description: Существует множество способов использования переменных в строках для создания форматированного текста.
ms.date: 05/23/2020
ms.custom: contributor-KevinMarquette
ms.openlocfilehash: 1e65e90ffa09b34f62bc49ad64b062d429483c33
ms.sourcegitcommit: ed4a895d672334c7b02fb7ef6e950dbc2ba4a197
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/28/2020
ms.locfileid: "84149467"
---
# <a name="everything-you-wanted-to-know-about-variable-substitution-in-strings"></a>Все, что вы хотели знать о подстановке переменных в строках

Переменные в строках можно использовать множеством способов. Я называю это подстановкой переменных, но подразумеваю все ситуации, когда необходимо отформатировать строку с учетом значений переменных. Мне часто приходится объяснять этот момент новичкам, изучающим создание скриптов.

> [!NOTE]
> [Оригинал][] этой статьи впервые был опубликован в блоге автора [@KevinMarquette][]. Команда разработчиков PowerShell благодарит Кевина за то, что он поделился с нами этим материалом. Читайте его блог — [PowerShellExplained.com][].

## <a name="concatenation"></a>Объединение

Первый класс методов можно называть объединением. По сути, они принимают несколько строк и объединяют их друг с другом. Объединение уже довольно давно используется для создания форматированных строк.

```powershell
$name = 'Kevin Marquette'
$message = 'Hello, ' + $name
```

Объединение отлично подходит для ситуаций, когда необходимо добавить всего несколько значений. Однако зачастую применять его довольно сложно.

```powershell
$first = 'Kevin'
$last = 'Marquette'
```

```powershell
$message = 'Hello, ' + $first + ' ' + $last + '.'
```

Этот простой пример читать уже труднее.

## <a name="variable-substitution"></a>Подстановка переменных

В PowerShell есть более простой вариант. Переменные можно задавать непосредственно в строках.

```powershell
$message = "Hello, $first $last."
```

Многое зависит от типа кавычек, в которые заключена строка. Строка, заключенная в двойные кавычки, допускает подстановку, а строка с одинарными кавычками — нет. Вы можете выбрать подходящий вариант в зависимости от ситуации.

## <a name="command-substitution"></a>Подстановка команд

Если вы пытаетесь получить значения свойств в строку, ситуация немного усложняется. Многие новички испытывают с этим проблемы. Позвольте мне сначала показать, что, по их мнению, должно сработать (по идее, все выглядит логично).

```powershell
$directory = Get-Item 'c:\windows'
$message = "Time: $directory.CreationTime"
```

Казалось бы, вы должны получить `CreationTime` из `$directory`, но вместо этого вы получаете в качестве значения `Time: c:\windows.CreationTime`. Причина в том, что подстановка такого типа распознает только базовую переменную. Она интерпретирует точку как часть строки, поэтому не сопоставляет значение на более глубоких уровнях.

Выходит так, что при помещении в строку этот объект предоставляет строку в качестве значения по умолчанию.
Некоторые объекты вместо этого предоставляют имя типа, например `System.Collections.Hashtable`. Это то, на что нужно обратить внимание.

PowerShell позволяет выполнять команды внутри строки с помощью специального синтаксиса. Это позволяет получить свойства этих объектов и выполнить любую другую команду для получения значения.

```powershell
$message = "Time: $($directory.CreationTime)"
```

Этот подход отлично подходит для определенных ситуаций, но в некоторых случаях может оказаться таким же неудобным, как объединение при наличии нескольких переменных.

### <a name="command-execution"></a>Выполнение команды

Команды можно выполнять внутри строки. Хотя так можно делать, мне это не нравится. Код быстро становится перегруженным, и его трудно отлаживать. Я либо использую команду и сохраняю ее результат в переменную, либо использую строку форматирования.

```powershell
$message = "Date: $(Get-Date)"
```

## <a name="format-string"></a>Строка форматирования

.NET позволяет отформатировать строки, с которыми довольно легко работать. Сначала позвольте продемонстрировать статический метод, после чего я покажу, как сделать то же самое с помощью ярлыка PowerShell.

```powershell
# .NET string format string
[string]::Format('Hello, {0} {1}.',$first,$last)

# PowerShell format string
'Hello, {0} {1}.' -f $first, $last
```

В этом случае строка анализируется на наличие токенов `{0}` и `{1}`, а затем этот номер используется для выбора среди предоставленных значений. Если вы хотите повторить одно значение в строке, можно повторно использовать его номер.

При таком подходе чем сложнее строка, тем больше значений будет получено.

### <a name="format-values-as-arrays"></a>Форматирование значений в виде массивов

Если строка форматирования слишком длинная, можно сначала поместить значения в массив.

```powershell
$values = @(
    "Kevin"
    "Marquette"
)
'Hello, {0} {1}.' -f $values
```

Это не сплаттинг, поскольку я передаю весь массив, но идея аналогична.

## <a name="advanced-formatting"></a>Расширенное форматирование

Я намеренно использовал для вызова .NET, так как для этой платформы уже хорошо [задокументировано][] множество вариантов форматирования. Для различных типов данных предусмотрены встроенные возможности форматирования.

```powershell
"{0:yyyyMMdd}" -f (Get-Date)
"Population {0:N0}" -f  8175133
```

Рассматривать я их не буду, лишь упомяну, что это очень эффективный механизм форматирования, который вы можете использовать при необходимости.

## <a name="joining-strings"></a>Объединение строк

Иногда требуется сцепить список значений вместе. Это можно сделать с помощью оператора `-join`. Он даже позволяет указать символ для объединения строк.

```powershell
$servers = @(
    'server1'
    'server2'
    'server3'
)

$servers  -join ','
```

Если с помощью `-join` необходимо объединить несколько строк без разделителя, необходимо указать пустую строку `''`.
Но если нужно сделать только это, существует более быстрый вариант.

```powershell
[string]::Concat('server1','server2','server3')
[string]::Concat($servers)
```

Также стоит отметить, что с помощью оператора `-split` строки можно разделить.

## <a name="join-path"></a>Join-Path

Этот командлет часто бывает неудобен, но он отлично подходит для создания пути к файлу.

```powershell
$folder = 'Temp'
Join-Path -Path 'c:\windows' -ChildPath $folder
```

Самое замечательное в нем то, что он правильно обрабатывает обратные косые черты, когда собирает значение воедино. Это особенно важно, если вы принимаете значения от пользователей или файлов конфигурации.

Он также прекрасно работает с `Split-Path` и `Test-Path`. Я также рассказываю о нем в публикации о [чтении и сохранении в файлы][].

## <a name="strings-are-arrays"></a>Строки как массивы

Прежде чем продолжить, я должен упомянуть о добавлении строк. Помните, что строка представляет собой обычный массив символов. При добавлении нескольких строк в одну каждый раз создается новый массив.

Взгляните на этот пример.

```powershell
$message = "Numbers: "
foreach($number in 1..10000)
{
    $message += " $number"
}
```

Он выглядит очень простым, но на самом деле при каждом добавлении строки в `$message` создается полностью новая строка. Для этого выделяется память, в нее копируются данные, а старая строка удаляется.
Ничего особенного, если такая операция выполняется лишь несколько раз, но в случае цикла, подобного этому, это может быть проблемой.

### <a name="stringbuilder"></a>StringBuilder

Класс StringBuilder также очень часто используется для создания больших строк из множества строк меньшего размера. Его популярность связана с тем, что он просто собирает все добавленные в него строки, а затем сцепляет их в конце при извлечении значения.

```powershell
$stringBuilder = New-Object -TypeName "System.Text.StringBuilder"

[void]$stringBuilder.Append("Numbers: ")
foreach($number in 1..10000)
{
    [void]$stringBuilder.Append(" $number")
}
$message = $stringBuilder.ToString()
```

Опять же, именно поэтому я использую .NET. Пользуюсь я им нечасто, но знать о его существовании будет не лишним.

## <a name="delineation-with-braces"></a>Разграничение с помощью фигурных скобок

Этот метод используется для объединения суффикса с другими данными в строке. Иногда у переменной отсутствует четкая граница слова.

```powershell
$test = "Bet"
$tester = "Better"
Write-Host "$test $tester ${test}ter"
```

Благодарю [/u/real_parbold][] за эту идею.

Вот альтернатива данному подходу.

```powershell
Write-Host "$test $tester $($test)ter"
Write-Host "{0} {1} {0}ter" -f $test, $tester
```

Лично я использую для этого строку форматирования, но знать о такой возможности будет не лишним на тот случай, если вам она где-то встретится.

## <a name="find-and-replace-tokens"></a>Токены для поиска и замены

Хотя большая часть этих функций призвана снизить потребность в развертывании собственного решения, их можно применять и в тех случаях, когда необходимо заменить строки в больших файлах шаблонов.

Предположим, что вы извлекли шаблон из файла, который содержит большой объем текста.

```powershell
$letter = Get-Content -Path TemplateLetter.txt -RAW
$letter = $letter -replace '#FULL_NAME#', 'Kevin Marquette'
```

У вас может быть много токенов для замены. Хитрость заключается в том, чтобы использовать особый токен, который легко найти и заменить. Я обычно использую специальный символ на обоих концах, чтобы его было проще отличить.

Недавно я обнаружил новый подход для решения этой задачи. Так как это довольно распространенная схема, я не стану вдаваться в дальнейшие подробности в этом разделе.

### <a name="replace-multiple-tokens"></a>Замена нескольких токенов

Если у меня есть список токенов, которые нужно заменить, я использую более универсальный подход. Я помещаю их в хэш-таблицу и перебираю их методом итерации, чтобы выполнить замену.

```powershell
$tokenList = @{
    Full_Name = 'Kevin Marquette'
    Location = 'Orange County'
    State = 'CA'
}

$letter = Get-Content -Path TemplateLetter.txt -RAW
foreach( $token in $tokenList.GetEnumerator() )
{
    $pattern = '#{0}#' -f $token.key
    $letter = $letter -replace $pattern, $token.Value
}
```

При необходимости эти токены можно загрузить из файла JSON или CSV.

### <a name="executioncontext-expandstring"></a>Метод ExpandString класса ExecutionContext

Существует отличный способ, который заключается в том, чтобы определить строку подстановки с помощью одинарных кавычек, а затем развернуть переменные. Взгляните на этот пример.

```powershell
$message = 'Hello, $Name!'
$name = 'Kevin Marquette'
$string = $ExecutionContext.InvokeCommand.ExpandString($message)
```

При вызове `.InvokeCommand.ExpandString` в текущем контексте выполнения для подстановки используются переменные в текущей области. Ключевым моментом здесь является то, что `$message` можно определить заранее, когда переменные еще даже не существуют.

Немного дополнив этот код, можно обеспечить повторное выполнение этой замены для различных значений.

```powershell
$message = 'Hello, $Name!'
$nameList = 'Mark Kraus','Kevin Marquette','Lee Dailey'
foreach($name in $nameList){
    $ExecutionContext.InvokeCommand.ExpandString($message)
}
```

Развивая эту идею, можно импортировать большой шаблон электронной почты из текстового файла. Я благодарю [Марк Краус][] за это [предложение][].

## <a name="whatever-works-the-best-for-you"></a>Оптимальный вариант для конкретной ситуации

Мне нравится подход со строками форматирования. Я применяю его для более сложных строк или при наличии нескольких переменных. Но для коротких строк подойдет любой из описанных методов.

## <a name="anything-else"></a>Другие возможности

Я лишь вкратце затронул эту тему. Я надеюсь, что вы сможете двигаться дальше, узнав для себя что-то новое.

<!-- link references -->
[Оригинал]: https://powershellexplained.com/2017-01-13-powershell-variable-substitution-in-strings/
[powershellexplained.com]: https://powershellexplained.com/
[@KevinMarquette]: https://twitter.com/KevinMarquette
[Марк Краус]: https://get-powershellblog.blogspot.com/
[предложение]: https://www.reddit.com/r/PowerShell/comments/5npf8h/kevmar_everything_you_wanted_to_know_about/dcdfia5/
[/u/real_parbold]: https://www.reddit.com/r/PowerShell/comments/5npf8h/kevmar_everything_you_wanted_to_know_about/dcdfm6p/
[чтении и сохранении в файлы]: https://powershellexplained.com/2017-03-18-Powershell-reading-and-saving-data-to-files/
[задокументировано]: /dotnet/api/system.string.format#overloads
