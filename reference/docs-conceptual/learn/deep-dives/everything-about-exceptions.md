---
title: Все, что вы хотели знать об исключениях
description: Обработка ошибок — это лишь часть процесса написания кода.
ms.date: 05/23/2020
ms.custom: contributor-KevinMarquette
ms.openlocfilehash: cd17ae6b5ded052c93923b648155a4dda8956b34
ms.sourcegitcommit: ba7315a496986451cfc1296b659d73ea2373d3f0
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/10/2020
ms.locfileid: "90012567"
---
# <a name="everything-you-wanted-to-know-about-exceptions"></a><span data-ttu-id="64f3c-103">Все, что вы хотели знать об исключениях</span><span class="sxs-lookup"><span data-stu-id="64f3c-103">Everything you wanted to know about exceptions</span></span>

<span data-ttu-id="64f3c-104">Обработка ошибок — это лишь часть процесса написания кода.</span><span class="sxs-lookup"><span data-stu-id="64f3c-104">Error handling is just part of life when it comes to writing code.</span></span> <span data-ttu-id="64f3c-105">Зачастую можно проверить, выполняются ли условия для ожидаемого поведения.</span><span class="sxs-lookup"><span data-stu-id="64f3c-105">We can often check and validate conditions for expected behavior.</span></span> <span data-ttu-id="64f3c-106">При возникновении непредвиденной ситуации необходимо переключиться на обработку исключений.</span><span class="sxs-lookup"><span data-stu-id="64f3c-106">When the unexpected happens, we turn to exception handling.</span></span> <span data-ttu-id="64f3c-107">Вы можете легко обрабатывать исключения, созданные кодом других разработчиков, или создавать собственные исключения, которые смогут обработать другие.</span><span class="sxs-lookup"><span data-stu-id="64f3c-107">You can easily handle exceptions generated by other people's code or you can generate your own exceptions for others to handle.</span></span>

> [!NOTE]
> <span data-ttu-id="64f3c-108">[Оригинал][] этой статьи впервые был опубликован в блоге автора [@KevinMarquette][].</span><span class="sxs-lookup"><span data-stu-id="64f3c-108">The [original version][] of this article appeared on the blog written by [@KevinMarquette][].</span></span> <span data-ttu-id="64f3c-109">Команда разработчиков PowerShell благодарит Кевина за то, что он поделился с нами этим материалом.</span><span class="sxs-lookup"><span data-stu-id="64f3c-109">The PowerShell team thanks Kevin for sharing this content with us.</span></span> <span data-ttu-id="64f3c-110">Читайте его блог — [PowerShellExplained.com][].</span><span class="sxs-lookup"><span data-stu-id="64f3c-110">Please check out his blog at [PowerShellExplained.com][].</span></span>

## <a name="basic-terminology"></a><span data-ttu-id="64f3c-111">Базовая терминология</span><span class="sxs-lookup"><span data-stu-id="64f3c-111">Basic terminology</span></span>

<span data-ttu-id="64f3c-112">Прежде чем двигаться дальше, необходимо разобраться с основными терминами.</span><span class="sxs-lookup"><span data-stu-id="64f3c-112">We need to cover some basic terms before we jump into this one.</span></span>

### <a name="exception"></a><span data-ttu-id="64f3c-113">Исключение</span><span class="sxs-lookup"><span data-stu-id="64f3c-113">Exception</span></span>

<span data-ttu-id="64f3c-114">Исключение подобно событию, которое создается, когда не удается справиться с проблемой путем обычной обработки ошибок.</span><span class="sxs-lookup"><span data-stu-id="64f3c-114">An Exception is like an event that is created when normal error handling can't deal with the issue.</span></span>
<span data-ttu-id="64f3c-115">Примерами проблем, которые приводят к исключениям, могут служить попытки деления числа на ноль и нехватка памяти.</span><span class="sxs-lookup"><span data-stu-id="64f3c-115">Trying to divide a number by zero or running out of memory are examples of something that creates an exception.</span></span> <span data-ttu-id="64f3c-116">Иногда автор кода, который вы используете, создает исключения для определенных проблем в случае их возникновения.</span><span class="sxs-lookup"><span data-stu-id="64f3c-116">Sometimes the author of the code you're using creates exceptions for certain issues when they happen.</span></span>

### <a name="throw-and-catch"></a><span data-ttu-id="64f3c-117">Throw и Catch</span><span class="sxs-lookup"><span data-stu-id="64f3c-117">Throw and Catch</span></span>

<span data-ttu-id="64f3c-118">Когда происходит исключение, мы говорим, что оно вызвано.</span><span class="sxs-lookup"><span data-stu-id="64f3c-118">When an exception happens, we say that an exception is thrown.</span></span> <span data-ttu-id="64f3c-119">Чтобы обработать вызванное исключение, его необходимо перехватить.</span><span class="sxs-lookup"><span data-stu-id="64f3c-119">To handle a thrown exception, you need to catch it.</span></span> <span data-ttu-id="64f3c-120">Если вызывается исключение, которое не перехватывается никакими объектами, выполнение скрипта прекращается.</span><span class="sxs-lookup"><span data-stu-id="64f3c-120">If an exception is thrown and it isn't caught by something, the script stops executing.</span></span>

### <a name="the-call-stack"></a><span data-ttu-id="64f3c-121">Стек вызовов</span><span class="sxs-lookup"><span data-stu-id="64f3c-121">The call stack</span></span>

<span data-ttu-id="64f3c-122">Стек вызовов — это список функций, которые вызывали друг друга.</span><span class="sxs-lookup"><span data-stu-id="64f3c-122">The call stack is the list of functions that have called each other.</span></span> <span data-ttu-id="64f3c-123">При вызове функции она добавляется в стек или вверх списка.</span><span class="sxs-lookup"><span data-stu-id="64f3c-123">When a function is called, it gets added to the stack or the top of the list.</span></span> <span data-ttu-id="64f3c-124">При выходе из функции или возврате ею значения она удаляется из стека.</span><span class="sxs-lookup"><span data-stu-id="64f3c-124">When the function exits or returns, it is removed from the stack.</span></span>

<span data-ttu-id="64f3c-125">При вызове исключения выполняется проверка этого стека вызовов, чтобы обработчик исключений мог его перехватить.</span><span class="sxs-lookup"><span data-stu-id="64f3c-125">When an exception is thrown, that call stack is checked in order for an exception handler to catch it.</span></span>

### <a name="terminating-and-non-terminating-errors"></a><span data-ttu-id="64f3c-126">Неустранимые и устранимые ошибки</span><span class="sxs-lookup"><span data-stu-id="64f3c-126">Terminating and non-terminating errors</span></span>

<span data-ttu-id="64f3c-127">Исключение обычно является неустранимой ошибкой.</span><span class="sxs-lookup"><span data-stu-id="64f3c-127">An exception is generally a terminating error.</span></span> <span data-ttu-id="64f3c-128">Вызванное исключение либо перехватывается, либо завершает текущее выполнение.</span><span class="sxs-lookup"><span data-stu-id="64f3c-128">A thrown exception is either be caught or it terminates the current execution.</span></span> <span data-ttu-id="64f3c-129">По умолчанию устранимая ошибка генерируется `Write-Error` и приводит к добавлению ошибки в выходной поток без вызова исключения.</span><span class="sxs-lookup"><span data-stu-id="64f3c-129">By default, a non-terminating error is generated by `Write-Error` and it adds an error to the output stream without throwing an exception.</span></span>

<span data-ttu-id="64f3c-130">Обращаю внимание на это потому, что `Write-Error` и другие устранимые ошибки не активируют `catch`.</span><span class="sxs-lookup"><span data-stu-id="64f3c-130">I point this out because `Write-Error` and other non-terminating errors do not trigger the `catch`.</span></span>

### <a name="swallowing-an-exception"></a><span data-ttu-id="64f3c-131">Игнорирование исключения</span><span class="sxs-lookup"><span data-stu-id="64f3c-131">Swallowing an exception</span></span>

<span data-ttu-id="64f3c-132">Это ситуация, когда ошибка перехватывается только для того, чтобы ее подавить.</span><span class="sxs-lookup"><span data-stu-id="64f3c-132">This is when you catch an error just to suppress it.</span></span> <span data-ttu-id="64f3c-133">Используйте эту возможность с осторожностью, поскольку это может существенно усложнить устранение неполадок.</span><span class="sxs-lookup"><span data-stu-id="64f3c-133">Do this with caution because it can make troubleshooting issues very difficult.</span></span>

## <a name="basic-command-syntax"></a><span data-ttu-id="64f3c-134">Основной синтаксис команды</span><span class="sxs-lookup"><span data-stu-id="64f3c-134">Basic command syntax</span></span>

<span data-ttu-id="64f3c-135">Ниже приведен краткий обзор основного синтаксиса обработки исключений, используемого в PowerShell.</span><span class="sxs-lookup"><span data-stu-id="64f3c-135">Here is a quick overview of the basic exception handling syntax used in PowerShell.</span></span>

### <a name="throw"></a><span data-ttu-id="64f3c-136">Ключевое слово throw</span><span class="sxs-lookup"><span data-stu-id="64f3c-136">Throw</span></span>

<span data-ttu-id="64f3c-137">Чтобы вызвать собственное событие исключения, воспользуйтесь ключевым словом `throw`.</span><span class="sxs-lookup"><span data-stu-id="64f3c-137">To create our own exception event, we throw an exception with the `throw` keyword.</span></span>

```powershell
function Start-Something
{
    throw "Bad thing happened"
}
```

<span data-ttu-id="64f3c-138">Это приведет к созданию исключения во время выполнения, которое является неустранимой ошибкой.</span><span class="sxs-lookup"><span data-stu-id="64f3c-138">This creates a runtime exception that is a terminating error.</span></span> <span data-ttu-id="64f3c-139">Оно обрабатывается с помощью `catch` в вызывающей функции или приводит к выходу из скрипта с сообщением следующего вида.</span><span class="sxs-lookup"><span data-stu-id="64f3c-139">It's handled by a `catch` in a calling function or exits the script with a message like this.</span></span>

```powershell
PS> Start-Something

Bad thing happened
At line:1 char:1
+ throw "Bad thing happened"
+ ~~~~~~~~~~~~~~~~~~~~~~~~~~
    + CategoryInfo          : OperationStopped: (Bad thing happened:String) [], RuntimeException
    + FullyQualifiedErrorId : Bad thing happened
```

#### <a name="write-error--erroraction-stop"></a><span data-ttu-id="64f3c-140">Параметр -ErrorAction Stop командлета Write-Error</span><span class="sxs-lookup"><span data-stu-id="64f3c-140">Write-Error -ErrorAction Stop</span></span>

<span data-ttu-id="64f3c-141">Я упоминал, что по умолчанию `Write-Error` не вызывает неустранимую ошибку.</span><span class="sxs-lookup"><span data-stu-id="64f3c-141">I mentioned that `Write-Error` doesn't throw a terminating error by default.</span></span> <span data-ttu-id="64f3c-142">Если указать `-ErrorAction Stop`, `Write-Error` создаст неустранимую ошибку, которую можно обработать с помощью `catch`.</span><span class="sxs-lookup"><span data-stu-id="64f3c-142">If you specify `-ErrorAction Stop`, `Write-Error`generates a terminating error that can be handled with a `catch`.</span></span>

```powershell
Write-Error -Message "Houston, we have a problem." -ErrorAction Stop
```

<span data-ttu-id="64f3c-143">Благодарю Ли Дейли за напоминание о том, что `-ErrorAction Stop` можно использовать таким образом.</span><span class="sxs-lookup"><span data-stu-id="64f3c-143">Thank you to Lee Dailey for reminding about using `-ErrorAction Stop` this way.</span></span>

#### <a name="cmdlet--erroraction-stop"></a><span data-ttu-id="64f3c-144">Параметр -ErrorAction Stop в командлете</span><span class="sxs-lookup"><span data-stu-id="64f3c-144">Cmdlet -ErrorAction Stop</span></span>

<span data-ttu-id="64f3c-145">Если указать `-ErrorAction Stop` в любой расширенной функции или командлете, все инструкции `Write-Error` будут преобразованы в неустранимые ошибки, которые приводят к остановке выполнения или могут быть обработаны с помощью `catch`.</span><span class="sxs-lookup"><span data-stu-id="64f3c-145">If you specify `-ErrorAction Stop` on any advanced function or cmdlet, it turns all `Write-Error` statements into terminating errors that stop execution or that can be handled by a `catch`.</span></span>

```powershell
Start-Something -ErrorAction Stop
```

### <a name="trycatch"></a><span data-ttu-id="64f3c-146">Try и Catch</span><span class="sxs-lookup"><span data-stu-id="64f3c-146">Try/Catch</span></span>

<span data-ttu-id="64f3c-147">Принцип обработки исключений в PowerShell (и многих других языках) состоит в том, что сначала к разделу кода применяется `try`, а если происходит ошибка, к нему применяется `catch`.</span><span class="sxs-lookup"><span data-stu-id="64f3c-147">The way exception handling works in PowerShell (and many other languages) is that you first `try` a section of code and if it throws an error, you can `catch` it.</span></span> <span data-ttu-id="64f3c-148">Приведем краткий пример.</span><span class="sxs-lookup"><span data-stu-id="64f3c-148">Here is a quick sample.</span></span>

```powershell
try
{
    Start-Something
}
catch
{
    Write-Output "Something threw an exception"
}

try
{
    Start-Something -ErrorAction Stop
}
catch
{
    Write-Output "Something threw an exception or used Write-Error"
}
```

<span data-ttu-id="64f3c-149">Скрипт `catch` выполняется только в том случае, если произошла неустранимая ошибка.</span><span class="sxs-lookup"><span data-stu-id="64f3c-149">The `catch` script only runs if there's a terminating error.</span></span> <span data-ttu-id="64f3c-150">Если `try` выполняется правильно, `catch` пропускается.</span><span class="sxs-lookup"><span data-stu-id="64f3c-150">If the `try` executes correctly, then it skips over the `catch`.</span></span>

### <a name="tryfinally"></a><span data-ttu-id="64f3c-151">Try и Finally</span><span class="sxs-lookup"><span data-stu-id="64f3c-151">Try/Finally</span></span>

<span data-ttu-id="64f3c-152">Иногда ошибку обрабатывать не требуется, но необходимо выполнить определенный код в зависимости от того, было ли создано исключение.</span><span class="sxs-lookup"><span data-stu-id="64f3c-152">Sometimes you don't need to handle an error but still need some code to execute if an exception happens or not.</span></span> <span data-ttu-id="64f3c-153">Именно это и делает скрипт `finally`.</span><span class="sxs-lookup"><span data-stu-id="64f3c-153">A `finally` script does exactly that.</span></span>

<span data-ttu-id="64f3c-154">Взгляните на этот пример.</span><span class="sxs-lookup"><span data-stu-id="64f3c-154">Take a look at this example:</span></span>

```powershell
$command = [System.Data.SqlClient.SqlCommand]::New(queryString, connection)
$command.Connection.Open()
$command.ExecuteNonQuery()
$command.Connection.Close()
```

<span data-ttu-id="64f3c-155">Всякий раз, когда вы открываете ресурс или подключаетесь к нему, его следует закрыть.</span><span class="sxs-lookup"><span data-stu-id="64f3c-155">Anytime you open or connect to a resource, you should close it.</span></span> <span data-ttu-id="64f3c-156">Если `ExecuteNonQuery()` вызывает исключение, соединение не закрывается.</span><span class="sxs-lookup"><span data-stu-id="64f3c-156">If the `ExecuteNonQuery()` throws an exception, the connection isn't closed.</span></span> <span data-ttu-id="64f3c-157">Вот тот же код в блоке `try/finally`.</span><span class="sxs-lookup"><span data-stu-id="64f3c-157">Here is the same code inside a `try/finally` block.</span></span>

```powershell
$command = [System.Data.SqlClient.SqlCommand]::New(queryString, connection)
try
{
    $command.Connection.Open()
    $command.ExecuteNonQuery()
}
finally
{
    $command.Connection.Close()
}
```

<span data-ttu-id="64f3c-158">В этом примере соединение закрывается при возникновении ошибки.</span><span class="sxs-lookup"><span data-stu-id="64f3c-158">In this example, the connection is closed if there's an error.</span></span> <span data-ttu-id="64f3c-159">Оно также закрывается при отсутствии ошибок.</span><span class="sxs-lookup"><span data-stu-id="64f3c-159">It also is closed if there's no error.</span></span> <span data-ttu-id="64f3c-160">При этом всякий раз выполняется скрипт `finally`.</span><span class="sxs-lookup"><span data-stu-id="64f3c-160">The `finally` script runs every time.</span></span>

<span data-ttu-id="64f3c-161">Так как исключение не перехватывается, оно по-прежнему распространяет в стек вызовов.</span><span class="sxs-lookup"><span data-stu-id="64f3c-161">Because you're not catching the exception, it still gets propagated up the call stack.</span></span>

### <a name="trycatchfinally"></a><span data-ttu-id="64f3c-162">Try, catch и finally</span><span class="sxs-lookup"><span data-stu-id="64f3c-162">Try/Catch/Finally</span></span>

<span data-ttu-id="64f3c-163">Вполне допустимо использовать `catch` и `finally` вместе.</span><span class="sxs-lookup"><span data-stu-id="64f3c-163">It's perfectly valid to use `catch` and `finally` together.</span></span> <span data-ttu-id="64f3c-164">В большинстве случаев используется либо один, либо другой скрипт, но вам могут встретиться сценарии, в которых используются они оба.</span><span class="sxs-lookup"><span data-stu-id="64f3c-164">Most of the time you'll use one or the other, but you may find scenarios where you use both.</span></span>

## <a name="psitem"></a><span data-ttu-id="64f3c-165">$PSItem</span><span class="sxs-lookup"><span data-stu-id="64f3c-165">$PSItem</span></span>

<span data-ttu-id="64f3c-166">Теперь, когда мы разобрались с основами, можно изучить вопрос подробнее.</span><span class="sxs-lookup"><span data-stu-id="64f3c-166">Now that we got the basics out of the way, we can dig a little deeper.</span></span>

<span data-ttu-id="64f3c-167">В блоке `catch` существует автоматическая переменная (`$PSItem` или `$_`) типа `ErrorRecord`, содержащая сведения об исключении.</span><span class="sxs-lookup"><span data-stu-id="64f3c-167">Inside the `catch` block, there's an automatic variable (`$PSItem` or `$_`) of type `ErrorRecord` that contains the details about the exception.</span></span> <span data-ttu-id="64f3c-168">Ниже приведен краткий обзор некоторых ключевых свойств.</span><span class="sxs-lookup"><span data-stu-id="64f3c-168">Here is a quick overview of some of the key properties.</span></span>

<span data-ttu-id="64f3c-169">В этих примерах для создания такого исключения я использовал недопустимый путь в `ReadAllText`.</span><span class="sxs-lookup"><span data-stu-id="64f3c-169">For these examples, I used an invalid path in `ReadAllText` to generate this exception.</span></span>

```powershell
[System.IO.File]::ReadAllText( '\\test\no\filefound.log')
```

### <a name="psitemtostring"></a><span data-ttu-id="64f3c-170">PSItem.ToString()</span><span class="sxs-lookup"><span data-stu-id="64f3c-170">PSItem.ToString()</span></span>

<span data-ttu-id="64f3c-171">Этот метод позволяет получить максимально понятное сообщение, которое можно использовать при ведении журнала и выводе общего результата.</span><span class="sxs-lookup"><span data-stu-id="64f3c-171">This gives you the cleanest message to use in logging and general output.</span></span> <span data-ttu-id="64f3c-172">`ToString()` вызывается автоматически, если в строку помещена переменная `$PSItem`.</span><span class="sxs-lookup"><span data-stu-id="64f3c-172">`ToString()` is automatically called if `$PSItem` is placed inside a string.</span></span>

```powershell
catch
{
    Write-Output "Ran into an issue: $($PSItem.ToString())"
}

catch
{
    Write-Output "Ran into an issue: $PSItem"
}
```

### <a name="psiteminvocationinfo"></a><span data-ttu-id="64f3c-173">$PSItem.InvocationInfo</span><span class="sxs-lookup"><span data-stu-id="64f3c-173">$PSItem.InvocationInfo</span></span>

<span data-ttu-id="64f3c-174">Это свойство содержит дополнительные сведения, собираемые PowerShell о функции или скрипте, которые вызвали исключение.</span><span class="sxs-lookup"><span data-stu-id="64f3c-174">This property contains additional information collected by PowerShell about the function or script where the exception was thrown.</span></span> <span data-ttu-id="64f3c-175">Ниже приведено свойство `InvocationInfo` из примера созданного мною исключения.</span><span class="sxs-lookup"><span data-stu-id="64f3c-175">Here is the `InvocationInfo` from the sample exception that I created.</span></span>

```powershell
PS> $PSItem.InvocationInfo | Format-List *

MyCommand             : Get-Resource
BoundParameters       : {}
UnboundArguments      : {}
ScriptLineNumber      : 5
OffsetInLine          : 5
ScriptName            : C:\blog\throwerror.ps1
Line                  :     Get-Resource
PositionMessage       : At C:\blog\throwerror.ps1:5 char:5
                        +     Get-Resource
                        +     ~~~~~~~~~~~~
PSScriptRoot          : C:\blog
PSCommandPath         : C:\blog\throwerror.ps1
InvocationName        : Get-Resource
```

<span data-ttu-id="64f3c-176">Здесь приведены важные сведения: имя `ScriptName`, строка кода `Line` и номер строки `ScriptLineNumber`, из которой инициирован вызов.</span><span class="sxs-lookup"><span data-stu-id="64f3c-176">The important details here show the `ScriptName`, the `Line` of code and the `ScriptLineNumber` where the invocation started.</span></span>

### <a name="psitemscriptstacktrace"></a><span data-ttu-id="64f3c-177">$PSItem.ScriptStackTrace</span><span class="sxs-lookup"><span data-stu-id="64f3c-177">$PSItem.ScriptStackTrace</span></span>

<span data-ttu-id="64f3c-178">Это свойство показывает порядок вызовов функций, ведущих к коду, в котором создано исключение.</span><span class="sxs-lookup"><span data-stu-id="64f3c-178">This property shows the order of function calls that got you to the code where the exception was generated.</span></span>

```powershell
PS> $PSItem.ScriptStackTrace
at Get-Resource, C:\blog\throwerror.ps1: line 13
at Start-Something, C:\blog\throwerror.ps1: line 5
at <ScriptBlock>, C:\blog\throwerror.ps1: line 18
```

<span data-ttu-id="64f3c-179">Я выполняю вызовы функций в пределах одного скрипта, но таким же образом можно отслеживать функции при использовании нескольких скриптов.</span><span class="sxs-lookup"><span data-stu-id="64f3c-179">I'm only making calls to functions in the same script but this would track the calls if multiple scripts were involved.</span></span>

### <a name="psitemexception"></a><span data-ttu-id="64f3c-180">$PSItem.Exception</span><span class="sxs-lookup"><span data-stu-id="64f3c-180">$PSItem.Exception</span></span>

<span data-ttu-id="64f3c-181">Это, собственно, и есть вызванное исключение.</span><span class="sxs-lookup"><span data-stu-id="64f3c-181">This is the actual exception that was thrown.</span></span>

#### <a name="psitemexceptionmessage"></a><span data-ttu-id="64f3c-182">$PSItem.Exception.Message</span><span class="sxs-lookup"><span data-stu-id="64f3c-182">$PSItem.Exception.Message</span></span>

<span data-ttu-id="64f3c-183">Это общее сообщение, которое описывает исключение и служит хорошей отправной точкой при устранении неполадок.</span><span class="sxs-lookup"><span data-stu-id="64f3c-183">This is the general message that describes the exception and is a good starting point when troubleshooting.</span></span> <span data-ttu-id="64f3c-184">Для большинства исключений предусмотрены сообщения по умолчанию, но при необходимости их можно настроить по своему усмотрению.</span><span class="sxs-lookup"><span data-stu-id="64f3c-184">Most exceptions have a default message but can also be set to something custom when the exception is thrown.</span></span>

```powershell
PS> $PSItem.Exception.Message

Exception calling "ReadAllText" with "1" argument(s): "The network path was not found."
```

<span data-ttu-id="64f3c-185">Это еще одно сообщение, возвращаемое при вызове `$PSItem.ToString()`, если для `ErrorRecord` не задан другой его вариант.</span><span class="sxs-lookup"><span data-stu-id="64f3c-185">This is also the message returned when calling `$PSItem.ToString()` if there was not one set on the `ErrorRecord`.</span></span>

#### <a name="psitemexceptioninnerexception"></a><span data-ttu-id="64f3c-186">$PSItem.Exception.InnerException</span><span class="sxs-lookup"><span data-stu-id="64f3c-186">$PSItem.Exception.InnerException</span></span>

<span data-ttu-id="64f3c-187">Исключения могут содержать внутренние исключения.</span><span class="sxs-lookup"><span data-stu-id="64f3c-187">Exceptions can contain inner exceptions.</span></span> <span data-ttu-id="64f3c-188">Это часто случается, когда вызываемый код перехватывает одно исключение и вызывает другое.</span><span class="sxs-lookup"><span data-stu-id="64f3c-188">This is often the case when the code you're calling catches an exception and throws a different exception.</span></span> <span data-ttu-id="64f3c-189">Исходное исключение помещается в новое исключение.</span><span class="sxs-lookup"><span data-stu-id="64f3c-189">The original exception is placed inside the new exception.</span></span>

```powershell
PS> $PSItem.Exception.InnerExceptionMessage
The network path was not found.
```

<span data-ttu-id="64f3c-190">Я вернусь к этому вопросу позже, когда буду рассказывать о повторном вызове исключений.</span><span class="sxs-lookup"><span data-stu-id="64f3c-190">I will revisit this later when I talk about re-throwing exceptions.</span></span>

#### <a name="psitemexceptionstacktrace"></a><span data-ttu-id="64f3c-191">$PSItem.Exception.StackTrace</span><span class="sxs-lookup"><span data-stu-id="64f3c-191">$PSItem.Exception.StackTrace</span></span>

<span data-ttu-id="64f3c-192">Это свойство `StackTrace` для исключения.</span><span class="sxs-lookup"><span data-stu-id="64f3c-192">This is the `StackTrace` for the exception.</span></span> <span data-ttu-id="64f3c-193">Я продемонстрировал принцип работы свойства `ScriptStackTrace` выше, но это предназначено для вызовов управляемого кода.</span><span class="sxs-lookup"><span data-stu-id="64f3c-193">I showed a `ScriptStackTrace` above, but this one is for the calls to managed code.</span></span>

```Output
at System.IO.FileStream.Init(String path, FileMode mode, FileAccess access, Int32 rights, Boolean
 useRights, FileShare share, Int32 bufferSize, FileOptions options, SECURITY_ATTRIBUTES secAttrs,
 String msgPath, Boolean bFromProxy, Boolean useLongPath, Boolean checkHost)
at System.IO.FileStream..ctor(String path, FileMode mode, FileAccess access, FileShare share, Int32
 bufferSize, FileOptions options, String msgPath, Boolean bFromProxy, Boolean useLongPath, Boolean
 checkHost)
at System.IO.StreamReader..ctor(String path, Encoding encoding, Boolean detectEncodingFromByteOrderMarks,
 Int32 bufferSize, Boolean checkHost)
at System.IO.File.InternalReadAllText(String path, Encoding encoding, Boolean checkHost)
at CallSite.Target(Closure , CallSite , Type , String )
```

<span data-ttu-id="64f3c-194">Эта трассировка стека выполняется только в случае, если событие вызвано из управляемого кода.</span><span class="sxs-lookup"><span data-stu-id="64f3c-194">You only get this stack trace when the event is thrown from managed code.</span></span> <span data-ttu-id="64f3c-195">Я вызываю функцию .NET Framework напрямую, так что это все, что можно увидеть в этом примере.</span><span class="sxs-lookup"><span data-stu-id="64f3c-195">I'm calling a .NET framework function directly so that is all we can see in this example.</span></span> <span data-ttu-id="64f3c-196">Как правило, трассировка стека просматривается, чтобы найти место остановки кода и начало системных вызовов.</span><span class="sxs-lookup"><span data-stu-id="64f3c-196">Generally when you're looking at a stack trace, you're looking for where your code stops and the system calls begin.</span></span>

## <a name="working-with-exceptions"></a><span data-ttu-id="64f3c-197">Работа с исключениями</span><span class="sxs-lookup"><span data-stu-id="64f3c-197">Working with exceptions</span></span>

<span data-ttu-id="64f3c-198">Для работы с исключениями недостаточно базового синтаксиса и основных свойств.</span><span class="sxs-lookup"><span data-stu-id="64f3c-198">There is more to exceptions than the basic syntax and exception properties.</span></span>

### <a name="catching-typed-exceptions"></a><span data-ttu-id="64f3c-199">Перехват типизированных исключений</span><span class="sxs-lookup"><span data-stu-id="64f3c-199">Catching typed exceptions</span></span>

<span data-ttu-id="64f3c-200">Исключения можно перехватывать избирательно.</span><span class="sxs-lookup"><span data-stu-id="64f3c-200">You can be selective with the exceptions that you catch.</span></span> <span data-ttu-id="64f3c-201">Исключения имеют тип, задав который можно перехватить только исключения определенного типа.</span><span class="sxs-lookup"><span data-stu-id="64f3c-201">Exceptions have a type and you can specify the type of exception you want to catch.</span></span>

```powershell
try
{
    Start-Something -Path $path
}
catch [System.IO.FileNotFoundException]
{
    Write-Output "Could not find $path"
}
catch [System.IO.IOException]
{
        Write-Output "IO error with the file: $path"
}
```

<span data-ttu-id="64f3c-202">Каждый блок `catch` проверяется на наличие исключения заданного типа, пока не будет найден тот, в котором оно создается.</span><span class="sxs-lookup"><span data-stu-id="64f3c-202">The exception type is checked for each `catch` block until one is found that matches your exception.</span></span>
<span data-ttu-id="64f3c-203">Важно понимать, что исключения могут наследоваться от других исключений.</span><span class="sxs-lookup"><span data-stu-id="64f3c-203">It's important to realize that exceptions can inherit from other exceptions.</span></span> <span data-ttu-id="64f3c-204">В приведенном выше примере `FileNotFoundException` наследуется от `IOException`.</span><span class="sxs-lookup"><span data-stu-id="64f3c-204">In the example above, `FileNotFoundException` inherits from `IOException`.</span></span> <span data-ttu-id="64f3c-205">Поэтому, если исключение `IOException` было первым, будет вызвано именно оно.</span><span class="sxs-lookup"><span data-stu-id="64f3c-205">So if the `IOException` was first, then it would get called instead.</span></span> <span data-ttu-id="64f3c-206">Даже если совпадений несколько, вызывается только один блок catch.</span><span class="sxs-lookup"><span data-stu-id="64f3c-206">Only one catch block is invoked even if there are multiple matches.</span></span>

<span data-ttu-id="64f3c-207">При наличии исключения `System.IO.PathTooLongException` исключение `IOException` распознается как совпадение, но при наличии исключения `InsufficientMemoryException` перехватывать его нечем, поэтому оно распространится по стеку.</span><span class="sxs-lookup"><span data-stu-id="64f3c-207">If we had a `System.IO.PathTooLongException`, the `IOException` would match but if we had a `InsufficientMemoryException` then nothing would catch it and it would propagate up the stack.</span></span>

### <a name="catch-multiple-types-at-once"></a><span data-ttu-id="64f3c-208">Одновременный перехват нескольких типов</span><span class="sxs-lookup"><span data-stu-id="64f3c-208">Catch multiple types at once</span></span>

<span data-ttu-id="64f3c-209">С помощью одной инструкции `catch` можно перехватывать несколько типов исключений одновременно.</span><span class="sxs-lookup"><span data-stu-id="64f3c-209">It's possible to catch multiple exception types with the same `catch` statement.</span></span>

```powershell
try
{
    Start-Something -Path $path -ErrorAction Stop
}
catch [System.IO.DirectoryNotFoundException],[System.IO.FileNotFoundException]
{
    Write-Output "The path or file was not found: [$path]"
}
catch [System.IO.IOException]
{
    Write-Output "IO error with the file: [$path]"
}
```

<span data-ttu-id="64f3c-210">Благодарю `/u/Sheppard_Ra` за предложение добавить этот раздел.</span><span class="sxs-lookup"><span data-stu-id="64f3c-210">Thank you `/u/Sheppard_Ra` for suggesting this addition.</span></span>

### <a name="throwing-typed-exceptions"></a><span data-ttu-id="64f3c-211">Вызов типизированных исключений</span><span class="sxs-lookup"><span data-stu-id="64f3c-211">Throwing typed exceptions</span></span>

<span data-ttu-id="64f3c-212">В PowerShell можно вызывать типизированные исключения.</span><span class="sxs-lookup"><span data-stu-id="64f3c-212">You can throw typed exceptions in PowerShell.</span></span> <span data-ttu-id="64f3c-213">Вместо вызова `throw` со строкой:</span><span class="sxs-lookup"><span data-stu-id="64f3c-213">Instead of calling `throw` with a string:</span></span>

```powershell
throw "Could not find: $path"
```

<span data-ttu-id="64f3c-214">используйте ускоритель исключений следующим образом:</span><span class="sxs-lookup"><span data-stu-id="64f3c-214">Use an exception accelerator like this:</span></span>

```powershell
throw [System.IO.FileNotFoundException] "Could not find: $path"
```

<span data-ttu-id="64f3c-215">Но в таком случае необходимо указать сообщение.</span><span class="sxs-lookup"><span data-stu-id="64f3c-215">But you have to specify a message when you do it that way.</span></span>

<span data-ttu-id="64f3c-216">Можно также создать новый экземпляр исключения для вызова.</span><span class="sxs-lookup"><span data-stu-id="64f3c-216">You can also create a new instance of an exception to be thrown.</span></span> <span data-ttu-id="64f3c-217">При этом сообщение является необязательным, так как в системе предусмотрены сообщения по умолчанию для всех встроенных исключений.</span><span class="sxs-lookup"><span data-stu-id="64f3c-217">The message is optional when you do this because the system has default messages for all built-in exceptions.</span></span>

```powershell
throw [System.IO.FileNotFoundException]::new()
throw [System.IO.FileNotFoundException]::new("Could not find path: $path")
```

<span data-ttu-id="64f3c-218">Если вы не используете PowerShell 5.0 или более поздних версий, необходимо использовать устаревший подход с применением `New-Object`.</span><span class="sxs-lookup"><span data-stu-id="64f3c-218">If you're not using PowerShell 5.0 or higher, you must use the older `New-Object` approach.</span></span>

```powershell
throw (New-Object -TypeName System.IO.FileNotFoundException )
throw (New-Object -TypeName System.IO.FileNotFoundException -ArgumentList "Could not find path: $path")
```

<span data-ttu-id="64f3c-219">Как упоминалось в предыдущем разделе, используя типизированное исключение, вы (или другие пользователи) можете перехватывать исключения по типу.</span><span class="sxs-lookup"><span data-stu-id="64f3c-219">By using a typed exception, you (or others) can catch the exception by the type as mentioned in the previous section.</span></span>

#### <a name="write-error--exception"></a><span data-ttu-id="64f3c-220">Параметр -Exception командлета Write-Error</span><span class="sxs-lookup"><span data-stu-id="64f3c-220">Write-Error -Exception</span></span>

<span data-ttu-id="64f3c-221">Эти типизированные исключения можно добавить в `Write-Error` и при этом перехватывать исключения с помощью `catch` по их типу.</span><span class="sxs-lookup"><span data-stu-id="64f3c-221">We can add these typed exceptions to `Write-Error` and we can still `catch` the errors by exception type.</span></span> <span data-ttu-id="64f3c-222">Используйте командлет `Write-Error`, как показано в следующих примерах.</span><span class="sxs-lookup"><span data-stu-id="64f3c-222">Use `Write-Error` like in these examples:</span></span>

```powershell
# with normal message
Write-Error -Message "Could not find path: $path" -Exception ([System.IO.FileNotFoundException]::new()) -ErrorAction Stop

# With message inside new exception
Write-Error -Exception ([System.IO.FileNotFoundException]::new("Could not find path: $path")) -ErrorAction Stop

# Pre PS 5.0
Write-Error -Exception ([System.IO.FileNotFoundException]"Could not find path: $path") -ErrorAction Stop

Write-Error -Message "Could not find path: $path" -Exception ( New-Object -TypeName System.IO.FileNotFoundException ) -ErrorAction Stop
```

<span data-ttu-id="64f3c-223">Теперь исключение можно перехватить следующим образом.</span><span class="sxs-lookup"><span data-stu-id="64f3c-223">Then we can catch it like this:</span></span>

```powershell
catch [System.IO.FileNotFoundException]
{
    Write-Log $PSItem.ToString()
}
```

#### <a name="the-big-list-of-net-exceptions"></a><span data-ttu-id="64f3c-224">Большой список исключений .NET</span><span class="sxs-lookup"><span data-stu-id="64f3c-224">The big list of .NET exceptions</span></span>

<span data-ttu-id="64f3c-225">В дополнение к этой публикации я (при помощи [Сообщество Reddit/r/PowerShell][]) составил основной список, который содержит сотни исключений .NET.</span><span class="sxs-lookup"><span data-stu-id="64f3c-225">I compiled a master list with the help of the [Reddit/r/PowerShell community][] that contains hundreds of .NET exceptions to complement this post.</span></span>

- <span data-ttu-id="64f3c-226">[Большой список исключений .NET][]</span><span class="sxs-lookup"><span data-stu-id="64f3c-226">[The big list of .NET exceptions][]</span></span>

<span data-ttu-id="64f3c-227">Для начала я ищу в этом списке исключения, которые хорошо подходят для моей ситуации.</span><span class="sxs-lookup"><span data-stu-id="64f3c-227">I start by searching that list for exceptions that feel like they would be a good fit for my situation.</span></span> <span data-ttu-id="64f3c-228">Следует попытаться использовать исключения в базовом пространстве имен `System`.</span><span class="sxs-lookup"><span data-stu-id="64f3c-228">You should try to use exceptions in the base `System` namespace.</span></span>

### <a name="exceptions-are-objects"></a><span data-ttu-id="64f3c-229">Исключения как объекты</span><span class="sxs-lookup"><span data-stu-id="64f3c-229">Exceptions are objects</span></span>

<span data-ttu-id="64f3c-230">При использовании большого числа типизированных исключений следует помнить, что они являются объектами.</span><span class="sxs-lookup"><span data-stu-id="64f3c-230">If you start using a lot of typed exceptions, remember that they are objects.</span></span> <span data-ttu-id="64f3c-231">Различные исключения имеют разные конструкторы и свойства.</span><span class="sxs-lookup"><span data-stu-id="64f3c-231">Different exceptions have different constructors and properties.</span></span> <span data-ttu-id="64f3c-232">В документации [FileNotFoundException][] для `System.IO.FileNotFoundException` указано, что для этого исключения можно передать сообщение и путь к файлу.</span><span class="sxs-lookup"><span data-stu-id="64f3c-232">If we look at the [FileNotFoundException][] documentation for `System.IO.FileNotFoundException`, we see that we can pass in a message and a file path.</span></span>

```powershell
[System.IO.FileNotFoundException]::new("Could not find file", $path)
```

<span data-ttu-id="64f3c-233">У него есть свойство `FileName`, которое предоставляет путь к этому файлу.</span><span class="sxs-lookup"><span data-stu-id="64f3c-233">And it has a `FileName` property that exposes that file path.</span></span>

```powershell
catch [System.IO.FileNotFoundException]
{
    Write-Output $PSItem.Exception.FileName
}
```

<span data-ttu-id="64f3c-234">Сведения о других конструкторах и свойствах объектов см. в документации по [Документация по .NET][].</span><span class="sxs-lookup"><span data-stu-id="64f3c-234">You should consult the [.NET documentation][] for other constructors and object properties.</span></span>

### <a name="re-throwing-an-exception"></a><span data-ttu-id="64f3c-235">Повторный вызов исключения</span><span class="sxs-lookup"><span data-stu-id="64f3c-235">Re-throwing an exception</span></span>

<span data-ttu-id="64f3c-236">Если блок `catch` используется только для вызова того же исключения с помощью `throw`, перехватывать его с помощью `catch` не стоит.</span><span class="sxs-lookup"><span data-stu-id="64f3c-236">If all you're going to do in your `catch` block is `throw` the same exception, then don't `catch` it.</span></span> <span data-ttu-id="64f3c-237">Перехватывать с помощью `catch` следует только исключение, которое планируется обработать или использовать для выполнения какого-либо действия.</span><span class="sxs-lookup"><span data-stu-id="64f3c-237">You should only `catch` an exception that you plan to handle or perform some action when it happens.</span></span>

<span data-ttu-id="64f3c-238">Бывают случаи, когда необходимо выполнить действие с исключением, но при этом вызывать его повторно, чтобы его можно было обработать на более низком уровне.</span><span class="sxs-lookup"><span data-stu-id="64f3c-238">There are times where you want to perform an action on an exception but re-throw the exception so something downstream can deal with it.</span></span> <span data-ttu-id="64f3c-239">Мы можем написать сообщение или записать проблему в журнал ближе к месту обнаружения, а обработать эту проблему на другом уровне стека.</span><span class="sxs-lookup"><span data-stu-id="64f3c-239">We could write a message or log the problem close to where we discover it but handle the issue further up the stack.</span></span>

```powershell
catch
{
    Write-Log $PSItem.ToString()
    throw $PSItem
}
```

<span data-ttu-id="64f3c-240">Интересно, что `throw` можно вызвать из `catch`, и тогда текущее исключение будет вызвано повторно.</span><span class="sxs-lookup"><span data-stu-id="64f3c-240">Interestingly enough, we can call `throw` from within the `catch` and it re-throws the current exception.</span></span>

```powershell
catch
{
    Write-Log $PSItem.ToString()
    throw
}
```

<span data-ttu-id="64f3c-241">Исключение создается повторно, чтобы сохранить исходные сведения о выполнении, например исходный скрипт и номер строки.</span><span class="sxs-lookup"><span data-stu-id="64f3c-241">We want to re-throw the exception to preserve the original execution information like source script and line number.</span></span> <span data-ttu-id="64f3c-242">Если на этом этапе вызывается новое исключение, оно скрывает первоначальное место его возникновения.</span><span class="sxs-lookup"><span data-stu-id="64f3c-242">If we throw a new exception at this point, it hides where the exception started.</span></span>

#### <a name="re-throwing-a-new-exception"></a><span data-ttu-id="64f3c-243">Повторный вызов нового исключения</span><span class="sxs-lookup"><span data-stu-id="64f3c-243">Re-throwing a new exception</span></span>

<span data-ttu-id="64f3c-244">Если вы перехватили исключение, но хотите вызвать другое, следует вложить исходное исключение в новое.</span><span class="sxs-lookup"><span data-stu-id="64f3c-244">If you catch an exception but you want to throw a different one, then you should nest the original exception inside the new one.</span></span> <span data-ttu-id="64f3c-245">Это позволяет объекту на более низком уровне стека получить к нему доступ как к `$PSItem.Exception.InnerException`.</span><span class="sxs-lookup"><span data-stu-id="64f3c-245">This allows someone down the stack to access it as the `$PSItem.Exception.InnerException`.</span></span>

```powershell
catch
{
    throw [System.MissingFieldException]::new('Could not access field',$PSItem.Exception)
}
```

#### <a name="pscmdletthrowterminatingerror"></a><span data-ttu-id="64f3c-246">$PSCmdlet.ThrowTerminatingError()</span><span class="sxs-lookup"><span data-stu-id="64f3c-246">$PSCmdlet.ThrowTerminatingError()</span></span>

<span data-ttu-id="64f3c-247">Единственное, что мне не нравится в использовании `throw` для необработанных исключений, заключается в том, что в качестве причины ошибки в сообщении об ошибке указывается инструкция `throw` и номер проблемной строки.</span><span class="sxs-lookup"><span data-stu-id="64f3c-247">The one thing that I don't like about using `throw` for raw exceptions is that the error message points at the `throw` statement and indicates that line is where the problem is.</span></span>

```Output
Unable to find the specified file.
At line:31 char:9
+         throw [System.IO.FileNotFoundException]::new()
+         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    + CategoryInfo          : OperationStopped: (:) [], FileNotFoundException
    + FullyQualifiedErrorId : Unable to find the specified file.
```

<span data-ttu-id="64f3c-248">Если сообщение об ошибке сообщает о том, что скрипт работает неправильно из-за вызова `throw` в строке 31, оно не подходит для отображения пользователям скрипта.</span><span class="sxs-lookup"><span data-stu-id="64f3c-248">Having the error message tell me that my script is broken because I called `throw` on line 31 is a bad message for users of your script to see.</span></span> <span data-ttu-id="64f3c-249">Оно не сообщает им ничего полезного.</span><span class="sxs-lookup"><span data-stu-id="64f3c-249">It doesn't tell them anything useful.</span></span>

<span data-ttu-id="64f3c-250">Декстер Дхами отметил, что для устранения этой проблемы я могу использовать `ThrowTerminatingError()`.</span><span class="sxs-lookup"><span data-stu-id="64f3c-250">Dexter Dhami pointed out that I can use `ThrowTerminatingError()` to correct that.</span></span>

```powershell
$PSCmdlet.ThrowTerminatingError(
    [System.Management.Automation.ErrorRecord]::new(
        ([System.IO.FileNotFoundException]"Could not find $Path"),
        'My.ID',
        [System.Management.Automation.ErrorCategory]::OpenError,
        $MyObject
    )
)
```

<span data-ttu-id="64f3c-251">Если предположить, что метод `ThrowTerminatingError()` вызван внутри функции с именем `Get-Resource`, сообщение об ошибке будет таким, как показано ниже.</span><span class="sxs-lookup"><span data-stu-id="64f3c-251">If we assume that `ThrowTerminatingError()` was called inside a function called `Get-Resource`, then this is the error that we would see.</span></span>

```Output
Get-Resource : Could not find C:\Program Files (x86)\Reference
Assemblies\Microsoft\Framework\.NETPortable\v4.6\System.IO.xml
At line:6 char:5
+     Get-Resource -Path $Path
+     ~~~~~~~~~~~~
    + CategoryInfo          : OpenError: (:) [Get-Resource], FileNotFoundException
    + FullyQualifiedErrorId : My.ID,Get-Resource
```

<span data-ttu-id="64f3c-252">Вы заметили, что в качестве источника проблемы в нем указана функция `Get-Resource`?</span><span class="sxs-lookup"><span data-stu-id="64f3c-252">Do you see how it points to the `Get-Resource` function as the source of the problem?</span></span> <span data-ttu-id="64f3c-253">Теперь пользователь узнает что-то полезное.</span><span class="sxs-lookup"><span data-stu-id="64f3c-253">That tells the user something useful.</span></span>

<span data-ttu-id="64f3c-254">Так как значением `$PSItem` является `ErrorRecord`, можно таким же образом использовать `ThrowTerminatingError` для повторного вызова.</span><span class="sxs-lookup"><span data-stu-id="64f3c-254">Because `$PSItem` is an `ErrorRecord`, we can also use `ThrowTerminatingError` this way to re-throw.</span></span>

```powershell
catch
{
    $PSCmdlet.ThrowTerminatingError($PSItem)
}
```

<span data-ttu-id="64f3c-255">При этом источник ошибки изменится на командлет, а внутренние данные о функции будут скрыты от его пользователей.</span><span class="sxs-lookup"><span data-stu-id="64f3c-255">This changes the source of the error to the Cmdlet and hide the internals of your function from the users of your Cmdlet.</span></span>

## <a name="try-can-create-terminating-errors"></a><span data-ttu-id="64f3c-256">Try как источник неустранимой ошибки</span><span class="sxs-lookup"><span data-stu-id="64f3c-256">Try can create terminating errors</span></span>

<span data-ttu-id="64f3c-257">Кирк Манро указывает, что некоторые исключения являются неустранимыми ошибками только при выполнении внутри блока `try/catch`.</span><span class="sxs-lookup"><span data-stu-id="64f3c-257">Kirk Munro points out that some exceptions are only terminating errors when executed inside a `try/catch` block.</span></span> <span data-ttu-id="64f3c-258">В этом предоставленном им примере исключение во время выполнения вызывается вследствие деления на ноль.</span><span class="sxs-lookup"><span data-stu-id="64f3c-258">Here is the example he gave me that generates a divide by zero runtime exception.</span></span>

```powershell
function Start-Something { 1/(1-1) }
```

<span data-ttu-id="64f3c-259">Вызовем его теперь следующим образом, чтобы код содержал ошибку, но при этом выводилось сообщение.</span><span class="sxs-lookup"><span data-stu-id="64f3c-259">Then invoke it like this to see it generate the error and still output the message.</span></span>

```powershell
&{ Start-Something; Write-Output "We did it. Send Email" }
```

<span data-ttu-id="64f3c-260">Однако если поместить этот же код в `try/catch`, то происходит нечто иное.</span><span class="sxs-lookup"><span data-stu-id="64f3c-260">But by placing that same code inside a `try/catch`, we see something else happen.</span></span>

```powershell
try
{
    &{ Start-Something; Write-Output "We did it. Send Email" }
}
catch
{
    Write-Output "Notify Admin to fix error and send email"
}
```

<span data-ttu-id="64f3c-261">Ошибка становится неустранимой, а первое сообщение не выводится.</span><span class="sxs-lookup"><span data-stu-id="64f3c-261">We see the error become a terminating error and not output the first message.</span></span> <span data-ttu-id="64f3c-262">Не нравится мне в этом то, что при наличии такого кода в функции поведение становится другим, если использовать `try/catch`.</span><span class="sxs-lookup"><span data-stu-id="64f3c-262">What I don't like about this one is that you can have this code in a function and it acts differently if someone is using a `try/catch`.</span></span>

<span data-ttu-id="64f3c-263">Сам я не сталкивался с такой проблемой, но это крайний случай, о котором следует помнить.</span><span class="sxs-lookup"><span data-stu-id="64f3c-263">I have not ran into issues with this myself but it is corner case to be aware of.</span></span>

### <a name="pscmdletthrowterminatingerror-inside-trycatch"></a><span data-ttu-id="64f3c-264">Метод $PSCmdlet.ThrowTerminatingError() в try/catch</span><span class="sxs-lookup"><span data-stu-id="64f3c-264">$PSCmdlet.ThrowTerminatingError() inside try/catch</span></span>

<span data-ttu-id="64f3c-265">Одна из особенностей `$PSCmdlet.ThrowTerminatingError()` заключается в том, что в командлете этот метод вызывает неустранимую ошибку, но после выхода из него ошибка становится устранимой.</span><span class="sxs-lookup"><span data-stu-id="64f3c-265">One nuance of `$PSCmdlet.ThrowTerminatingError()` is that it creates a terminating error within your Cmdlet but it turns into a non-terminating error after it leaves your Cmdlet.</span></span> <span data-ttu-id="64f3c-266">Из-за этого тому, кто вызывает функцию, приходится решать, как следует обрабатывать такую ошибку.</span><span class="sxs-lookup"><span data-stu-id="64f3c-266">This leaves the burden on the caller of your function to decide how to handle the error.</span></span> <span data-ttu-id="64f3c-267">В этом случае можно превратить ее снова в неустранимую ошибку с помощью `-ErrorAction Stop` или воспользоваться вызовом из `try{...}catch{...}`.</span><span class="sxs-lookup"><span data-stu-id="64f3c-267">They can turn it back into a terminating error by using `-ErrorAction Stop` or calling it from within a `try{...}catch{...}`.</span></span>

### <a name="public-function-templates"></a><span data-ttu-id="64f3c-268">Шаблоны общих функций</span><span class="sxs-lookup"><span data-stu-id="64f3c-268">Public function templates</span></span>

<span data-ttu-id="64f3c-269">В одной из последних бесед с Кирком Манро мы говорили о том, что он помещает каждый блок `begin`, `process` и `end` во всех своих расширенных функциях в блок `try{...}catch{...}`.</span><span class="sxs-lookup"><span data-stu-id="64f3c-269">One last take a way I had with my conversation with Kirk Munro was that he places a `try{...}catch{...}` around every `begin`, `process` and `end` block in all of his advanced functions.</span></span> <span data-ttu-id="64f3c-270">В этих универсальных блоках catch у него есть одна строка с методом `$PSCmdlet.ThrowTerminatingError($PSItem)` для обработки всех исключений, вызываемых его функциями.</span><span class="sxs-lookup"><span data-stu-id="64f3c-270">In those generic catch blocks, he has a single line using `$PSCmdlet.ThrowTerminatingError($PSItem)` to deal with all exceptions leaving his functions.</span></span>

```powershell
function Start-Something
{
    [CmdletBinding()]
    param()

    process
    {
        try
        {
            ...
        }
        catch
        {
            $PSCmdlet.ThrowTerminatingError($PSItem)
        }
    }
}
```

<span data-ttu-id="64f3c-271">Поскольку в его функциях все находится в операторе `try`, весь код работает единообразно.</span><span class="sxs-lookup"><span data-stu-id="64f3c-271">Because everything is in a `try` statement within his functions, everything acts consistently.</span></span> <span data-ttu-id="64f3c-272">Это также позволяет выводить для пользователя понятные сообщения об ошибках, в которых скрыты данные о внутреннем коде.</span><span class="sxs-lookup"><span data-stu-id="64f3c-272">This also gives clean errors to the end user that hides the internal code from the generated error.</span></span>

## <a name="trap"></a><span data-ttu-id="64f3c-273">Ключевое слово trap</span><span class="sxs-lookup"><span data-stu-id="64f3c-273">Trap</span></span>

<span data-ttu-id="64f3c-274">Я уделил много внимания особенностям блока `try/catch`.</span><span class="sxs-lookup"><span data-stu-id="64f3c-274">I focused on the `try/catch` aspect of exceptions.</span></span> <span data-ttu-id="64f3c-275">Однако прежде чем закрывать эту тему, нужно упомянуть об одной устаревшей функции.</span><span class="sxs-lookup"><span data-stu-id="64f3c-275">But there's one legacy feature I need to mention before we wrap this up.</span></span>

<span data-ttu-id="64f3c-276">Ключевое слово `trap` помещается в скрипт или функцию для перехвата всех исключений, возникающих в соответствующей области.</span><span class="sxs-lookup"><span data-stu-id="64f3c-276">A `trap` is placed in a script or function to catch all exceptions that happen in that scope.</span></span> <span data-ttu-id="64f3c-277">При возникновении исключения выполняется код в ловушке `trap`, а затем продолжается выполнение стандартного кода.</span><span class="sxs-lookup"><span data-stu-id="64f3c-277">When an exception happens, the code in the `trap` is executed and then the normal code continues.</span></span> <span data-ttu-id="64f3c-278">Если происходит несколько исключений, ловушка вызывается снова и снова.</span><span class="sxs-lookup"><span data-stu-id="64f3c-278">If multiple exceptions happen, then the trap is called over and over.</span></span>

```powershell
trap
{
    Write-Log $PSItem.ToString()
}

throw [System.Exception]::new('first')
throw [System.Exception]::new('second')
throw [System.Exception]::new('third')
```

<span data-ttu-id="64f3c-279">Я лично никогда не применял этот подход. Однако, судя по скриптам администраторов и контроллеров, которые заносят в журнал абсолютно все исключения, а затем продолжают выполнение, могу сказать, что в нем есть своя польза.</span><span class="sxs-lookup"><span data-stu-id="64f3c-279">I personally never adopted this approach but I can see the value in admin or controller scripts that log any and all exceptions, then still continue to execute.</span></span>

## <a name="closing-remarks"></a><span data-ttu-id="64f3c-280">Заключительное слово</span><span class="sxs-lookup"><span data-stu-id="64f3c-280">Closing remarks</span></span>

<span data-ttu-id="64f3c-281">Добавление соответствующей обработки исключений в скрипты не только делает эти скрипты более стабильными, но и упрощает устранение таких исключений.</span><span class="sxs-lookup"><span data-stu-id="64f3c-281">Adding proper exception handling to your scripts not only make them more stable, but also makes it easier for you to troubleshoot those exceptions.</span></span>

<span data-ttu-id="64f3c-282">Я уделил так много внимания `throw`, так как это основное понятие, которым мы оперируем при обсуждении обработки исключений.</span><span class="sxs-lookup"><span data-stu-id="64f3c-282">I spent a lot of time talking `throw` because it is a core concept when talking about exception handling.</span></span> <span data-ttu-id="64f3c-283">В PowerShell также предоставляется командлет `Write-Error`, справляющийся со всеми ситуациями, в которых следовало бы использовать `throw`.</span><span class="sxs-lookup"><span data-stu-id="64f3c-283">PowerShell also gave us `Write-Error` that handles all the situations where you would use `throw`.</span></span> <span data-ttu-id="64f3c-284">Так что изложенное в этой статье вовсе не означает, что вам обязательно необходимо использовать `throw`.</span><span class="sxs-lookup"><span data-stu-id="64f3c-284">So don't think that you need to be using `throw` after reading this.</span></span>

<span data-ttu-id="64f3c-285">Теперь, когда я подробно рассказал об обработке исключений, я собираюсь заняться вопросом использования `Write-Error -Stop` для создания ошибок в коде.</span><span class="sxs-lookup"><span data-stu-id="64f3c-285">Now that I have taken the time to write about exception handling in this detail, I'm going to switch over to using `Write-Error -Stop` to generate errors in my code.</span></span> <span data-ttu-id="64f3c-286">Я также собираюсь воспользоваться советом Кирка и перейти на использование `ThrowTerminatingError` в качестве обработчика исключений для каждой функции.</span><span class="sxs-lookup"><span data-stu-id="64f3c-286">I'm also going to take Kirk's advice and make `ThrowTerminatingError` my goto exception handler for every function.</span></span>

<!-- link references -->
[powershellexplained.com]: https://powershellexplained.com/
[Оригинал]: https://powershellexplained.com/2017-04-10-Powershell-exceptions-everything-you-ever-wanted-to-know/
[original version]: https://powershellexplained.com/2017-04-10-Powershell-exceptions-everything-you-ever-wanted-to-know/
[@KevinMarquette]: https://twitter.com/KevinMarquette
[Сообщество Reddit/r/PowerShell]: https://www.reddit.com/r/PowerShell/comments/64866o/kevmar_all_net_46_exceptions_list_for_use_with/
[Reddit/r/PowerShell community]: https://www.reddit.com/r/PowerShell/comments/64866o/kevmar_all_net_46_exceptions_list_for_use_with/
[Большой список исключений .NET]: https://powershellexplained.com/2017-04-07-all-dotnet-exception-list
[The big list of .NET exceptions]: https://powershellexplained.com/2017-04-07-all-dotnet-exception-list
[FileNotFoundException]: /dotnet/api/System.IO.FileNotFoundException
[Документация по .NET]: /dotnet/api
[.NET documentation]: /dotnet/api
