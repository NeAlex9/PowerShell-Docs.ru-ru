---
ms.date: 08/23/2018
keywords: powershell,командлет
title: Принцип работы конвейеров PowerShell
ms.assetid: 6be50926-7943-4ef7-9499-4490d72a63fb
ms.openlocfilehash: fc7c7f57bdce458185a0f5bdb8bc1fbbd81d0d61
ms.sourcegitcommit: b6871f21bd666f9cd71dd336bb3f844cf472b56c
ms.translationtype: MTE95
ms.contentlocale: ru-RU
ms.lasthandoff: 02/03/2019
ms.locfileid: "55681104"
---
# <a name="understanding-pipelines"></a>Принцип работы конвейеров

Конвейеры представляют собой последовательность соединенных сегментов канала. Элементы, перемещающиеся по конвейеру, проходят через каждый сегмент. Для создания конвейера в PowerShell команды соединяются друг с другом с помощью оператора канала |. Результат каждой команды используется в качестве входных данных для следующей.

Эта нотация конвейера похожа на нотацию, которая используется в других оболочках. На первый взгляд не совсем понятно, чем отличаются конвейеры в PowerShell. Хотя вы видите на экране текст, PowerShell передает по конвейеру между командами не текст, а объекты.

## <a name="the-powershell-pipeline"></a>Конвейер PowerShell

Пожалуй, конвейеры являются наиболее полезной концепцией в интерфейсах командной строки. При правильном использовании конвейеры упрощают как обработку сложных команд, так и отслеживание потока их выполнения. Каждая команда в конвейере (которая называется элементом конвейера) обычно поочередно передает свои выходные данные в следующую команду конвейера в виде объектов. Команды обрабатывают только один объект за раз. Это снижает потребление ресурсов и позволяет сразу же получать выходные данные.

Например, вы можете использовать командлет `Out-Host` для принудительного постраничного отображения выходных данных из другой команды. На экране эти данные будут показаны как обычный текст, разбитый на страницы:

```powershell
Get-ChildItem -Path C:\WINDOWS\System32 | Out-Host -Paging
```

```Output
    Directory: C:\WINDOWS\system32

Mode                LastWriteTime         Length Name
----                -------------         ------ ----
d-----        4/12/2018   2:15 AM                0409
d-----        5/13/2018  11:31 PM                1033
d-----        4/11/2018   4:38 PM                AdvancedInstallers
d-----        5/13/2018  11:13 PM                af-ZA
d-----        5/13/2018  11:13 PM                am-et
d-----        4/11/2018   4:38 PM                AppLocker
d-----        5/13/2018  11:31 PM                appmgmt
d-----        7/11/2018   2:05 AM                appraiser
d---s-        4/12/2018   2:20 AM                AppV
d-----        5/13/2018  11:10 PM                ar-SA
d-----        5/13/2018  11:13 PM                as-IN
d-----        8/14/2018   9:03 PM                az-Latn-AZ
d-----        5/13/2018  11:13 PM                be-BY
d-----        5/13/2018  11:10 PM                BestPractices
d-----        5/13/2018  11:10 PM                bg-BG
d-----        5/13/2018  11:13 PM                bn-BD
d-----        5/13/2018  11:13 PM                bn-IN
d-----        8/14/2018   9:03 PM                Boot
d-----        8/14/2018   9:03 PM                bs-Latn-BA
d-----        4/11/2018   4:38 PM                Bthprops
d-----        4/12/2018   2:19 AM                ca-ES
d-----        8/14/2018   9:03 PM                ca-ES-valencia
d-----        5/13/2018  10:46 PM                CatRoot
d-----        8/23/2018   5:07 PM                catroot2
<SPACE> next page; <CR> next line; Q quit
...
```

Разбиение на страницы также снижает потребление ресурсов ЦП, так обработку продолжает командлет `Out-Host`, когда он получает всю страницу для отображения. Командлет, стоящий в конвейере выше, приостанавливает выполнение, пока не будет готова следующая страница выходных данных.

Разницу можно увидеть в диспетчере задач Windows, отслеживая ресурсы ЦП и памяти, используемые PowerShell. Выполните следующую команду: `Get-ChildItem C:\Windows -Recurse`. Сравните использование ресурсов ЦП и памяти с помощью этой команды: `Get-ChildItem C:\Windows -Recurse | Out-Host -Paging`.

## <a name="objects-in-the-pipeline"></a>Объекты в конвейере

При запуске командлета в PowerShell вы видите выходные данные в виде текста — именно так в окне консоли и должны отображаться объекты. В текстовом представлении могут отображаться не все свойства выводимого объекта.

Например, рассмотрим командлет `Get-Location`. Если запустить `Get-Location` в корневой папке диска C (ваше текущее расположение), вы увидите следующий результат:

```
PS> Get-Location

Path
----
C:\
```

Эти выходные данные в виде текста содержат сводную информацию, а не полное представление объекта, возвращаемого командлетом `Get-Location`. Процесс, который форматирует данные для отображения на экране, добавляет к выходным данным заголовок.

При передаче выходных данных по конвейеру в командлет `Get-Member` вы получите информацию об объекте, возвращаемом командлетом `Get-Location`.

```powershell
PS> Get-Location | Get-Member
```

```Output
   TypeName: System.Management.Automation.PathInfo

Name         MemberType Definition
----         ---------- ----------
Equals       Method     bool Equals(System.Object obj)
GetHashCode  Method     int GetHashCode()
GetType      Method     type GetType()
ToString     Method     string ToString()
Drive        Property   System.Management.Automation.PSDriveInfo Drive {get;}
Path         Property   string Path {get;}
Provider     Property   System.Management.Automation.ProviderInfo Provider {get;}
ProviderPath Property   string ProviderPath {get;}
```

Командлет `Get-Location` возвращает объект **PathInfo**, который содержит текущий путь и другие сведения.
