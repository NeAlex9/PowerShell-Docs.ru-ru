---
ms.date: 07/10/2019
keywords: jea,powershell,безопасность
title: Возможности ролей JEA
ms.openlocfilehash: 613557d03bb481f9280a06ca1506166a18b4dab2
ms.sourcegitcommit: d43f66071f1f33b350d34fa1f46f3a35910c5d24
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/23/2019
ms.locfileid: "74416774"
---
# <a name="jea-role-capabilities"></a>Возможности ролей JEA

При создании конечной точки JEA потребуется определить одну или несколько "возможностей ролей", описывающих, что именно пользователь может сделать в сеансе JEA. Возможность роли — это файл данных PowerShell с расширением `.psrc`, содержащий все командлеты, функции, поставщики и внешние программы, которые должны быть доступны для подключающихся пользователей.

## <a name="determine-which-commands-to-allow"></a>Определение разрешаемых команд

Прежде всего, при создании файла возможности роли нужно определить, к чему именно потребуется доступ пользователям. Этот процесс сбора требований может занять некоторое время, однако он крайне важен. Предоставление пользователям доступа к слишком малому набору командлетов и функций может помешать их нормальной работе. Открыв доступ к слишком большому числу командлетов и функций, вы можете предоставить пользователям больше возможностей, чем предусмотрено, тем самым понизив уровень вашей безопасности.

То, как вы будете это делать, зависит от вашей организации и целей. Следующие советы помогут убедиться, что вы встали на правильный путь.

1. **Определите**, какие команды пользователи применяют для выполнения поставленных задач. Для этого можно опросить ИТ-специалистов, проверить сценарии автоматизации либо проанализировать журналы или записи сеансов PowerShell.
2. По возможности **замените** используемые программы командной строки на эквиваленты PowerShell, чтобы сделать аудит и настройку JEA максимально удобными. Внешние программы не поддерживают такую детальную настройку ограничений, как собственные командлеты PowerShell и функции в JEA.
3. **Ограничьте** область действия командлетов, разрешив только отдельные параметры и их значения. Это особенно важно в том случае, если пользователи должны управлять только частью системы.
4. **Создайте** настраиваемые функции на замену сложным командам или командам, которые трудно ограничить в JEA. Простая функция, включающая в себя сложную команду или применяющая дополнительную логику проверки, повышает уровень контроля и упрощает работу администраторов и конечных пользователей.
5. **Проверьте** полученный список допустимых команд на соответствие потребностям пользователей или служб автоматизации и при необходимости скорректируйте его.

### <a name="examples-of-potentially-dangerous-commands"></a>Примеры потенциально опасных команд

Важно тщательно отбирать команды, чтобы конечная точка JEA не позволяла пользователю повысить свои права.

> [!IMPORTANT]
> Важные сведения, необходимые для успеха пользователя: команды в сеансе JEA часто запускаются с повышенными привилегиями.

В таблице ниже приведено несколько примеров команд, которые в состоянии без ограничений быть использованы злоумышленниками. Этот список не является исчерпывающим и служит лишь отправной точкой для дальнейших действий.

|                                            Риск                                            |                                Пример                                |                                                                              Связанные команды                                                                              |
| ------------------------------------------------------------------------------------------ | --------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Предоставление прав администратора подключающемуся пользователю для обхода JEA                                | `Add-LocalGroupMember -Member 'CONTOSO\jdoe' -Group 'Administrators'` | `Add-ADGroupMember`, `Add-LocalGroupMember`, `net.exe`, `dsadd.exe`                                                                                                        |
| Выполнение произвольного кода, например вредоносных программ, эксплойтов или пользовательских сценариев для обхода защиты | `Start-Process -FilePath '\\san\share\malware.exe'`                   | `Start-Process`, `New-Service`, `Invoke-Item`, `Invoke-WmiMethod`, `Invoke-CimMethod`, `Invoke-Expression`, `Invoke-Command`, `New-ScheduledTask`, `Register-ScheduledJob` |

## <a name="create-a-role-capability-file"></a>Создание файла возможностей ролей

Вы можете создать новый файл возможности роли с помощью командлета [New-PSRoleCapabilityFile](/powershell/module/microsoft.powershell.core/new-psrolecapabilityfile?view=powershell-6).

```powershell
New-PSRoleCapabilityFile -Path .\MyFirstJEARole.psrc
```

Полученный файл возможностей роли должен быть изменен, чтобы разрешить команды, необходимые для роли. Справочная документация PowerShell содержит несколько примеров того, как можно настроить такой файл.

### <a name="allowing-powershell-cmdlets-and-functions"></a>Разрешение функций и командлетов PowerShell

Чтобы разрешить пользователям запускать функции или командлеты PowerShell, добавьте имя функции или командлета в поле VisibleFunctions или VisibleCmdlets. Если вы не уверены, является ли команда командлетом или функцией, выполните `Get-Command <name>` и проверьте свойство **CommandType** в выходных данных.

```powershell
VisibleCmdlets = 'Restart-Computer', 'Get-NetIPAddress'
```

Иногда область действия командлета или функции слишком широка для потребностей пользователей. Например, администратору DNS, скорее всего, потребуется только доступ для перезапуска службы DNS. В средах с несколькими клиентами клиенты имеют доступ к средствам самостоятельного управления. Клиенты должны быть ограничены, чтобы они могли управлять только собственными ресурсами. В этих случаях можно ограничить доступные параметры из командлета или функции.

```powershell
VisibleCmdlets = @{ Name = 'Restart-Computer'; Parameters = @{ Name = 'Name' }}
```

В более сложных сценариях может потребоваться ограничить значения, которые можно задать для этих параметров. Возможности ролей позволяют задать набор допустимых значений или шаблон регулярного выражения, который определяет, какие входные данные допустимы.

```powershell
VisibleCmdlets = @{ Name = 'Restart-Service'; Parameters = @{ Name = 'Name'; ValidateSet = 'Dns', 'Spooler' }},
                 @{ Name = 'Start-Website'; Parameters = @{ Name = 'Name'; ValidatePattern = 'HR_*' }}
```

> [!NOTE]
> [Общие параметры PowerShell](/powershell/module/microsoft.powershell.core/about/about_commonparameters) всегда разрешены, даже если ограничить доступные параметры.
> Их не следует явно указывать в поле "Parameters".

В следующей таблице описаны различные способы настройки видимого командлета или видимой функции.
Вы можете комбинировать любые приведенные ниже примеры в поле **VisibleCmdlets**.

|                                           Пример                                           |                                                             Вариант использования                                                              |
| ------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------- |
| `'My-Func'` или `@{ Name = 'My-Func' }`                                                      | Разрешает пользователю выполнить `My-Func` без каких-либо ограничений для параметров.                                                      |
| `'MyModule\My-Func'`                                                                        | Разрешает пользователю выполнить `My-Func` из модуля `MyModule` без каких-либо ограничений для параметров.                           |
| `'My-*'`                                                                                    | Разрешает пользователю выполнить любой командлет или функцию с командой `My`.                                                                 |
| `'*-Func'`                                                                                  | Разрешает пользователю выполнить любой командлет или функцию с существительным `Func`.                                                               |
| `@{ Name = 'My-Func'; Parameters = @{ Name = 'Param1'}, @{ Name = 'Param2' }}`              | Разрешает пользователю выполнить `My-Func` с параметрами `Param1` и `Param2`. Для параметров можно задать любое значение.          |
| `@{ Name = 'My-Func'; Parameters = @{ Name = 'Param1'; ValidateSet = 'Value1', 'Value2' }}` | Разрешает пользователю выполнить `My-Func` с параметром `Param1`. Для параметра можно задать только значение "Value1" или "Value2".        |
| `@{ Name = 'My-Func'; Parameters = @{ Name = 'Param1'; ValidatePattern = 'contoso.*' }}`    | Разрешает пользователю выполнить `My-Func` с параметром `Param1`. Для параметра можно задать любое значение, начинающееся с "contoso". |

> [!WARNING]
> Для обеспечения наилучшей безопасности при определении видимых командлетов или функций рекомендуется не использовать подстановочные знаки. Вместо этого следует явно указать каждую надежную команду, чтобы убедиться, что не будут случайно разрешены никакие другие команды, которые используют такую же схему именования.

Вы не можете применить **ValidatePattern** вместе с **ValidateSet** для одного командлета или одной функции.

В противном случае **ValidatePattern** переопределит **ValidateSet**.

Дополнительные сведения о **ValidatePattern** см. в [этой записи блога *Hey, Scripting Guy!* ](https://devblogs.microsoft.com/scripting/validate-powershell-parameters-before-running-the-script/) и справочных материалах о [регулярных выражениях PowerShell](/powershell/module/microsoft.powershell.core/about/about_regular_expressions).

### <a name="allowing-external-commands-and-powershell-scripts"></a>Разрешение внешних команд и сценариев PowerShell

Чтобы разрешить пользователям запускать исполняемые файлы и сценарии PowerShell (PS1) в сеансе JEA, нужно добавить полный путь к каждой программы в поле **VisibleExternalCommands**.

```powershell
VisibleExternalCommands = 'C:\Windows\System32\whoami.exe', 'C:\Program Files\Contoso\Scripts\UpdateITSoftware.ps1'
```

По возможности следует использовать командлеты или функции PowerShell, эквивалентные любым внешним исполняемым файлам, которые вы разрешаете, так как для этих функций и командлетов PowerShell вы можете управлять разрешенными параметрами.

Многие исполняемые файлы дают возможность считать текущее состояние и затем изменить его, указав различные параметры.

Например, рассмотрим роль администратора файлового сервера, который управляет набором общих сетевых ресурсов, размещенных в системе. Одним из способов управления ими является использование `net share`. Однако разрешение использования **net.exe** очень опасно, так как администратор может легко воспользоваться этой командой для получения прав администратора с помощью `net group Administrators unprivilegedjeauser /add`. Безопаснее разрешить командлет [Get-SmbShare](/powershell/module/smbshare/get-smbshare), которой дает тот же результат, но имеет гораздо более ограниченную область действия.

Делая внешние команды доступными для пользователей в рамках сеанса JEA, всегда указывайте полный путь к исполняемому файлу. Это предотвращает выполнение одноименных потенциально вредоносных программ, расположенных в других местах в системе.

### <a name="allowing-access-to-powershell-providers"></a>Разрешение доступа к поставщикам PowerShell

По умолчанию в сеансах JEA нет доступных поставщиков PowerShell. Это служит для снижения риска раскрытия конфиденциальной информации и параметров конфигурации подключающемуся пользователю.

При необходимости доступ к поставщикам PowerShell можно разрешить с помощью команды `VisibleProviders`. Для просмотра полного списка поставщиков запустите `Get-PSProvider`.

```powershell
VisibleProviders = 'Registry'
```

Для простых задач, которым требуется доступ к файловой системе, реестру, хранилищу сертификатов, или других конфиденциальных поставщиков можно написать настраиваемую функцию, которая работает с поставщиком от имени пользователя. К функциям, командлетам и внешним программам, доступным в сеансе JEA, не применяются те же ограничения, что и для JEA. Они могут по умолчанию получить доступ к любому поставщику. В случаях, когда требуется скопировать файлы из конечной точки JEA или на нее, рассмотрите возможность использования [диска пользователя](session-configurations.md#user-drive).

### <a name="creating-custom-functions"></a>Создание настраиваемых функций

В файле возможностей роли можно создать настраиваемые функции, чтобы упростить выполнение сложных задач для конечных пользователей. Настраиваемые функции также удобны, когда требуется расширенная логика проверки для значений параметров командлета. Вы можете составлять простые функции в поле **FunctionDefinitions**:

```powershell
VisibleFunctions = 'Get-TopProcess'

FunctionDefinitions = @{
    Name = 'Get-TopProcess'

    ScriptBlock = {
        param($Count = 10)

        Get-Process | Sort-Object -Property CPU -Descending |
            Microsoft.PowerShell.Utility\Select-Object -First $Count
    }
}
```

> [!IMPORTANT]
> Не забудьте добавить имя настраиваемых функций в поле **VisibleFunctions**, чтобы пользователи JEA могли запускать их.

Основная часть (блок сценария) настраиваемых функций запускается в языковом режиме по умолчанию для данной системы, и на нее не налагаются ограничения языка JEA. Это означает, что функции имеют доступ к файловой системе и реестру и могут запускать команды, которые не были сделаны видимыми в файле возможностей роли. Будьте внимательны, чтобы избежать выполнения произвольного кода при использовании параметров. Не передавайте вводимые пользователем данные напрямую в такие командлеты, как `Invoke-Expression`.

В приведенном выше примере можно заметить, что полное имя модуля (FQMN) `Microsoft.PowerShell.Utility\Select-Object` было использовано вместо сокращенного `Select-Object`.
Функции, определенные в файлах возможностей роли, по-прежнему подчиняются области действия сеансов JEA, что включает в себя функции прокси-сервера, создаваемые JEA для ограничения существующих команд.

По умолчанию `Select-Object` является во всех сеансах JEA ограниченным командлетом, который не позволяет выбрать произвольные свойства для объектов. Чтобы использовать `Select-Object` в функциях без ограничений, требуется явно запросить полную реализацию, указав полное имя модуля. Любой ограниченный командлет в сеансе JEA имеет те же ограничения при вызове из функции. Дополнительные сведения см. в разделе [about_Command_Precedence](/powershell/module/microsoft.powershell.core/about/about_command_precedence).

При наличии нескольких настраиваемых функций может быть проще поместить их в модуль сценария PowerShell. Затем можно сделать эти функции видимыми в сеансе JEA с помощью поля **VisibleFunctions**, как и в случае со встроенными и сторонними модулями.

Для корректной работы завершения при нажатии клавиши TAB в сеансах JEA необходимо включить встроенную функцию `tabexpansion2` в список **VisibleFunctions**.

## <a name="place-role-capabilities-in-a-module"></a>Помещение возможностей ролей в модуль

Чтобы среда PowerShell обнаружила файл возможности роли, его следует поместить в папку **RoleCapabilities** в модуле PowerShell. Этот модуль может храниться в любой папке, включенной в переменную среды `$env:PSModulePath`, однако не следует помещать его в папку System32 либо в папку, где не являющиеся доверенными подключающиеся пользователи могут изменить его. Ниже приведен пример создания базового модуля сценария PowerShell с именем **ContosoJEA** в папке `$env:ProgramFiles`.

```powershell
# Create a folder for the module
$modulePath = Join-Path $env:ProgramFiles "WindowsPowerShell\Modules\ContosoJEA"
New-Item -ItemType Directory -Path $modulePath

# Create an empty script module and module manifest.
# At least one file in the module folder must have the same name as the folder itself.
New-Item -ItemType File -Path (Join-Path $modulePath "ContosoJEAFunctions.psm1")
New-ModuleManifest -Path (Join-Path $modulePath "ContosoJEA.psd1") -RootModule "ContosoJEAFunctions.psm1"

# Create the RoleCapabilities folder and copy in the PSRC file
$rcFolder = Join-Path $modulePath "RoleCapabilities"
New-Item -ItemType Directory $rcFolder
Copy-Item -Path .\MyFirstJEARole.psrc -Destination $rcFolder
```

Дополнительные сведения о модулях PowerShell см. в разделе [Основные сведения о модуле PowerShell](/powershell/scripting/developer/windows-powershell).

## <a name="updating-role-capabilities"></a>Изменение возможностей ролей

Изменить файл возможностей роли, чтобы обновить параметры, можно в любое время. Все новые сеансы JEA, запущенные после изменения возможности роли, будут использовать обновленные возможности.

Именно поэтому так важно управлять доступом к папке возможностей роли. Изменять файлы возможностей ролей должно быть разрешено только наиболее надежным администраторам. Если пользователь, не являющийся доверенным, может изменять файлы возможностей ролей, он легко сможет получить доступ к командлетам, повышающим его права.

Администраторам, желающим заблокировать доступ к возможностям ролей, следует убедиться, что учетная запись Local System имеет доступ на чтение к файлам возможностей ролей и содержащим их модулям.

## <a name="how-role-capabilities-are-merged"></a>Способ слияния возможностей ролей

Пользователи получают доступ ко всем соответствующим возможностям ролей в [файле конфигурации сеанса](session-configurations.md) при входе в сеанс JEA. JEA пытается предоставить такому пользователю наиболее широкий набор команд, разрешенных для любой из этих ролей.

### <a name="visiblecmdlets-and-visiblefunctions"></a>VisibleCmdlets и VisibleFunctions

Наиболее сложная логика слияния затрагивает командлеты и функции, параметры и значения параметров которых могут быть ограничены в JEA.

Действуют следующие правила:

1. Если командлет является видимым всего в одной роли, он видим для пользователя с любыми применимыми ограничениями параметров.
2. Если командлет является видимым в нескольких ролях, каждая из которых налагает на него схожие ограничения, он видим пользователю с такими ограничениями.
3. Если командлет является видимым в нескольких ролях, каждая из которых разрешает иной набор параметров, пользователю видим как командлет, так и все параметры, определенные для каждой роли.
   Если одна из ролей не имеет ограничений для параметров, будет разрешены все параметры.
4. Если одна из ролей определяет набор или шаблон проверок для параметра командлета, а другая разрешает параметр, но не ограничивает его значения, набор или шаблон проверок будет игнорироваться.
5. Если набор проверок определен для одного параметра командлета в нескольких ролях, все значения из всех наборов проверок будут разрешены.
6. Если шаблон проверок определен для одного параметра командлета в нескольких ролях, будут разрешены все значения, соответствующие любому из шаблонов.
7. Если набор проверок определен в одной или нескольких ролях и шаблон проверок определен в другой роли для того же параметра командлета, набор проверок игнорируется, а к оставшимся шаблонам проверок применяется правило (6).

Ниже приведен пример объединения ролей согласно этим правилам:

```powershell
# Role A Visible Cmdlets
$roleA = @{
    VisibleCmdlets = 'Get-Service',
                     @{ Name = 'Restart-Service';
                        Parameters = @{ Name = 'DisplayName'; ValidateSet = 'DNS Client' } }
}

# Role B Visible Cmdlets
$roleB = @{
    VisibleCmdlets = @{ Name = 'Get-Service';
                        Parameters = @{ Name = 'DisplayName'; ValidatePattern = 'DNS.*' } },
                     @{ Name = 'Restart-Service';
                        Parameters = @{ Name = 'DisplayName'; ValidateSet = 'DNS Server' } }
}

# Resulting permissions for a user who belongs to both role A and B
# - The constraint in role B for the DisplayName parameter on Get-Service
#   is ignored because of rule #4
# - The ValidateSets for Restart-Service are merged because both roles use
#   ValidateSet on the same parameter per rule #5
$mergedAandB = @{
    VisibleCmdlets = 'Get-Service',
                     @{ Name = 'Restart-Service';
                        Parameters = @{ Name = 'DisplayName'; ValidateSet = 'DNS Client', 'DNS Server' } }
}
```

### <a name="visibleexternalcommands-visiblealiases-visibleproviders-scriptstoprocess"></a>VisibleExternalCommands, VisibleAliases, VisibleProviders, ScriptsToProcess

Все другие поля в файле роли возможностей ролей добавляются в совокупный набор допустимых внешних команд, псевдонимов, поставщиков и сценариев запуска. Команда, псевдоним, поставщик или сценарий, доступные в одной возможности роли, доступны пользователю JEA.

Внимательно следите за тем, чтобы комбинированный набор поставщиков из одной возможности роли и командлеты, функции и команды из другой не разрешали пользователям непреднамеренный доступ к системным ресурсам.
Например, если одна роль разрешает командлет `Remove-Item`, а другая разрешает поставщик `FileSystem`, существует риск того, что пользователь JEA удалит произвольные файлы на компьютере. Дополнительные сведения об определении действующих разрешений пользователей см. в [разделе об аудите JEA](audit-and-report.md).

## <a name="next-steps"></a>Дальнейшие действия

[Создание файла конфигурации сеанса](session-configurations.md)
