---
title: Типы параметров командлета | Документация Майкрософт
ms.custom: ''
ms.date: 09/13/2016
ms.reviewer: ''
ms.suite: ''
ms.tgt_pltfrm: ''
ms.topic: article
ms.assetid: 6602730d-3892-4656-80c7-7bca2d14337f
caps.latest.revision: 14
ms.openlocfilehash: f5781c0c03aca41d01a44598a9a8c00d6d21d2fd
ms.sourcegitcommit: 52a67bcd9d7bf3e8600ea4302d1fa8970ff9c998
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/15/2019
ms.locfileid: "72369313"
---
# <a name="types-of-cmdlet-parameters"></a>Типы параметров командлета

В этом разделе описываются различные типы параметров, которые можно объявить в командлетах. Параметры командлета могут быть параметрами позиционированного, именованного, обязательного, необязательного или switch.

## <a name="positional-and-named-parameters"></a>Позиционированные и именованные параметры

Все параметры командлета являются либо именованными, либо параметрами позиционирования. Именованный параметр требует ввода имени параметра и аргумента при вызове командлета. Для позиционированного параметра требуется только ввод аргументов в относительном порядке. Затем система сопоставляет первый безымянный аргумент с первым позиционированным параметром. Система сопоставляет второй безымянный аргумент с вторым неименованным параметром и т. д. По умолчанию все параметры командлета являются именованными параметрами.

Чтобы определить именованный параметр, опустите ключевое слово `Position` в объявлении атрибута **Parameter** , как показано в следующем объявлении параметра.

```csharp
[Parameter(ValueFromPipeline=true)]
public string UserName
{
  get { return userName; }
  set { userName = value; }
}
private string userName;
```

Чтобы определить параметр с указанием места, добавьте ключевое слово `Position` в объявление атрибута Parameter, а затем укажите расположение. В следующем примере параметр `UserName` объявляется как параметр с положением 0. Это означает, что первый аргумент вызова будет автоматически привязан к этому параметру.

```csharp
[Parameter(Position = 0)]
public string UserName
{
  get { return userName; }
  set { userName = value; }
}
private string userName;
```

> [!NOTE]
> Хороший проект командлета рекомендует объявлять наиболее используемые параметры как параметры позиционирования, чтобы пользователь не вводил имя параметра при запуске командлета.

Позиционированные и именованные параметры принимают одиночные аргументы или несколько аргументов, разделенных запятыми. Несколько аргументов разрешены, только если параметр принимает коллекцию, например массив строк. В одном командлете можно смешивать позиционированные и именованные параметры. В этом случае система сначала извлекает именованные аргументы, а затем пытается сопоставлять остальные неименованные аргументы с заданными параметрами.

Следующие команды демонстрируют различные способы, с помощью которых можно указать один и несколько аргументов для параметров командлета `Get-Command`. Обратите внимание, что в двух последних примерах не нужно указывать **-Name** , так как параметр `Name` определен как параметр с позиционированием.

```powershell
Get-Command -Name get-service
Get-Command -Name get-service,set-service
Get-Command get-service
Get-Command get-service,set-service
```

## <a name="mandatory-and-optional-parameters"></a>Обязательные и необязательные параметры

Можно также определить параметры командлета как обязательные или необязательные параметры. (Обязательный параметр необходимо указать до того, как среда выполнения Windows PowerShell вызовет командлет.)  По умолчанию параметры определяются как необязательные.

Чтобы определить обязательный параметр, добавьте ключевое слово `Mandatory` в объявление атрибута Parameter и присвойте ему значение `true`, как показано в следующем объявлении параметра.

```csharp
[Parameter(Position = 0, Mandatory = true)]
public string UserName
{
  get { return userName; }
  set { userName = value; }
}
private string userName;
```

Чтобы определить необязательный параметр, опустите ключевое слово `Mandatory` в объявлении атрибута **Parameter** , как показано в следующем объявлении параметра.

```csharp
[Parameter(Position = 0)]
public string UserName
{
  get { return userName; }
  set { userName = value; }
}
private string userName;
```

## <a name="switch-parameters"></a>Параметры переключателя

Windows PowerShell предоставляет тип [System. Management. Automation. переключатель](/dotnet/api/System.Management.Automation.SwitchParameter) , который позволяет определить параметр, значение которого автоматически устанавливается в `false`, если параметр не указан при вызове командлета. Везде, где это возможно, используйте параметры переключения вместо логических параметров.

Рассмотрим следующий пример. По умолчанию несколько командлетов Windows PowerShell не передают выходной объект в конвейер. Однако эти командлеты имеют параметр `PassThru`, который переопределяет поведение по умолчанию. Если при вызове этих командлетов указан параметр `PassThru`, командлет возвращает выходной объект в конвейер.

Если требуется, чтобы параметр имел значение по умолчанию `true`, если параметр не указан в вызове, рассмотрите возможность отменять смысл параметра. Например, вместо присвоения атрибуту Parameter логического значения `true`, объявите свойство как тип [System. Management. Automation. переключатель](/dotnet/api/System.Management.Automation.SwitchParameter) , а затем задайте для параметра значение по умолчанию `false`.

Чтобы определить параметр переключателя, объявите свойство как тип [System. Management. Automation. переключатель](/dotnet/api/System.Management.Automation.SwitchParameter) , как показано в следующем примере.

```csharp
[Parameter(Position = 1)]
public SwitchParameter GoodBye
{
  get { return goodbye; }
  set { goodbye = value; }
}
private bool goodbye;
```

Чтобы командлет действовал для параметра, если он указан, используйте следующую структуру в одном из методов обработки ввода.

```csharp
protected override void ProcessRecord()
{
  WriteObject("Switch parameter test: " + userName + ".");
  if(goodbye)
  {
    WriteObject(" Goodbye!");
  }
} // End ProcessRecord
```

## <a name="see-also"></a>См. также:

[Запись командлета Windows PowerShell](./writing-a-windows-powershell-cmdlet.md)
