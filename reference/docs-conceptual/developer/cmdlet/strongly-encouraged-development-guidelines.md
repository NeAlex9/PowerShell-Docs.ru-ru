---
title: Настоятельно рекомендуем рекомендации по разработке | Документация Майкрософт
ms.custom: ''
ms.date: 09/13/2016
ms.reviewer: ''
ms.suite: ''
ms.tgt_pltfrm: ''
ms.topic: article
ms.assetid: 4d68a8f3-fba0-44c5-97b9-9fc191d269a5
caps.latest.revision: 13
ms.openlocfilehash: 0906d0d37c66b8c1538a0b2e9e0f1ff2fba12ac0
ms.sourcegitcommit: debd2b38fb8070a7357bf1a4bf9cc736f3702f31
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/05/2019
ms.locfileid: "72369343"
---
# <a name="strongly-encouraged-development-guidelines"></a>Настоятельные рекомендации по разработке

В этом разделе описываются рекомендации, которые следует выполнить при написании командлетов. Они разделены на рекомендации по проектированию командлетов и руководств по написанию кода командлета. Может оказаться, что эти рекомендации не применимы для каждого сценария. Однако если они будут применены и вы не следуйте этим рекомендациям, пользователи могут столкнуться с плохими возможностями при использовании командлетов.

## <a name="design-guidelines"></a>Руководство по проектированию

- [Использование определенного существительного для имени командлета (SD01)](./strongly-encouraged-development-guidelines.md#use-a-specific-noun-for-a-cmdlet-name-sd01)

- [Использовать сценарий Pascal для имен командлетов (SD02)](./strongly-encouraged-development-guidelines.md#use-pascal-case-for-cmdlet-names-sd02)

- [Рекомендации по проектированию параметров (SD03)](./strongly-encouraged-development-guidelines.md#parameter-design-guidelines-sd03)

- [Отправить отзыв пользователю (SD04)](./strongly-encouraged-development-guidelines.md#provide-feedback-to-the-user-sd04)

- [Создание файла справки по командлету (SD05)](./strongly-encouraged-development-guidelines.md#create-a-cmdlet-help-file-sd05)

## <a name="code-guidelines"></a>Рекомендации по коду

- [Параметры кодирования (SC01)](./strongly-encouraged-development-guidelines.md#coding-parameters-sc01)

- [Поддержка хорошо определенных входных данных конвейера (SC02)](./strongly-encouraged-development-guidelines.md#support-well-defined-pipeline-input-sc02)

- [Запись отдельных записей в конвейер (SC03)](./strongly-encouraged-development-guidelines.md#write-single-records-to-the-pipeline-sc03)

- [Сделать командлеты без учета регистра и с сохранением регистра (SC04)](./strongly-encouraged-development-guidelines.md#make-cmdlets-case-insensitive-and-case-preserving-sc04)

## <a name="design-guidelines"></a>Руководство по проектированию

При проектировании командлетов необходимо следовать приведенным ниже рекомендациям, чтобы обеспечить согласованное взаимодействие с пользователем при использовании командлетов и других командлетов. Если вы нашли рекомендации по проектированию, применимые к вашей ситуации, ознакомьтесь с рекомендациями по написанию кода для аналогичных руководств.

### <a name="use-a-specific-noun-for-a-cmdlet-name-sd01"></a>Использование определенного существительного для имени командлета (SD01)

Существительные, используемые в именах командлетов, должны быть очень специфичными, чтобы пользователь мог обнаружить свои командлеты. Применяйте универсальные существительные, такие как "Server", с сокращенной версией названия продукта. Например, если имя существительное относится к серверу, на котором работает экземпляр Microsoft SQL Server, используйте существительное, например SQLServer. Сочетание отдельных существительных и краткий список утвержденных команд позволяет пользователю быстро обнаружить и оценить функциональность, избегая дублирования имен командлетов.

Для улучшения взаимодействия с пользователем существительное, выбранное для имени командлета, должно быть в единственном числе. Например, вместо **Get-Processes**следует использовать имя `Get-Process`. Лучше всего следовать этому правилу для всех имен командлетов, даже если командлет будет работать с более чем одним элементом.

### <a name="use-pascal-case-for-cmdlet-names-sd02"></a>Использовать сценарий Pascal для имен командлетов (SD02)

Для имен параметров следует использовать сценарий Pascal. Иными словами, первые буквы глагола и все термины, используемые в существительных, заменяются прописными буквами. Например: "`Clear-ItemProperty`".

### <a name="parameter-design-guidelines-sd03"></a>Рекомендации по проектированию параметров (SD03)

Командлету требуются параметры, которые получают данные, с которыми он должен действовать, а также параметры, которые указывают сведения, используемые для определения характеристик операции. Например, командлет может иметь параметр `Name`, который получает данные из конвейера, а командлет может иметь параметр `Force`, указывающий, что командлет может принудительно выполнить свою операцию. Количество параметров, которые может определить командлет, не ограничено.

#### <a name="use-standard-parameter-names"></a>Использовать стандартные имена параметров

Командлет должен использовать стандартные имена параметров, чтобы пользователь мог быстро определить, что означает конкретный параметр. Если требуется более конкретное имя, используйте стандартное имя параметра, а затем укажите более конкретное имя в качестве псевдонима. Например, у командлета `Get-Service` есть параметр с универсальным именем (`Name`) и более конкретный псевдоним (`ServiceName`). Для указания параметра можно использовать оба условия.

Дополнительные сведения об именах параметров и их типах данных см. в разделе [имя параметра командлета и рекомендации по функциональности](./standard-cmdlet-parameter-names-and-types.md).

#### <a name="use-singular-parameter-names"></a>Использовать имена параметров в единственном числе

Избегайте использования множественных имен для параметров, значение которых равно одному элементу. Сюда входят параметры, принимающие массивы или списки, поскольку пользователь может предоставить массив или список только с одним элементом.

Имена параметров во множественном числе следует использовать только в тех случаях, когда значение параметра всегда является значением с несколькими элементами. В этих случаях командлет должен проверить, что указано несколько элементов, и если не задано несколько элементов, командлет должен вывести предупреждение пользователю.

#### <a name="use-pascal-case-for-parameter-names"></a>Использовать сценарий Pascal для имен параметров

Для имен параметров следует использовать сценарий Pascal. Иными словами, необходимо сделать прописной первую букву каждого слова в имени параметра, включая первую букву имени. Например, имя параметра `ErrorAction` использует правильную прописную букву. Следующие имена параметров используют неправильные прописные буквы:

- `errorAction`

- `erroraction`

#### <a name="parameters-that-take-a-list-of-options"></a>Параметры, которые принимают список параметров

Существует два способа создания параметра, значение которого можно выбрать из набора параметров.

- Определите тип перечисления (или используйте существующий тип перечисления), который указывает допустимые значения. Затем используйте тип перечисления для создания параметра этого типа.

- Добавьте атрибут **Validate** в объявление параметра. Дополнительные сведения об этом атрибуте см. в разделе [объявление атрибута "Validate](./validateset-attribute-declaration.md)".

#### <a name="use-standard-types-for-parameters"></a>Использовать стандартные типы для параметров

Чтобы обеспечить согласованность с другими командлетами, используйте стандартные типы для параметров, если это возможно. Дополнительные сведения о типах, которые следует использовать для различных параметров, см. в разделе [имена и типы параметров стандартных командлетов](./standard-cmdlet-parameter-names-and-types.md). В этом разделе приводятся ссылки на несколько разделов, описывающих имена и типы .NET Framework для групп стандартных параметров, таких как "Параметры действия".

#### <a name="use-strongly-typed-net-framework-types"></a>Использовать строго типизированные типы .NET Framework

Параметры должны быть определены как типы .NET Framework, чтобы обеспечить лучшую проверку параметров. Например, параметры, которые ограничены одним значением из набора значений, должны быть определены как тип перечисления. Чтобы обеспечить поддержку значения универсального кода ресурса (URI), определите параметр как тип [System. URI](/dotnet/api/System.Uri) . Избегайте использования основных строковых параметров для всех свойств текста в свободной форме.

#### <a name="use-consistent-parameter-types"></a>Использовать совместимые типы параметров

Если один и тот же параметр используется несколькими командлетами, всегда используйте один и тот же тип параметра.  Например, если параметр `Process` является типом [System. Int16](/dotnet/api/System.Int16) для одного командлета, не делайте параметр `Process` для другого командлета типа [System. UInt16](/dotnet/api/System.UInt16) .

#### <a name="parameters-that-take-true-and-false"></a>Параметры, принимающие значения true и false

Если параметр принимает только `true` и `false`, определите параметр как тип [System. Management. Automation. переключатель](/dotnet/api/System.Management.Automation.SwitchParameter). Параметр Switch обрабатывается как `true`, если он указан в команде. Если параметр не включен в команду, Windows PowerShell считает значение параметра `false`. Не определяйте логические параметры.

Если параметру необходимо различать 3 значения: $true, $false и "не указано", определите параметр типа Nullable\<bool >.  Необходимость в 3-неопределенном значении обычно возникает, когда командлет может изменить логическое свойство объекта. В этом случае "не указано" означает, что не следует изменять текущее значение свойства.

#### <a name="support-arrays-for-parameters"></a>Поддержка массивов параметров

Часто пользователи должны выполнять одну и ту же операцию с несколькими аргументами. Для этих пользователей командлет должен принять массив в качестве входных параметров, чтобы пользователь мог передать аргументы в параметр как переменную Windows PowerShell. Например, командлет [Get-Process](/powershell/module/Microsoft.PowerShell.Management/Get-Process) использует массив для строк, которые указывают имена получаемых процессов.

#### <a name="support-the-passthru-parameter"></a>Поддержка параметра PassThru

По умолчанию многие командлеты, которые изменяют систему, такие как командлет « [останавливает-обработать](/powershell/module/Microsoft.PowerShell.Management/Stop-Process) », ведут себя как «приемники» для объектов и не возвращают результат. Этот командлет должен реализовать параметр `PassThru`, чтобы принудительно вернуть объект в командлет. Если указан параметр `PassThru`, командлет возвращает объект, используя вызов метода [System. Management. Automation. командлет. WriteObject](/dotnet/api/System.Management.Automation.Cmdlet.WriteObject) . Например, следующая команда останавливает процесс Calc и передает результирующий процесс в конвейер.

```powershell
Stop-Process calc -passthru
```

В большинстве случаев командлеты Add, Set и New должны поддерживать параметр `PassThru`.

#### <a name="support-parameter-sets"></a>Поддержка наборов параметров

Командлет предназначен для выполнения одной задачи. Однако часто существует несколько способов описания операции или целевого объекта операции. Например, процесс может быть идентифицирован по имени, идентификатору или объекту процесса. Командлет должен поддерживать все разумные представления целевых объектов. Как правило, командлет удовлетворяет этому требованию, указывая наборы параметров (называемые наборами параметров), которые работают вместе. Один параметр может принадлежать любому количеству наборов параметров. Дополнительные сведения о наборах параметров см. в разделе [наборы параметров командлета](./cmdlet-parameter-sets.md).

При указании наборов параметров установите только один параметр в наборе в значение Валуефромпипелине. Дополнительные сведения об объявлении атрибута **Parameter** см. в разделе [объявление параметераттрибуте](./parameter-attribute-declaration.md).

Если используются наборы параметров, набор параметров по умолчанию определяется атрибутом **командлета** . Набор параметров по умолчанию должен включать параметры, которые, скорее всего, будут использоваться в интерактивном сеансе Windows PowerShell. Дополнительные сведения об объявлении атрибута **командлета** см. в разделе [объявление CmdletAttribute](./cmdlet-attribute-declaration.md).

### <a name="provide-feedback-to-the-user-sd04"></a>Отправить отзыв пользователю (SD04)

Используйте рекомендации в этом разделе, чтобы отправить отзыв пользователю. Этот отзыв позволяет пользователю знать, что происходит в системе, и принимать более качественные административные решения.

Среда выполнения Windows PowerShell позволяет пользователю указать способ управления выходными данными каждого вызова метода `Write`, задав переменную предпочтения. Пользователь может задать несколько переменных предпочтений, включая переменную, которая определяет, должна ли система отображать информацию и переменную, которая определяет, должна ли система запрашивать пользователя перед дальнейшим действием.

#### <a name="support-the-writewarning-writeverbose-and-writedebug-methods"></a>Поддержка методов Вритеварнинг, Вритевербосе и Вритедебуг

Командлет должен вызвать метод [System. Management. Automation. командлет. вритеварнинг](/dotnet/api/System.Management.Automation.Cmdlet.WriteWarning) , когда командлет собирается выполнить операцию, которая может иметь непредвиденный результат. Например, командлет должен вызвать этот метод, если командлет собирается перезаписать файл, доступный только для чтения.

Командлет должен вызвать метод [System. Management. Automation. командлет. вритевербосе](/dotnet/api/System.Management.Automation.Cmdlet.WriteVerbose) , когда пользователю нужны некоторые сведения о выполняемом командлете. Например, командлет должен вызывать эту информацию, если автор командлета полагает, что существуют сценарии, для которых может потребоваться дополнительная информация о выполняемом командлете.

Командлет должен вызвать метод [System. Management. Automation. командлет. вритедебуг](/dotnet/api/System.Management.Automation.Cmdlet.WriteDebug) , когда разработчик или специалист по поддержке продукта должен понять, что именно вызвало повреждение операции командлета. Командлету не требуется вызывать метод [System. Management. Automation. командлет. вритедебуг](/dotnet/api/System.Management.Automation.Cmdlet.WriteDebug) в том же коде, который вызывает метод [System. Management. Automation. командлет. вритевербосе](/dotnet/api/System.Management.Automation.Cmdlet.WriteVerbose) , поскольку параметр `Debug` представляет оба набора данных.

#### <a name="support-writeprogress-for-operations-that-take-a-long-time"></a>Поддержка Вритепрогресс для операций, которые выполняются длительное время

Операции командлета, выполнение которых занимает много времени и которые не могут выполняться в фоновом режиме, должны поддерживать отчеты о ходе выполнения через периодические вызовы метода [System. Management. Automation. командлет. вритепрогресс](/dotnet/api/System.Management.Automation.Cmdlet.WriteProgress) .

#### <a name="use-the-host-interfaces"></a>Использование интерфейсов узла

Иногда командлет должен напрямую взаимодействовать с пользователем, а не с помощью различных методов Write или, поддерживаемых классом [System. Management. Automation. командлет](/dotnet/api/System.Management.Automation.Cmdlet) . В этом случае командлет должен быть производным от класса [System. Management. Automation. PSCmdlet](/dotnet/api/System.Management.Automation.PSCmdlet) и использовать свойство [System. Management. Automation. PSCmdlet. Host *](/dotnet/api/System.Management.Automation.PSCmdlet.Host) . Это свойство поддерживает разные уровни типа связи, включая типы Промптфорчоице, Prompt и ReadLine. На самом конкретном уровне он также предоставляет способы чтения и записи отдельных ключей и работы с буферами.

Если командлет специально не предназначен для создания графического пользовательского интерфейса, он не должен обходить узел с помощью свойства [System. Management. Automation. PSCmdlet. Host *](/dotnet/api/System.Management.Automation.PSCmdlet.Host) . Примером командлета, предназначенного для создания графического пользовательского интерфейса, является командлет [Out-GridView](/powershell/module/Microsoft.PowerShell.Utility/Out-GridView) .

> [!NOTE]
> Командлеты не должны использовать API [System. Console](/dotnet/api/System.Console) .

### <a name="create-a-cmdlet-help-file-sd05"></a>Создание файла справки по командлету (SD05)

Для каждой сборки командлета создайте файл Help. XML, содержащий сведения о командлете. Эти сведения включают описание командлета, описания параметров командлета, примеры использования командлета и многое другое.

## <a name="code-guidelines"></a>Рекомендации по коду

При написании командлетов необходимо следовать приведенным ниже рекомендациям, чтобы обеспечить согласованное взаимодействие с пользователем при использовании командлетов и других командлетов. Когда вы найдете рекомендации по коду, применимые к вашей ситуации, ознакомьтесь с рекомендациями по проектированию для аналогичных руководств.

### <a name="coding-parameters-sc01"></a>Параметры кодирования (SC01)

Определите параметр, объявив открытое свойство класса командлета, дополненного атрибутом **Parameter** . Параметры не обязательно должны быть статическими членами производного класса .NET Framework для командлета. Дополнительные сведения об объявлении атрибута **Parameter** см. в разделе [объявление атрибута параметра](./parameter-attribute-declaration.md).

#### <a name="support-windows-powershell-paths"></a>Поддержка путей Windows PowerShell

Путь Windows PowerShell — это механизм нормализации доступа к пространствам имен. При назначении пути Windows PowerShell параметру в командлете пользователь может определить пользовательский "диск", который будет выступать в качестве ярлыка для определенного пути. Когда пользователь указывает такой диск, хранимые данные, такие как данные в реестре, можно использовать согласованным образом.

Если командлет позволяет пользователю указать файл или источник данных, он должен определить параметр типа [System. String](/dotnet/api/System.String). Если поддерживается более одного диска, тип должен быть массивом. Имя параметра должно быть `Path`с псевдонимом `PSPath`. Кроме того, параметр `Path` должен поддерживать символы-шаблоны. Если поддержка символов-шаблонов не требуется, определите параметр `LiteralPath`.

Если данные, которые командлет считывает или записывают, должны быть файлом, командлет должен принять входные данные пути Windows PowerShell, а командлет должен использовать свойство [System. Management. Automation. sessionState. Path](/dotnet/api/System.Management.Automation.SessionState.Path) для преобразования путей Windows PowerShell в пути, распознаваемые файловой системой. К конкретным механизмам относятся следующие методы.

- [System. Management. Automation. PSCmdlet. Жетресолведпровидерпасфромпспас](/dotnet/api/System.Management.Automation.PSCmdlet.GetResolvedProviderPathFromPSPath)

- [System. Management. Automation. PSCmdlet. Жетунресолведпровидерпасфромпспас](/dotnet/api/System.Management.Automation.PSCmdlet.GetUnresolvedProviderPathFromPSPath)

- [System. Management. Automation. Пасинтринсикс. Жетресолведпровидерпасфромпспас](/dotnet/api/System.Management.Automation.PathIntrinsics.GetResolvedProviderPathFromPSPath)

- [System. Management. Automation. Пасинтринсикс. Жетунресолведпровидерпасфромпспас](/dotnet/api/System.Management.Automation.PathIntrinsics.GetUnresolvedProviderPathFromPSPath)

Если данные, считываемые или записываемые командлетом, являются только набором строк, а не файлом, командлет должен использовать сведения о содержимом поставщика (`Content` члене) для чтения и записи. Эти сведения получаются из свойства [System. Management. Automation. Provider. кмдлетпровидер. инвокепровидер](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.InvokeProvider) . Эти механизмы позволяют другим хранилищам данных принимать участие в чтении и записи данных.

#### <a name="support-wildcard-characters"></a>Поддержка подстановочных знаков

По возможности командлет должен поддерживать подстановочные знаки. Поддержка подстановочных знаков выполняется во многих местах командлета (особенно когда параметр принимает строку для указания одного объекта из набора объектов). Например, командлет «Sample **-proc** » из [учебника стоппрок](./stopproc-tutorial.md) определяет параметр `Name` для обработки строк, представляющих имена процессов. Этот параметр поддерживает подстановочные знаки, чтобы пользователь мог легко указать процессы для их завершения.

Если доступна поддержка подстановочных знаков, операция командлета обычно создает массив. Иногда не имеет смысла поддерживать массив, поскольку пользователь может использовать только один элемент за раз. Например, командлету [Set-Location](/powershell/module/Microsoft.PowerShell.Management/Set-Location) не требуется поддерживать массив, поскольку пользователь устанавливает только одно расположение. В этом случае командлет по-прежнему поддерживает подстановочные знаки, но обеспечивает разрешение в одном месте.

Дополнительные сведения о шаблонах символов-шаблонов см. [в разделе Поддержка подстановочных знаков в параметрах командлета](./supporting-wildcard-characters-in-cmdlet-parameters.md).

#### <a name="defining-objects"></a>Определение объектов

В этом разделе содержатся рекомендации по определению объектов для командлетов и расширению существующих объектов.

##### <a name="define-standard-members"></a>Определение стандартных членов

Определите стандартные члены для расширения типа объекта в файле пользовательских типов. ps1xml (используйте файл Windows PowerShell Types. ps1xml в качестве шаблона). Стандартные члены определяются узлом с именем Псстандардмемберс. Эти определения позволяют другим командлетам и среде выполнения Windows PowerShell работать с объектом согласованным образом.

##### <a name="define-objectmembers-to-be-used-as-parameters"></a>Определить Обжектмемберс для использования в качестве параметров

При проектировании объекта для командлета убедитесь, что его члены сопоставляются непосредственно с параметрами командлетов, которые будут его использовать. Это сопоставление позволяет легко отправлять объект в конвейер и передавать его из одного командлета в другой.

Существующие .NET Framework объекты, возвращаемые командлетами, часто не имеют некоторых важных или удобных элементов, необходимых разработчику или пользователю скрипта. Эти отсутствующие элементы могут быть особенно важны для вывода и для создания правильных имен членов, чтобы объект мог быть правильно передан в конвейер. Создайте файл Custom Types. ps1xml, чтобы документировать эти необходимые элементы. При создании этого файла рекомендуется использовать следующее соглашение об именовании: *< Your_Product_Name >* . Types. ps1xml.

Например, можно добавить свойство скрипта `Mode` в тип [System. IO. FileInfo](/dotnet/api/System.IO.FileInfo) для более четкого представления атрибутов файла. Кроме того, можно добавить свойство псевдонима `Count` в тип [System. Array](/dotnet/api/System.Array) , чтобы обеспечить единообразное использование имени этого свойства (вместо `Length`).

##### <a name="implement-the-icomparable-interface"></a>Реализация интерфейса IComparable

Реализуйте интерфейс [System. IComparable](/dotnet/api/System.IComparable) для всех выходных объектов. Это позволяет легко передавать выходные объекты в различные командлеты сортировки и анализа.

##### <a name="update-display-information"></a>Обновить отображаемые сведения

Если отображение объекта не предоставляет ожидаемых результатов, создайте пользовательский *\<йоурпродуктнаме >* . Файл Format. ps1xml для этого объекта.

### <a name="support-well-defined-pipeline-input-sc02"></a>Поддержка хорошо определенных входных данных конвейера (SC02)

#### <a name="implement-for-the-middle-of-a-pipeline"></a>Реализация для середины конвейера

Реализуйте командлет, предполагая, что он будет вызываться из середины конвейера (то есть другие командлеты создадут свои входные данные или занимают его выходные данные). Например, можно предположить, что командлет `Get-Process`, поскольку он создает данные, используется только в качестве первого командлета в конвейере. Однако поскольку этот командлет предназначен для середины конвейера, этот командлет позволяет предыдущим командлетам или данным в конвейере указать процессы для извлечения.

#### <a name="support-input-from-the-pipeline"></a>Поддержка входных данных из конвейера

В каждом наборе параметров для командлета включите по крайней мере один параметр, который поддерживает входные данные из конвейера. Поддержка входных данных конвейера позволяет пользователю получить данные или объекты, отправить их в правильный набор параметров и передать результаты непосредственно в командлет.

Параметр принимает входные данные из конвейера, если атрибут **Parameter** включает ключевое слово `ValueFromPipeline`, атрибут `ValueFromPipelineByPropertyName` ключевого слова или оба ключевых слова в его объявлении. Если ни один из параметров в наборе параметров не поддерживает ключевые слова `ValueFromPipeline` или `ValueFromPipelineByPropertyName`, командлет не может иметь смысл поместиться после другого командлета, так как он игнорирует любые входные данные конвейера.

#### <a name="support-the-processrecord-method"></a>Поддержка метода ProcessRecord

Чтобы принять все записи из предыдущего командлета в конвейере, командлет должен реализовать метод [System. Management. Automation. командлет. ProcessRecord](/dotnet/api/System.Management.Automation.Cmdlet.ProcessRecord) . Windows PowerShell вызывает этот метод несколько раз, по одному разу для каждой записи, которая отправляется в командлет.

### <a name="write-single-records-to-the-pipeline-sc03"></a>Запись отдельных записей в конвейер (SC03)

Когда командлет возвращает объекты, командлет должен записывать объекты непосредственно по мере их создания. Командлет не должен удерживать их для того, чтобы буферизовать их в Объединенном массиве. Командлеты, получающие эти объекты в качестве входных данных, смогут обрабатывать, отображать или обрабатывать и отображать выходные объекты без задержки. Командлет, создающий выходные объекты по одному за раз, должен вызвать метод [System. Management. Automation. командлет. WriteObject](/dotnet/api/System.Management.Automation.Cmdlet.WriteObject) . Командлет, создающий выходные объекты в пакетах (например, так как базовый API возвращает массив выходных объектов), должен вызывать метод [System. Management. Automation. командлет. WriteObject](/dotnet/api/System.Management.Automation.Cmdlet.WriteObject) со вторым параметром, имеющим значение `true`.

### <a name="make-cmdlets-case-insensitive-and-case-preserving-sc04"></a>Сделать командлеты без учета регистра и с сохранением регистра (SC04)

По умолчанию Windows PowerShell не учитывает регистр. Тем не менее, поскольку он работает с множеством уже существующих систем, Windows PowerShell сохраняет регистр для простоты работы и совместимости. Иными словами, если символ указан в прописных буквах, Windows PowerShell сохранит его в прописных буквах. Чтобы системы работали правильно, командлет должен следовать этому соглашению. Если это возможно, оно должно выполняться без учета регистра. Однако он должен сохранить исходный регистр для командлетов, которые происходят позже в команде или в конвейере.

## <a name="see-also"></a>См. также:

[Необходимые рекомендации по разработке](./required-development-guidelines.md)

[Рекомендации по разработке рекомендаций](./advisory-development-guidelines.md)

[Запись командлета Windows PowerShell](./writing-a-windows-powershell-cmdlet.md)
