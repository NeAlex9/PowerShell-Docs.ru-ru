---
title: Написание манифеста модуля PowerShell | Документация Майкрософт
ms.custom: ''
ms.date: 09/13/2016
ms.reviewer: ''
ms.suite: ''
ms.tgt_pltfrm: ''
ms.topic: article
ms.assetid: e082c2e3-12ce-4032-9caf-bf6b2e0dcf81
caps.latest.revision: 23
ms.openlocfilehash: 1265855b82b0bfaa7b2717c8eb348b822c19f561
ms.sourcegitcommit: 52a67bcd9d7bf3e8600ea4302d1fa8970ff9c998
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/15/2019
ms.locfileid: "72367103"
---
# <a name="how-to-write-a-powershell-module-manifest"></a>Как написать манифест модуля PowerShell

После написания модуля Windows PowerShell можно дополнительно добавить манифест модуля. Манифест модуля — это файл сценария PowerShell, который можно использовать для включения сведений о модуле. Например, можно описать автора, указать файлы в модуле (например, вложенные модули), выполнить сценарии для настройки среды пользователя, загрузки типов и файлов форматирования, определить требования к системе и ограничить элементы, экспортируемые модулем.

## <a name="creating-a-module-manifest"></a>Создание манифеста модуля

*Манифест модуля* — это файл данных Windows PowerShell (PSD1), описывающий содержимое модуля и определяющий способ обработки модуля. Сам файл манифеста — это текстовый файл, содержащий хэш-таблицу ключей и значений. Файл манифеста связывается с модулем путем его именования в качестве модуля и размещения в корне каталога модуля.

Для простых модулей, содержащих только одну PSM1 или двоичную сборку, манифест модуля является необязательным. Однако рекомендуется использовать манифест модуля везде, где это возможно, так как они помогают организовать код и поддерживать сведения об управлении версиями. Кроме того, для экспорта сборки, установленной в глобальном кэше сборок, требуется манифест модуля. Для модулей, поддерживающих функцию обновляемой справки, также требуется манифест модуля. Это значит, что обновляемая Справка использует ключ **HelpInfoUri** в манифесте модуля, чтобы найти файл справочной информации (HelpInfo XML), содержащий расположение обновленных файлов справки для модуля. Дополнительные сведения об обновляемой справке см. в разделе [Поддержка обновляемой справки](./supporting-updatable-help.md).

### <a name="to-create-and-use-a-module-manifest"></a>Создание и использование манифеста модуля

1. Создать манифест модуля можно несколькими способами.

   1. Непосредственно создайте хэш-таблицу с минимальными необходимыми сведениями и сохраните ее в файл. PSD1, имя которого совпадает с именем модуля. После этого можно открыть файл и добавить соответствующие значения вручную.

      `'@{ModuleVersion="1.0"}' > myModuleName.psd1`

   2. Или вызовите командлет [New-ModuleManifest](/powershell/module/Microsoft.PowerShell.Core/New-ModuleManifest) с одним или несколькими значениями по умолчанию, передаваемыми в качестве параметров. (Обратите внимание, что для создания манифеста требуется только имя файла.) При этом будет создан манифест модуля со всеми указанными явно значениями манифеста, а также с остальной, содержащей соответствующее значение по умолчанию.

      `New-ModuleManifest myModuleName.psd1 -ModuleVersion "2.0" -Author "YourNameHere"`

   3. Наконец, можно также создать пустой файл PSD1 и скопировать шаблон в конце этого раздела в файл и заполнить соответствующие значения. Единственным реальным требованием в этом случае является обеспечение того, что имя файла совпадает с именем модуля.

2. Добавьте дополнительные элементы в манифест, который требуется поместить в файл.

   Как правило, это может быть сделано в любом текстовом редакторе, например в блокноте. Однако это технически файл скрипта, который содержит код, поэтому может потребоваться изменить его в реальной среде разработки или написания сценариев, например Visual Studio Code. Опять же, обратите внимание, что все элементы файла манифеста являются необязательными, за исключением номера версии.

   Описание ключей и значений, которые можно иметь в манифесте модуля, см. в разделе **элементы манифеста модуля** ниже. Дополнительные сведения см. в описании параметров в командлете [New-ModuleManifest](/powershell/module/Microsoft.PowerShell.Core/New-ModuleManifest) .

3. При необходимости можно добавить дополнительный код в манифест модуля, чтобы обращаться к любым сценариям, которые не будут охватываться элементами манифеста базового модуля.

   Из-за проблем с безопасностью PowerShell запустит только небольшое подмножество доступных операций в файле манифеста модуля. Как правило, можно использовать оператор **If** , арифметические и операторы сравнения, а также базовые типы данных PowerShell.

4. После создания манифеста модуля его можно протестировать (чтобы убедиться, что все пути, описанные в манифесте, верны) с вызовом [Test-ModuleManifest](/powershell/module/Microsoft.PowerShell.Core/Test-ModuleManifest).

   `Test-ModuleManifest myModuleName.psd1`

5. Убедитесь, что манифест модуля расположен на верхнем уровне каталога, который содержит ваш модуль.

   При копировании модуля в систему и его импорте PowerShell будет использовать манифест модуля для импорта модуля.

6. При необходимости можно напрямую протестировать манифест модуля с помощью вызова метода [Import-Module](/powershell/module/Microsoft.PowerShell.Core/Import-Module) , используя точку с этим манифестом.

   `Import-Module .\myModuleName.psd1`

## <a name="module-manifest-elements"></a>Элементы манифеста модуля

В следующей таблице описаны элементы, которые можно иметь в манифесте модуля.

|Элемент|Значение по умолчанию|Описание|
|-------------|-------------|-----------------|
|RootModule<br /><br /> Тип: строка|' '|Модуль скрипта или файл двоичного модуля, связанный с этим манифестом. Предыдущие версии PowerShell вызвали этот элемент Модулетопроцесс.<br /><br /> Возможные типы для корневого модуля могут быть пустыми (что сделает этот модуль **манифеста** ), именем модуля скрипта (. psm1, который делает этот модуль **скрипта** ) или именем двоичного модуля (exe или DLL, который делает этот **двоичный** модуль). Размещение имени манифеста модуля (. PSD1) или файла скрипта (. ps1) в этом элементе приведет к ошибке.|
|ModuleVersion<br /><br /> Тип: строка|1.0|Номер версии этого модуля. Строка должна иметь возможность преобразования в [System. Version]. То есть "#. #. #. #. #". `Import-Module` загружает первый найденный модуль на **$psModulePath** , который соответствует имени, и имеет по крайней мере высокое значение в качестве параметра `-MinimumVersion`. Чтобы импортировать определенную версию, используйте вместо нее параметр @ no__t-0.<br /><br /> Пример: `ModuleVersion = '1.0'`|
|Код GUID<br /><br /> Тип: строка|Автоматически сформированный GUID|Идентификатор, используемый для уникальной идентификации этого модуля. Обратите внимание, что в настоящее время импорт модуля по идентификатору GUID невозможен.<br /><br /> Пример: `GUID = 'cfc45206-1e49-459d-a8ad-5b571ef94857'`|
|Дизайнер<br /><br /> Тип: строка|Нет|Автор этого модуля.<br /><br /> Пример: `Author = 'AuthorNameHere'`|
|CompanyName<br /><br /> Тип: строка|Неизвестно|Компания или поставщик этого модуля.<br /><br /> Пример: `CompanyName = 'Fabrikam'`|
|Авторские права<br /><br /> Тип: строка|(c) [Куррентеар] [author]. Все права защищены.|Заявление об авторских правах для этого модуля.<br /><br /> Пример: `Copyright = '2016 AuthorName. All rights reserved.'`|
|Описание<br /><br /> Тип: строка|' '|Описание функциональных возможностей, предоставляемых этим модулем.<br /><br /> Пример: `Description = 'This is a description of a module.'`|
|PowerShellVersion<br /><br /> Тип: строка|' '|Минимальная версия подсистемы Windows PowerShell, необходимая для этого модуля. Текущие допустимые значения: 1,0, 2,0, 3,0, 4,0 и 5,0.<br /><br /> Пример: `PowerShellVersion = '5.0'`|
|повершеллхостнаме<br /><br /> Тип: строка|' '|Указывает имя узла Windows PowerShell, необходимого для модуля. Это имя предоставляется Windows PowerShell. Чтобы найти имя основной программы, введите в программе: `$host.name`.<br /><br /> Пример: `PowerShellHostName = 'Windows PowerShell ISE Host'`|
|повершеллхостверсион<br /><br /> Тип: строка|' '|Минимальная версия узла Windows PowerShell, необходимая для этого модуля.<br /><br /> Пример: `PowerShellHostVersion = '2.0'`|
|дотнетфрамеворкверсион<br /><br /> Тип: строка|' '|Минимальная версия платформы Microsoft .NET, необходимая для этого модуля.<br /><br /> Пример: `DotNetFrameworkVersion = '3.5'`|
|CLRVersion<br /><br /> Тип: строка|' '|Минимальная версия среды CLR, необходимая для этого модуля.<br /><br /> Пример: `CLRVersion = '3.5'`|
|ProcessorArchitecture<br /><br /> Тип: строка|' '|Архитектура процессора (отсутствует, x86, AMD64), необходимая для этого модуля. Допустимые значения: x86, AMD64, IA64 и None (неизвестен или не задан).<br /><br /> Пример: `ProcessorArchitecture = 'x86'`|
|RequiredModules<br /><br /> Тип: [строка []]|@()|Модули, которые необходимо импортировать в глобальную среду перед импортом этого модуля. При этом будут загружены все перечисленные модули, если они еще не загружены. (Например, некоторые модули уже могут быть загружены с помощью другого модуля.) Можно также указать конкретную версию для загрузки с помощью `RequiredVersion`, а не `ModuleVersion`. При использовании `ModuleVersion` будет загружена последняя версия, доступная по меньшей мере с указанной версией.<br /><br /> Пример: `RequiredModules = @(@{ModuleName="myDependentModule"; ModuleVersion="2.0"; Guid="cfc45206-1e49-459d-a8ad-5b571ef94857"})`<br /><br /> Пример: `RequiredModules = @(@{ModuleName="myDependentModule"; RequiredVersion="1.5"; Guid="cfc45206-1e49-459d-a8ad-5b571ef94857"})`|
|рекуиредассемблиес<br /><br /> Тип: [строка []]|@()|Сборки, которые должны быть загружены перед импортом этого модуля.<br /><br /> Обратите внимание, что, в отличие от RequiredModules, PowerShell загрузит Рекуиредассемблиес, если они еще не загружены.|
|скриптстопроцесс<br /><br /> Тип: [строка []]|@()|Файлы скриптов (PS1), которые выполняются в состоянии сеанса вызывающего объекта при импорте модуля. Это может быть глобальное состояние сеанса или, для вложенных модулей, состояние сеанса другого модуля. Эти скрипты можно использовать для подготовки среды так же, как и сценария входа в систему.<br /><br /> Эти скрипты выполняются до загрузки всех модулей, перечисленных в манифесте.|
|типестопроцесс<br /><br /> Тип: [строка []]|@()|Файлы типов (. ps1xml), которые будут загружены при импорте этого модуля.|
|форматстопроцесс<br /><br /> Тип: [строка []]|@()|Файлы форматирования (. ps1xml), которые будут загружены при импорте этого модуля.|
|NestedModules<br /><br /> Тип: [строка []]|@()|Модули для импорта как вложенные модули модуля, указанного в RootModule/Модулетопроцесс.<br /><br /> Добавление имени модуля в этот элемент аналогично вызову `Import-Module` в коде скрипта или сборки. Основное отличие состоит в том, что проще увидеть, что именно вы загружаете в файле манифеста. Кроме того, если не удается загрузить модуль здесь, вы еще не загрузили фактический модуль.<br /><br /> Помимо других модулей, здесь также можно загрузить файлы скриптов (PS1). Эти файлы будут выполняться в контексте корневого модуля. (Это эквивалентно тому, что в корневом модуле можно получить доступ к сценарию с точкой.)|
|FunctionsToExport<br /><br /> Тип: [строка []]|@()|Указывает функции, которые экспортирует модуль (символы-шаблоны разрешены, но не рекомендуются) в состояние сеанса вызывающего объекта. По умолчанию никакие функции не экспортируются. Этот ключ можно использовать для перечисления функций, экспортируемых модулем.<br /><br /> Состояние сеанса вызывающего объекта может быть глобальным состоянием сеанса или, для вложенных модулей, состояние сеанса другого модуля. При создании цепочки вложенных модулей все функции, экспортированные вложенным модулем, будут экспортированы в глобальное состояние сеанса, если только модуль в цепочке не будет ограничивать функцию с помощью ключа FunctionsToExport.<br /><br /> Если манифест также экспортирует псевдонимы для функций, этот ключ может удалить функции, псевдонимы которых перечислены в ключе Алиасестоекспорт, но этот ключ не может добавлять в список псевдонимы функций.|
|CmdletsToExport<br /><br /> Тип: [строка []]|@()|Задает командлеты, экспортируемые модулем (символы-шаблоны разрешены, но не рекомендуются). По умолчанию командлеты не экспортируются. Этот ключ можно использовать для перечисления командлетов, экспортируемых модулем.<br /><br /> Состояние сеанса вызывающего объекта может быть глобальным состоянием сеанса или, для вложенных модулей, состояние сеанса другого модуля. При цепочке вложенных модулей все командлеты, экспортированные вложенным модулем, будут в конечном итоге экспортироваться в глобальное состояние сеанса, если только модуль в цепочке не будет ограничивать командлет с помощью ключа CmdletsToExport.<br /><br /> Если манифест также экспортирует псевдонимы для командлетов, этот ключ может удалить командлеты, псевдонимы которых перечислены в ключе Алиасестоекспорт, но этот ключ не может добавлять в список псевдонимы командлетов.|
|вариаблестоекспорт<br /><br /> Тип: строка|'*'|Указывает переменные, которые экспортирует модуль (символы-шаблоны разрешены) в состояние сеанса вызывающего объекта. По умолчанию экспортируются все переменные. Этот ключ можно использовать для ограничения переменных, экспортируемых модулем.<br /><br /> Состояние сеанса вызывающего объекта может быть глобальным состоянием сеанса или, для вложенных модулей, состояние сеанса другого модуля. При цепочке вложенных модулей все переменные, экспортированные вложенным модулем, будут экспортированы в глобальное состояние сеанса, если только модуль в цепочке не будет ограничивать переменную с помощью ключа Вариаблестоекспорт.<br /><br /> Если манифест также экспортирует псевдонимы для переменных, этот ключ может удалить переменные, псевдонимы которых перечислены в ключе Алиасестоекспорт, но этот ключ не может добавлять в список псевдонимы переменных.|
|алиасестоекспорт<br /><br /> Тип: [строка []]|@()|Задает псевдонимы, экспортируемые модулем (символы-шаблоны разрешены, но не рекомендуются) в состояние сеанса вызывающего объекта. По умолчанию никакие псевдонимы не экспортируются. Этот ключ можно использовать для перечисления псевдонимов, экспортируемых модулем.<br /><br /> Состояние сеанса вызывающего объекта может быть глобальным состоянием сеанса или, для вложенных модулей, состояние сеанса другого модуля. При создании цепочки вложенных модулей все псевдонимы, экспортированные вложенным модулем, будут в конечном итоге экспортироваться в глобальное состояние сеанса, если только модуль в цепочке не будет ограничивать псевдоним с помощью ключа Алиасестоекспорт.|
|модулелист<br /><br /> Тип: [строка []]|@()|Указывает все модули, Упакованные в этот модуль. Эти модули можно вводить по имени (строки с разделителями-запятыми) или в виде хэш-таблицы с ключами ModuleName и GUID. Хэш-таблица может также иметь необязательный ключ «ключом». Ключ Модулелист предназначен для выполнения функций инвентаризации модуля. Эти модули не обрабатываются автоматически.|
|FileList<br /><br /> Тип: [строка []]|@()|Список всех файлов, упакованных с помощью этого модуля. Как и в случае с Модулелист, FileList должен помочь вам в качестве списка инвентаризации и не обрабатывался иным образом.|
|PrivateData<br /><br /> Тип: [объект]|@{...}|Указывает все закрытые данные, которые необходимо передать в корневой модуль, заданный ключом RootModule/Модулетопроцесс.|
|HelpInfoURI<br /><br /> Тип: строка|' '|Универсальный код ресурса (URI) HelpInfo этого модуля.|
|DefaultCommandPrefix<br /><br /> Тип: строка|' '|Префикс по умолчанию для команд, экспортированных из этого модуля. Переопределите префикс по умолчанию, используя `Import-Module`-prefix.|

## <a name="sample-module-manifest"></a>Пример манифеста модуля

В следующем примере манифеста модуля показаны ключи и значения по умолчанию в манифесте модуля. Этот пример был создан с помощью командлета `New-ModuleManifest` в Windows PowerShell 3,0. При создании нескольких модулей с помощью этого командлета можно создать шаблон манифеста, который затем можно изменить для разных модулей.

```powershell
#
# Module manifest for module 'myManifest'
#
# Generated by: User01
#
# Generated on: 2019-10-09
#

@{

# Script module or binary module file associated with this manifest.
# RootModule = ''

# Version number of this module.
ModuleVersion = '1.0'

# Supported PSEditions
# CompatiblePSEditions = @()

# ID used to uniquely identify this module
GUID = 'b888e5a2-8578-4c0b-938d-0cd9b5b836ba'

# Author of this module
Author = 'User01'

# Company or vendor of this module
CompanyName = 'Unknown'

# Copyright statement for this module
Copyright = '(c) 2019 User01. All rights reserved.'

# Description of the functionality provided by this module
# Description = ''

# Minimum version of the Windows PowerShell engine required by this module
# PowerShellVersion = ''

# Name of the Windows PowerShell host required by this module
# PowerShellHostName = ''

# Minimum version of the Windows PowerShell host required by this module
# PowerShellHostVersion = ''

# Minimum version of Microsoft .NET Framework required by this module. This prerequisite is valid for the PowerShell Desktop edition only.
# DotNetFrameworkVersion = ''

# Minimum version of the common language runtime (CLR) required by this module. This prerequisite is valid for the PowerShell Desktop edition only.
# CLRVersion = ''

# Processor architecture (None, X86, Amd64) required by this module
# ProcessorArchitecture = ''

# Modules that must be imported into the global environment prior to importing this module
# RequiredModules = @()

# Assemblies that must be loaded prior to importing this module
# RequiredAssemblies = @()

# Script files (.ps1) that are run in the caller's environment prior to importing this module.
# ScriptsToProcess = @()

# Type files (.ps1xml) to be loaded when importing this module
# TypesToProcess = @()

# Format files (.ps1xml) to be loaded when importing this module
# FormatsToProcess = @()

# Modules to import as nested modules of the module specified in RootModule/ModuleToProcess
# NestedModules = @()

# Functions to export from this module, for best performance, do not use wildcards and do not delete the entry, use an empty array if there are no functions to export.
FunctionsToExport = @()

# Cmdlets to export from this module, for best performance, do not use wildcards and do not delete the entry, use an empty array if there are no cmdlets to export.
CmdletsToExport = @()

# Variables to export from this module
VariablesToExport = '*'

# Aliases to export from this module, for best performance, do not use wildcards and do not delete the entry, use an empty array if there are no aliases to export.
AliasesToExport = @()

# DSC resources to export from this module
# DscResourcesToExport = @()

# List of all modules packaged with this module
# ModuleList = @()

# List of all files packaged with this module
# FileList = @()

# Private data to pass to the module specified in RootModule/ModuleToProcess. This may also contain a PSData hashtable with additional module metadata used by PowerShell.
PrivateData = @{

    PSData = @{

        # Tags applied to this module. These help with module discovery in online galleries.
        # Tags = @()

        # A URL to the license for this module.
        # LicenseUri = ''

        # A URL to the main website for this project.
        # ProjectUri = ''

        # A URL to an icon representing this module.
        # IconUri = ''

        # ReleaseNotes of this module
        # ReleaseNotes = ''

    } # End of PSData hashtable

} # End of PrivateData hashtable

# HelpInfo URI of this module
# HelpInfoURI = ''

# Default prefix for commands exported from this module. Override the default prefix using Import-Module -Prefix.
# DefaultCommandPrefix = ''

}

```

## <a name="see-also"></a>См. также:

[Написание модуля Windows PowerShell](./writing-a-windows-powershell-module.md)
