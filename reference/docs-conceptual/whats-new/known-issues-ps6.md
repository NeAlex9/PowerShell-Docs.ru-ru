---
ms.date: 02/03/2020
keywords: powershell,core
title: Известные проблемы в PowerShell 6.0
ms.openlocfilehash: e9550e3db53865cfc2713d1d80665cced6f0d47a
ms.sourcegitcommit: bc9a4904c2b1561386d748fc9ac242699d2f1694
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/04/2020
ms.locfileid: "76996108"
---
# <a name="known-issues-for-powershell-60"></a>Известные проблемы в PowerShell 6.0

## <a name="known-issues-for-powershell-on-non-windows-platforms"></a>Известные проблемы в PowerShell на платформах, отличных от Windows

Альфа-выпуски PowerShell в Linux и macOS по большей части функциональны, но имеют некоторые существенные ограничения и проблемы использования. Бета-версии выпусков PowerShell в Linux и macOS более функциональны и стабильнее, чем альфа-версии, но в них все же может отсутствовать некоторый набор функций и могут содержаться ошибки. В некоторых случаях эти проблемы — это просто ошибки, которые еще не исправлены. В других случаях (как и с псевдонимами по умолчанию для ls, cp и т. д.) мы ожидаем обратной связи от сообщества относительно выбора, который следует сделать.

Примечание. Из-за схожести многих базовых подсистем модуль PowerShell в Linux и macOS обычно имеет одинаковый уровень функций и ошибок. За исключением указанного ниже, проблемы, описанные в этом разделе, применяются к обеим операционным системам.

### <a name="case-sensitivity-in-powershell"></a>Учет регистра в PowerShell

Исторически сложилось так, что PowerShell был единообразно чувствителен к регистру, за некоторыми исключениями. В операционных системах, подобных UNIX, файловая система преимущественно чувствительна к регистру, а PowerShell придерживается стандарта файловой системы. Это проявляется разными способами, очевидными и неочевидными.

#### <a name="directly"></a>Напрямую

- При указании файла в PowerShell необходимо использовать правильный регистр.

#### <a name="indirectly"></a>Косвенно

- Если скрипт пытается загрузить модуль, а имя модуля задано в неправильном регистре, то произойдет сбой загрузки модуля. Это может вызвать проблемы с существующими скриптами, если имя, используемое для ссылки на модуль, не соответствует фактическому имени файла.
- Завершение клавишей TAB не выполняется автоматически, если в имени файла неверный регистр. Для завершения фрагмента необходим правильный регистр. (Для завершения имени и элемента типа регистр не учитывается.)

### <a name="ps1-file-extensions"></a>Расширения файлов .PS1

Скрипты PowerShell должны иметь расширение `.ps1`, чтобы интерпретатор мог определить, как загружать и запускать их в текущем процессе. Выполнение скриптов в текущем процессе является ожидаемым обычным поведением для PowerShell. К скрипту без расширения `.ps1` можно добавить магическое число `#!`, но в таком случае скрипт будет запущен в новом экземпляре PowerShell, из-за чего скрипт не будет работать должным образом при замене объектов. (Примечание. Это может быть желательным поведением при выполнении скрипта PowerShell из `bash` или другой оболочки.)

### <a name="missing-command-aliases"></a>Отсутствуют псевдонимы команд

В Linux и macOS были удалены "псевдонимы удобства" основных команд: `ls`, `cp`, `mv`, `rm`, `cat`, `man`, `mount`, `ps`. В Windows PowerShell предоставляет набор псевдонимов, сопоставленных с именами команд Linux для удобства работы пользователя. Эти псевдонимы были удалены из версии PowerShell по умолчанию в дистрибутивах Linux и macOS. Теперь собственный исполняемый файл можно запускать без указания пути.

Есть свои плюсы и минусы этого подхода. С удалением псевдонимов пользователь может использовать собственные команды PowerShell, но это снижает функциональность в оболочке, потому что собственные команды возвращают строки вместо объектов.

> [!NOTE]
> Команда PowerShell ждет обратной связи в отношении этого аспекта. Какое предпочтительное решение?
> Оставить все как есть или вернуть "псевдонимы удобства"? Перейдите к [проблеме № 929](https://github.com/PowerShell/PowerShell/issues/929).

### <a name="missing-wildcard-globbing-support"></a>Отсутствует поддержка подстановочных знаков (подставки)

В настоящее время PowerShell выполняет расширение подстановочных знаков (подстановку) только для встроенных командлетов в Windows, для внешних команд и двоичных файлов, а также командлетов в Linux. Это означает, что команда, такая как `ls
*.txt`, завершается сбоем, потому что звездочка не расширена для соответствия именам файлов. В качестве обходного решения можно выполнить `ls (gci *.txt | % name)` или, еще проще, `gci *.txt`, используя встроенный эквивалент PowerShell `ls`.

Перейдите к [проблеме № 954](https://github.com/PowerShell/PowerShell/issues/954), чтобы дать нам обратную связь о том, как улучшить подстановку в Linux и macOS.

### <a name="net-framework-vs-net-core-framework"></a>Платформы .NET Framework и .NET Core Framework

PowerShell в Linux и macOS использует .NET Core, которая является частью полной платформы .NET Framework в Microsoft Windows. Это важно, так как PowerShell предоставляет прямой доступ к базовым типам, методам платформы и т. д. В результате скрипты, которые запускаются в Windows, могут не работать в других системах из-за различий в платформах. Дополнительные сведения о .NET Core Framework см. на странице [dotnetfoundation.org](https://dotnetfoundation.org/).

С выходом [.NET Standard 2.0](https://devblogs.microsoft.com/dotnet/introducing-net-standard/) .NET Core 2.0 возвращает многие традиционные типы и методы, представленные в полной версии .NET Framework. Это означает, что PowerShell Core может загружать многие традиционные модули Windows PowerShell без изменений. Вы можете следить за нашей работой, связанной с .NET Standard 2.0, [здесь](https://github.com/PowerShell/PowerShell/projects/4).

### <a name="redirection-issues"></a>Проблемы с перенаправлением

Перенаправление ввода не поддерживается в PowerShell на любой платформе.
[Проблема № 1629](https://github.com/PowerShell/PowerShell/issues/1629)

Используйте команду `Get-Content`, чтобы записать содержимое файла в конвейер.

Перенаправленный вывод содержит метку порядка байтов в Юникоде при использовании кодировки по умолчанию (UTF-8). Метка порядка байтов вызывает проблемы при работе со служебными программами, которые не ожидают ее, или при добавлении к файлу. Используйте `-Encoding Ascii` для записи текста ASCII, у которого нет метки порядка байтов.

> [!Note]
> См. [RFC0020](https://github.com/PowerShell/PowerShell-RFC/issues/71), чтобы дать нам обратную связь по улучшению кодирования в PowerShell Core на всех платформах. Мы работаем над поддержкой UTF-8 без метки порядка байтов и будем менять значения кодировки по умолчанию для командлетов на разных платформах.

### <a name="job-control"></a>Управление заданиями

В PowerShell на Linux и macOS не поддерживается управление заданиями.
Команды `fg` и `bg` недоступны.

В настоящее время вы можете использовать [задания PowerShell](/powershell/module/microsoft.powershell.core/about/about_jobs), которые работают на всех платформах.

### <a name="remoting-support"></a>Поддержка удаленного взаимодействия

В настоящее время PowerShell Core поддерживает протокол удаленного взаимодействия PowerShell (PSRP) через WSMan с базовой проверкой подлинности в macOS и Linux и с аутентификацией на основе NTLM в Linux. (Проверка подлинности на основе Kerberos не поддерживается.)

Работа по удаленному взаимодействию на основе WSMan выполняется в репозитории [psl-omi-provider](https://github.com/PowerShell/psl-omi-provider).

PowerShell Core также поддерживает PSRP через SSH на всех платформах (Windows, macOS и Linux). Хотя это в настоящее время не поддерживается в рабочей среде, вы можете узнать больше о настройке этой конфигурации [здесь](../learn/remoting/SSH-Remoting-in-PowerShell-Core.md).

### <a name="just-enough-administration-jea-support"></a>Поддержка Just Enough Administration (JEA)

Возможность создания удаленных конечных точек с ограниченными возможностями администрирования (JEA) в настоящее время недоступна в PowerShell в Linux и macOS. Эта функция не будет добавлена в 6.0. Мы рассмотрим ее добавление в последующих версия, так как для этого требуется значительная работа по проектированию.

### <a name="sudo-exec-and-powershell"></a>`sudo`, `exec` и PowerShell

Так как PowerShell выполняет большинство команд в памяти (как Python или Ruby), вы не можете использовать sudo напрямую со встроенными модулями PowerShell. (Вы можете, конечно, запустить `pwsh` из sudo.) Если необходимо запустить командлет PowerShell с помощью sudo, например `sudo Set-Date 8/18/2016`, вам следует выполнить `sudo pwsh Set-Date 8/18/2016`. Аналогично вы не можете напрямую выполнить встроенную команду PowerShell. Вместо этого вам нужно будет выполнить `exec pwsh item_to_exec`.

Эта проблема отслеживается как часть проблемы [#3232](https://github.com/PowerShell/PowerShell/issues/3232).

### <a name="missing-cmdlets"></a>Отсутствующие командлеты

Большое количество команд (командлетов), обычно доступных в PowerShell, недоступно в Linux и macOS. Во многих случаях эти команды не нужны на этих платформах (например, функции Windows, такие как реестр). Другие команды, такие как команды управления службами (Get, Start, Stop-Service) присутствуют, но не работают. В последующих выпусках эти проблемы можно устранить путем исправления и с течением времени добавления новых командлетов.

### <a name="command-availability"></a>Доступность команд

В следующей таблице перечислены команды, которые, как известно, не работают в PowerShell в Linux и macOS.

|Команды|Рабочее состояние|Примечания|
|--------|-----------------|-----|
|`Get-Service`, `New-Service`, `Restart-Service`, `Resume-Service`, `Set-Service`, `Start-Service`, `Stop-Service`, `Suspend-Service`|Недоступно.|Эти команды не распознаются. Это должно быть исправлено в последующем выпуске.|
|`Get-Acl`, `Get-AuthenticodeSignature`, `Get-CmsMessage`, `New-FileCatalog`, `Protect-CmsMessage`, `Set-Acl`, `Set-AuthenticodeSignature`, `Test-FileCatalog`, `Unprotect-CmsMessage`|Недоступно.|Эти команды не распознаются. Это должно быть исправлено в последующем выпуске.|
|`Wait-Process`|Доступна, но не работает должным образом. |Например, `Start-Process gvim -PassThru | Wait-Process` не работает. Ошибка при ожидании процесса.|
|`Connect-PSSession`, `Disable-PSRemoting`, `Disable-PSSessionConfiguration`, `Disconnect-PSSession`, `Enable-PSRemoting`, `Enable-PSSessionConfiguration`, `Get-PSSessionCapability`, `Get-PSSessionConfiguration`, `New-PSSessionConfigurationFile`, `Receive-PSSession`, `Register-PSSessionConfiguration`, `Set-PSSessionConfiguration`, `Test-PSSessionConfigurationFile`, `Unregister-PSSessionConfiguration`|Недоступно.|Эти команды не распознаются. Это должно быть исправлено в последующем выпуске.|
|`Get-Event`, `New-Event`, `Register-EngineEvent`, `Remove-Event`, `Unregister-Event`|Доступно, но нет источников событий.|Команды событий PowerShell присутствуют, но большинство источников событий, используемых с командами (например, System.Timers.Timer), недоступны в Linux, что делает команды бесполезными в альфа-выпуске.|
|`Set-ExecutionPolicy`|Доступно, но не работает.|Возвращается сообщение о том, что команда не поддерживается на этой платформе. Политика выполнения — это ориентированный на пользователя "ремень безопасности", который помогает предотвратить дорогостоящие ошибки. Она не является границей безопасности.|
|`New-PSSessionOption`, `New-PSTransportOption`|Доступно, но `New-PSSession` не работает.|В настоящее время работа `New-PSSessionOption` и `New-PSTransportOption` не проверяется, так как работает командлет `New-PSSession`.|
