---
ms.date: 06/05/2017
keywords: powershell,командлет
title: Перенаправление данных с помощью командлетов Out
ms.assetid: 2a4acd33-041d-43a5-a3e9-9608a4c52b0c
ms.openlocfilehash: 7c601b09cc53524eb55014b8ea19a5d79cb98b0e
ms.sourcegitcommit: e7445ba8203da304286c591ff513900ad1c244a4
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "62086159"
---
# <a name="redirecting-data-with-out--cmdlets"></a>Перенаправление данных с помощью командлетов Out-*

Windows PowerShell предоставляет несколько командлетов, позволяющих напрямую управлять выходными данными. Эти командлеты обладают двумя важными характеристиками.

Во-первых, в общем случае они преобразуют данные в некоторую форму текста. Это вызвано тем, что они выводят данные в системные компоненты, принимающие текстовые входные данные. Поэтому они должны представлять объекты в виде текста. Таким образом, текст форматируется в том виде, в котором отображается в окне консоли Windows PowerShell.

Во-вторых, эти командлеты используют глагол **Out** Windows PowerShell, так как отправляют сведения из Windows PowerShell в другое место. Командлет **Out-Host** не является исключением: отображение основного окна выходит за пределы Windows PowerShell. Это важно, так как при отправке данных из Windows PowerShell они фактически удаляются. Это можно увидеть, если попытаться создать конвейер, выводящий страницы данных в основное окно, а затем попробовать отформатировать их в виде списка, как показано ниже:

```powershell
Get-Process | Out-Host -Paging | Format-List
```

Можно ожидать, что команда отобразит страницы сведений о процессах в формате списка. Вместо этого она отображает табличный список по умолчанию:

```output
Handles  NPM(K)    PM(K)      WS(K) VM(M)   CPU(s)     Id ProcessName
-------  ------    -----      ----- -----   ------     -- -----------
    101       5     1076       3316    32     0.05   2888 alg
...
    618      18    39348      51108   143   211.20    740 explorer
    257       8     9752      16828    79     3.02   2560 explorer
...
<SPACE> next page; <CR> next line; Q quit
...
```

Командлет **Out-Host** отправляет данные непосредственно в консоль, поэтому команда **Format-List** не получает ничего для форматирования.

Правильный способ использования этой команды заключается в том, чтобы поместить командлет **Out-Host** в конце конвейера, как показано ниже. В результате перед разбиением на страницы и отображением данные процессов форматируются в виде списка.

```
PS> Get-Process | Format-List | Out-Host -Paging

Id      : 2888
Handles : 101
CPU     : 0.046875
Name    : alg
...

Id      : 740
Handles : 612
CPU     : 211.703125
Name    : explorer

Id      : 2560
Handles : 257
CPU     : 3.015625
Name    : explorer
...
<SPACE> next page; <CR> next line; Q quit
...
```

Это касается всех командлетов **Out**. Командлет **Out** должен всегда находиться в конце конвейера.

> [!NOTE]
> Все командлеты **Out** отображают выходные данные в виде текста, используя при этом действующее в окне консоли форматирование, включая ограничения длины строки.

## <a name="paging-console-output-out-host"></a>Разбиение выходных данных консоли на страницы (Out-Host)

По умолчанию Windows PowerShell отправляет данные в основное окно. Именно это и делает командлет Out-Host. Как мы уже упоминали, основным назначением командлета Out-Host является разбиение на страницы. Например, следующая команда использует Out-Host для разбиения выходных данных командлета Get-Command на страницы.

```powershell
Get-Command | Out-Host -Paging
```

Для разбиения на страницы также можно использовать функцию **more**. В Windows PowerShell функция **more** вызывает **Out-Host -Paging**. Следующая команда демонстрирует использование функции **more** для разбиения выходных данных Get-Command на страницы.

```powershell
Get-Command | more
```

Если включить в функцию more одно или несколько имен файлов в качестве аргументов, она считывает указанные файлы, разбивает их содержимое на страницы и передает его на узел:

```
PS> more c:\boot.ini
[boot loader]
timeout=5
default=multi(0)disk(0)rdisk(0)partition(1)\WINDOWS
[operating systems]
...
```

## <a name="discarding-output-out-null"></a>Удаление выходных данных (Out-Null)

Командлет **Out-Null** предназначен для немедленного удаления всех получаемых входных данных. Это удобно для удаления посторонних данных, получаемых при выполнении команды. При вводе следующей команды никакие данные не возвращаются:

```powershell
Get-Command | Out-Null
```

Командлет **Out-Null** не удаляет выходные данные ошибок. Например, если ввести следующую команду, появляется сообщение о том, что Windows PowerShell не распознает Is-NotACommand.

```
PS> Get-Command Is-NotACommand | Out-Null
Get-Command : 'Is-NotACommand' is not recognized as a cmdlet, function, operabl
e program, or script file.
At line:1 char:12
+ Get-Command  <<<< Is-NotACommand | Out-Null
```

## <a name="printing-data-out-printer"></a>Печать данных (Out-Printer)

Данные можно распечатать с помощью командлета **Out-Printer**. Если имя принтера не задано, командлет **Out-Printer** использует принтер по умолчанию. Можно использовать любой принтер, совместимый с Windows, указав его отображаемое имя. Сопоставление портов и даже наличие физического принтера при этом не требуется. Например, при наличии установленных средств Microsoft Office Document Imaging можно отправить данные в файл образа, введя следующее:

```powershell
Get-Command Get-Command | Out-Printer -Name 'Microsoft Office Document Image Writer'
```

## <a name="saving-data-out-file"></a>Сохранение данных (Out-File)

С помощью командлета **Out-File** выходные данные можно отправить в файл, а не в окно консоли. Следующая команда отправляет список процессов в файл **C:\\temp\\processlist.txt**:

```powershell
Get-Process | Out-File -FilePath C:\temp\processlist.txt
```

Результаты использования командлета **Out-File** могут отличаться от ожидаемых, если вы привыкли к стандартному перенаправлению выходных данных. Чтобы понять поведение командлета **Out-File**, необходимо помнить о контексте его выполнения.

По умолчанию командлет **Out-File** создает файл в кодировке Юникод. В долгосрочной перспективе это лучший вариант по умолчанию, однако при нем средства, ожидающие файлы в кодировке ASCII, будут работать неправильно. Формат вывода по умолчанию можно изменить на ASCII с помощью параметра **Encoding**:

```powershell
Get-Process | Out-File -FilePath C:\temp\processlist.txt -Encoding ASCII
```

**Out-File** форматирует содержимое файлов, чтобы оно было похоже на выходные данные консоли. В результате выходные данные усекаются, как в большинстве случаев и происходит в окне консоли. Например, если выполнить следующую команду:

```powershell
Get-Command | Out-File -FilePath c:\temp\output.txt
```

Результат будет выглядеть так:

```output
CommandType     Name                            Definition
-----------     ----                            ----------
Cmdlet          Add-Content                     Add-Content [-Path] <String[...
Cmdlet          Add-History                     Add-History [[-InputObject] ...
...
```

Чтобы получить выходные данные без принудительных переносов по словам по ширине экрана, можно использовать параметр **Width** для указания ширины строки. Так как параметр **Width** — это 32-разрядное целое число, его максимальное значение равно 2147483647. Введите следующую команду, чтобы установить ширину строки в максимальное значение:

```powershell
Get-Command | Out-File -FilePath c:\temp\output.txt -Width 2147483647
```

Командлет **Out-File** наиболее полезен, если требуется сохранить выходные данные в том виде, в котором они отображались бы на консоли. Для более точного управления форматом выходных данных требуются более сложные средства. Мы рассмотрим их в следующей главе, где приведены и дополнительные сведения о работе с объектами.