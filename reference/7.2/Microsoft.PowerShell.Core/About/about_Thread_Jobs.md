---
description: Предоставляет сведения о заданиях, основанных на потоках PowerShell. Задание потока — это тип фонового задания, выполняющего команду или выражение в отдельном потоке в рамках текущего процесса сеанса.
Locale: en-US
ms.date: 11/11/2020
online version: 1.0.0
schema: 2.0.0
title: about_Thread_Jobs
ms.openlocfilehash: 88880a6c58ddc02d7b35a44af7169f6c5af19a10
ms.sourcegitcommit: 95d41698c7a2450eeb70ef2fb6507fe7e6eff3b6
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/17/2020
ms.locfileid: "99602872"
---
# <a name="about-thread-jobs"></a>О заданиях потоков

## <a name="short-description"></a>Краткое описание

Предоставляет сведения о заданиях, основанных на потоках PowerShell. Задание потока — это тип фонового задания, выполняющего команду или выражение в отдельном потоке в рамках текущего процесса сеанса.

## <a name="long-description"></a>Подробное описание

PowerShell параллельно выполняет команды и скрипты с помощью заданий. Существует три типа заданий, предоставляемых PowerShell для поддержки параллелизма.

- `RemoteJob` — Команды и скрипты выполняются в удаленном сеансе. Дополнительные сведения см. в разделе [about_Remote_Jobs](about_Remote_Jobs.md).
- `BackgroundJob` — Команды и скрипты выполняются в отдельном процессе на локальном компьютере. См. дополнительные сведения о [заданиях](about_Jobs.md).
- `PSTaskJob` или `ThreadJob` — команды и скрипты выполняются в отдельном потоке в том же процессе на локальном компьютере.

Задания на основе потоков не так надежны, как удаленные и фоновые задания, так как они выполняются в одном и том же процессе в разных потоках. Если в одном задании есть критическая ошибка, которая приводит к сбою процесса, то все остальные задания в этом процессе завершаются.

Однако задания на основе потоков нуждаются в меньшей нагрузке. Они не используют удаленный уровень или сериализацию. Результирующие объекты возвращаются в виде ссылок на активные объекты в текущем сеансе. Без такой нагрузки задания на основе потоков выполняются быстрее и используют меньше ресурсов, чем другие типы заданий.

> [!IMPORTANT]
> Родительский сеанс, создавший задание, также отслеживает состояние задания и собирает данные конвейера. Дочерний процесс задания завершается родительским процессом после того, как задание достигнет завершенного состояния. Если родительский сеанс завершается, все выполняющиеся дочерние задания завершаются вместе с их дочерними процессами.

Существует два способа обойти эту ситуацию.

1. Используйте `Invoke-Command` для создания заданий, выполняемых в отключенных сеансах. Дополнительные сведения см. в разделе [about_Remote_Jobs](about_Remote_Jobs.md).
1. Используйте `Start-Process` для создания нового процесса, а не задания. Дополнительные сведения см. в разделе [Start-Process](xref:Microsoft.PowerShell.Management.Start-Process).

## <a name="how-to-start-and-manage-thread-based-jobs"></a>Запуск и управление заданиями на основе потоков

Запускать задания на основе потоков можно двумя способами:

- `Start-ThreadJob`— из модуля **среаджоб**
- `ForEach-Object -Parallel -AsJob` — компонент Parallel был добавлен в PowerShell 7,0

Используйте те же командлеты **задания** , которые описаны в [about_Jobs](about_Jobs.md) для управления заданиями на основе потоков.

### <a name="using-start-threadjob"></a>Использование `Start-ThreadJob`

Модуль **среаджоб** , который впервые поставлялся с PowerShell 6. Его также можно установить из коллекция PowerShell для Windows PowerShell 5,1.

Чтобы запустить задание потока на локальном компьютере, используйте `Start-ThreadJob` командлет с командой или сценарием, заключенными в фигурные скобки ( `{ }` ).

В следующем примере запускается задание потока, выполняющее `Get-Process` команду на локальном компьютере.

```powershell
Start-ThreadJob -ScriptBlock { Get-Process }
```

`Start-ThreadJob`Команда возвращает `ThreadJob` объект, представляющий выполняемое задание. Объект задания содержит полезные сведения о задании, включая текущее состояние выполнения. Он собирает результаты выполнения задания по мере формирования результатов.

### <a name="using-foreach-object--parallel--asjob"></a>Использование `ForEach-Object -Parallel -AsJob`

В PowerShell 7,0 добавлен новый набор параметров в `ForEach-Object` командлет. Новые параметры позволяют запускать блоки сценариев в параллельных потоках как задания PowerShell.

Вы можете передать данные в `ForEach-Object -Parallel` . Данные передаются в блок скрипта, который выполняется параллельно. `-AsJob`Параметр создает объекты заданий для каждого из параллельных потоков.

Следующая команда запускает задание, которое содержит дочерние задания для каждого входного значения, переданного команде. Каждое дочернее задание выполняет `Write-Output` команду с входным значением, переданным в качестве аргумента.

```powershell
1..5 | ForEach-Object -Parallel { Write-Output $_ } -AsJob
```

`ForEach-Object -Parallel`Команда возвращает `PSTaskJob` объект, содержащий дочерние задания для каждого входного значения перенаправленного. Объект задания содержит полезные сведения о состоянии выполнения дочерних заданий. Он собирает результаты дочерних заданий по мере формирования результатов.

## <a name="how-to-wait-for-a-job-to-complete-and-retrieve-job-results"></a>Как дождаться завершения задания и получить результаты задания

Вы можете использовать командлеты задания PowerShell, такие как `Wait-Job` и, `Receive-Job` чтобы дождаться завершения задания, а затем вернуть все результаты, созданные заданием.

Следующая команда запускает задание потока, которое выполняет `Get-Process` команду, затем ожидает завершения команды и возвращает все результаты данных, созданные командой.

```powershell
Start-ThreadJob -ScriptBlock { Get-Process } | Wait-Job | Receive-Job
```

Следующая команда запускает задание, которое выполняет `Write-Output` команду для каждого входного значения, а затем ожидает завершения всех дочерних заданий и возвращает все результаты данных, созданные дочерними заданиями.

```powershell
1..5 | ForEach-Object -Parallel { Write-Output $_ } -AsJob | Wait-Job | Receive-Job
```

`Receive-Job`Командлет возвращает результаты дочерних заданий.

```powershell
1
3
2
4
5
```

Так как каждое дочернее задание выполняется параллельно, порядок созданных результатов не гарантируется.

## <a name="thread-job-performance"></a>Производительность задания потока

Задания потоков выполняются быстрее и легче, чем другие типы заданий. Но они по-прежнему имеют накладные расходы, которые могут быть большими по сравнению с работой, выполняемой заданием.

PowerShell запускает команды и скрипты в сеансе. Только одна команда или сценарий может выполняться одновременно в сеансе. Поэтому при выполнении нескольких заданий каждое задание выполняется в отдельном сеансе. Каждый сеанс влияет на накладные расходы.

Задания потоков обеспечивают наилучшую производительность, когда работа, выполняемая ими, превышает издержки сеанса, используемого для выполнения задания. Существует два варианта соответствия этого критерия.

- Работа — это большое количество вычислительных ресурсов. выполнение скрипта для нескольких заданий потоков может использовать преимущества нескольких процессорных ядер и ускорить работу.

- Работа состоит из значительного ожидающего сценария, который тратит время на ожидание результатов ввода-вывода или удаленного вызова. Параллельное выполнение обычно завершается быстрее, чем при последовательном выполнении.

```powershell
(Measure-Command {
    1..1000 | ForEach { Start-ThreadJob { Write-Output "Hello $using:_" } } | Receive-Job -Wait
}).TotalMilliseconds
36860.8226

(Measure-Command {
    1..1000 | ForEach-Object { "Hello: $_" }
}).TotalMilliseconds
7.1975
```

В первом примере показан цикл foreach, который создает задания потоков 1000, чтобы выполнить простую запись в строку. Из-за накладных расходов на задание выполнение займет более 36 секунд.

Во втором примере командлет запускается `ForEach` для выполнения тех же операций 1000.
На этот раз `ForEach-Object` выполняется последовательно в одном потоке без дополнительных издержек заданий. Она завершается всего за 7 миллисекунд.

В следующем примере собираются до 5000 записей для 10 отдельных системных журналов. Поскольку сценарий включает чтение нескольких журналов, имеет смысл выполнять операции параллельно.

```powershell
$logNames.count
10

Measure-Command {
    $logs = $logNames | ForEach-Object {
        Get-WinEvent -LogName $_ -MaxEvents 5000 2>$null
    }
}

TotalMilliseconds : 252398.4321 (4 minutes 12 seconds)
$logs.Count
50000
```

Скрипт завершается в половину времени, когда задания выполняются параллельно.

```powershell
Measure-Command {
    $logs = $logNames | ForEach {
        Start-ThreadJob {
            Get-WinEvent -LogName $using:_ -MaxEvents 5000 2>$null
        } -ThrottleLimit 10
    } | Wait-Job | Receive-Job
}

TotalMilliseconds : 115994.3 (1 minute 56 seconds)
$logs.Count
50000
```

## <a name="thread-jobs-and-variables"></a>Задания и переменные потоков

Существует несколько способов передачи значений в задания на основе потоков.

`Start-ThreadJob` может принимать переменные, передаваемые в командлет, переданные в блок скрипта через `$using` ключевое слово или передаваемые через параметр **ArgumentList** .

```powershell
$msg = "Hello"

$msg | Start-ThreadJob { $input | Write-Output } | Wait-Job | Receive-Job

Start-ThreadJob { Write-Output $using:msg } | Wait-Job | Receive-Job

Start-ThreadJob { param ([string] $message) Write-Output $message } -ArgumentList @($msg) |
  Wait-Job | Receive-Job
```

`ForEach-Object -Parallel` принимает переданные переменные и переменные, передаваемые непосредственно в блок скрипта с помощью `$using` ключевого слова.

```powershell
$msg = "Hello"

$msg | ForEach-Object -Parallel { Write-Output $_ } -AsJob | Wait-Job | Receive-Job

1..1 | ForEach-Object -Parallel { Write-Output $using:msg } -AsJob | Wait-Job | Receive-Job
```

Так как задания потоков выполняются в одном процессе, любой ссылочный тип переменной, переданный в задание, должен обрабатываться аккуратно. Если он не является потокобезопасным объектом, ему никогда не следует присваивать значение, а метод и свойства никогда не должны вызываться для него.

В следующем примере потокобезопасный объект .NET передается `ConcurrentDictionary` во все дочерние задания для получения объектов процессов с уникальными именами. Поскольку это потокобезопасный объект, его можно безопасно использовать во время параллельного выполнения заданий в процессе.

```powershell
$threadSafeDictionary = [System.Collections.Concurrent.ConcurrentDictionary[string,object]]::new()
$jobs = Get-Process | ForEach {
    Start-ThreadJob {
        $proc = $using:_
        $dict = $using:threadSafeDictionary
        $dict.TryAdd($proc.ProcessName, $proc)
    }
}
$jobs | Wait-Job | Receive-Job

$threadSafeDictionary.Count
96

$threadSafeDictionary["pwsh"]

NPM(K)  PM(M)   WS(M) CPU(s)    Id SI ProcessName
------  -----   ----- ------    -- -- -----------
  112  108.25  124.43  69.75 16272  1 pwsh
```

## <a name="see-also"></a>См. также

- [about_Remote_Jobs](about_Remote_Jobs.md)
- [about_Thread_Jobs](about_Thread_Jobs.md)
- [about_Job_Details](about_Job_Details.md)
- [about_Remote](about_Remote.md)
- [about_PSSessions](about_PSSessions.md)
- [Start-Job](xref:Microsoft.PowerShell.Core.Start-Job)
- [Get-Job.](xref:Microsoft.PowerShell.Core.Get-Job)
- [Receive-Job.](xref:Microsoft.PowerShell.Core.Receive-Job)
- [Stop-Job.](xref:Microsoft.PowerShell.Core.Stop-Job)
- [Wait-Job](xref:Microsoft.PowerShell.Core.Wait-Job)
- [Remove-Job](xref:Microsoft.PowerShell.Core.Remove-Job)
