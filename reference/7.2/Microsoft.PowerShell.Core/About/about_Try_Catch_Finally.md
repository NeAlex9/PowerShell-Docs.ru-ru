---
description: Описывает использование `Try` `Catch` блоков, и `Finally` для управления завершающими ошибками.
Locale: en-US
ms.date: 04/01/2019
online version: https://docs.microsoft.com/powershell/module/microsoft.powershell.core/about/about_try_catch_finally?view=powershell-7.2&WT.mc_id=ps-gethelp
schema: 2.0.0
title: about_Try_Catch_Finally
ms.openlocfilehash: c93fa69e3badd7777950a850dfe81b79f9197f68
ms.sourcegitcommit: 95d41698c7a2450eeb70ef2fb6507fe7e6eff3b6
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/17/2020
ms.locfileid: "99601295"
---
# <a name="about-try-catch-finally"></a>О программе try catch finally

## <a name="short-description"></a>КРАТКОЕ ОПИСАНИЕ
Описывает использование `Try` `Catch` блоков, и `Finally` для управления завершающими ошибками.

## <a name="long-description"></a>ПОДРОБНОЕ ОПИСАНИЕ

Используйте `Try` `Catch` блоки, и, `Finally` чтобы реагировать на ошибки в скриптах или обрабатывать их. Эту `Trap` инструкцию также можно использовать для управления завершающими ошибками в скриптах. Дополнительные сведения см. в разделе [about_Trap](about_Trap.md).

Завершающая ошибка останавливает выполнение инструкции. Если PowerShell не обрабатывает завершающую ошибку каким-либо образом, PowerShell также прекращает выполнение функции или скрипта с помощью текущего конвейера. На других языках, таких как C \# , завершающие ошибки называются исключениями.

Используйте `Try` блок, чтобы определить раздел скрипта, в котором PowerShell должен отслеживать ошибки. При возникновении ошибки в `Try` блоке ошибка сначала сохраняется в `$Error` автоматическую переменную. Затем PowerShell выполняет поиск `Catch` блока, обрабатывающего ошибку. Если `Try` инструкция не имеет соответствующего `Catch` блока, PowerShell продолжит поиск соответствующего `Catch` блока или `Trap` оператора в родительских областях. После `Catch` завершения блока или в случае, если соответствующий `Catch` блок или `Trap` инструкция не найдены, `Finally` выполняется блок. Если ошибка не может быть обработана, эта ошибка записывается в поток ошибок.

`Catch`Блок может включать команды для отслеживания ошибки или для восстановления ожидаемого потока скрипта. `Catch`Блок может указывать, какие типы ошибок перехватываются. `Try`Инструкция может включать несколько `Catch` блоков для различных типов ошибок.

`Finally`Блок можно использовать для высвобождения ресурсов, которые больше не нужны для скрипта.

`Try`, `Catch` и `Finally` похожи на `Try` `Catch` Ключевые слова, и, `Finally` используемые в \# языке программирования C.

### <a name="syntax"></a>SYNTAX

`Try`Оператор содержит `Try` блок, ноль или более `Catch` блоков, а также ноль или один `Finally` блок. `Try`Оператор должен иметь по крайней мере один `Catch` блок или один `Finally` блок.

Ниже показан `Try` Синтаксис блока.

```powershell
try {<statement list>}
```

`Try`За ключевым словом следует список операторов в фигурных скобках. Если при выполнении инструкций в списке инструкций выполняется завершающая ошибка, скрипт передает объект ошибки из `Try` блока в соответствующий `Catch` блок.

Ниже показан `Catch` Синтаксис блока.

```powershell
catch [[<error type>][',' <error type>]*] {<statement list>}
```

Типы ошибок отображаются в квадратных скобках. Внешняя скобка указывает, что элемент является необязательным.

`Catch`За ключевым словом следует необязательный список спецификаций типов ошибок и список инструкций. Если в блоке возникает неустранимая ошибка `Try` , PowerShell выполняет поиск соответствующего `Catch` блока. Если он найден, выполняются инструкции в `Catch` блоке.

`Catch`Блок может указывать один или несколько типов ошибок. Тип ошибки является исключением Microsoft .NET Framework или исключением, производным от исключения платформа .NET Framework. `Catch`Блок обрабатывает ошибки указанного платформа .NET Framework класса исключений или любого класса, производного от указанного класса.

Если `Catch` блок указывает тип ошибки, этот `Catch` блок обрабатывает этот тип ошибки. Если в `Catch` блоке не указан тип ошибки, этот `Catch` блок обрабатывает все ошибки, обнаруженные в `Try` блоке. `Try`Инструкция может включать несколько `Catch` блоков для различных указанных типов ошибок.

Ниже показан `Finally` Синтаксис блока.

```powershell
finally {<statement list>}
```

`Finally`За ключевым словом следует список операторов, который выполняется каждый раз при выполнении скрипта, даже если `Try` Инструкция выполнена без ошибок или в инструкции обнаружена ошибка `Catch` .

Обратите внимание, что нажатие клавиши <kbd>CTRL</kbd> + <kbd>C</kbd> останавливает конвейер. Объекты, отправленные в конвейер, не будут отображаться как выходные данные. Таким образом, если включить отображаемый оператор, например "выполнение блока finally", он не будет отображаться после нажатия клавиши <kbd>CTRL</kbd> + <kbd>C</kbd>, даже если `Finally` блок был запущен.

### <a name="catching-errors"></a>ПЕРЕХВАТ ОШИБОК

В следующем примере скрипта показан `Try` блок с `Catch` блоком:

```powershell
try { NonsenseString }
catch { "An error occurred." }
```

`Catch`Ключевое слово должно следовать непосредственно за `Try` блоком или другим `Catch` блоком.

PowerShell не распознает "Нонсенсестринг" как командлет или другой элемент.
Выполнение этого скрипта возвращает следующий результат:

```powershell
An error occurred.
```

Когда сценарий встречает "Нонсенсестринг", это приводит к завершающей ошибке. `Catch`Блок обрабатывает ошибку, выполняя список инструкций внутри блока.

### <a name="using-multiple-catch-statements"></a>ИСПОЛЬЗОВАНИЕ НЕСКОЛЬКИХ ОПЕРАТОРОВ CATCH

`Try`Оператор может иметь любое количество `Catch` блоков. Например, следующий сценарий содержит `Try` блок, который скачивается `MyDoc.doc` и содержит два блока `Catch` :

```powershell
try {
   $wc = new-object System.Net.WebClient
   $wc.DownloadFile("http://www.contoso.com/MyDoc.doc","c:\temp\MyDoc.doc")
}
catch [System.Net.WebException],[System.IO.IOException] {
    "Unable to download MyDoc.doc from http://www.contoso.com."
}
catch {
    "An error occurred that could not be resolved."
}

```

Первый `Catch` блок обрабатывает ошибки типов **System .NET., except** и **System. IO. IOException** . Второй `Catch` блок не указывает тип ошибки. Второй `Catch` блок обрабатывает любые другие возникающие ошибки.

PowerShell сопоставляет типы ошибок путем наследования. `Catch`Блок обрабатывает ошибки указанного платформа .NET Framework класса исключений или любого класса, производного от указанного класса. Следующий пример содержит `Catch` блок, который перехватывает ошибку "команда не найдена":

```powershell
catch [System.Management.Automation.CommandNotFoundException]
{"Inherited Exception" }
```

Указанный тип ошибки, **комманднотфаундексцептион**, наследуется от типа **темексцептионSystem.Sys** . В следующем примере также перехватывается ошибка "команда не найдена":

```powershell
catch [System.SystemException] {"Base Exception" }
```

Этот `Catch` блок обрабатывает ошибку "команда не найдена" и другие ошибки, унаследованные от типа **SystemException** .

Если указать класс Error и один из его производных классов, поместите `Catch` блок для производного класса перед `Catch` блоком для общего класса.

### <a name="using-traps-in-a-try-catch"></a>Использование ловушек в блоке try catch

При возникновении завершающей ошибки в `Try` блоке с `Trap` определенным внутри `Try` блока, даже если существует соответствующий `Catch` блок, `Trap` оператор получает управление.

Если объект `Trap` существует в блоке более высокого уровня `Try` , чем, и в `Catch` текущей области нет соответствующего блока, то `Trap` будет принимать управление, даже если в какой-либо родительской области есть соответствующий `Catch` блок.

### <a name="accessing-exception-information"></a>ДОСТУП К СВЕДЕНИЯМ ОБ ИСКЛЮЧЕНИЯХ

В `Catch` блоке доступ к текущей ошибке можно получить с помощью `$_` , который также называется `$PSItem` . Объект имеет тип **ерроррекорд**.

```powershell
try { NonsenseString }
catch {
  Write-Host "An error occurred:"
  Write-Host $_
}
```

Выполнение этого скрипта возвращает следующий результат:

```Output
An Error occurred:
The term 'NonsenseString' is not recognized as the name of a cmdlet, function,
script file, or operable program. Check the spelling of the name, or if a path
was included, verify that the path is correct and try again.
```

Существуют дополнительные свойства, к которым можно получить доступ, например **скриптстакктраце**, **Exception** и **ErrorDetails**.  Например, если мы изменим сценарий следующим образом:

```powershell
try { NonsenseString }
catch {
  Write-Host "An error occurred:"
  Write-Host $_.ScriptStackTrace
}
```

Результат будет следующим:

```
An Error occurred:
at <ScriptBlock>, <No file>: line 2
```

### <a name="freeing-resources-by-using-finally"></a>ОСВОБОЖДЕНИЕ РЕСУРСОВ С ПОМОЩЬЮ FINALLY

Чтобы освободить ресурсы, используемые сценарием, добавьте `Finally` блок после `Try` `Catch` блоков и. `Finally`Операторы блока выполняются независимо от того, обнаруживает ли `Try` блок завершающую ошибку. PowerShell выполняет `Finally` блок до завершения сценария или до выхода из области действия текущего блока.

`Finally`Блок выполняется, даже если для его завершения используется <kbd>сочетание клавиш CTRL</kbd> + <kbd>C</kbd> . `Finally`Блок также запускается, если ключевое слово Exit останавливает скрипт из `Catch` блока.

### <a name="see-also"></a>СМ. ТАКЖЕ

[about_Break](about_Break.md)

[about_Continue](about_Continue.md)

[about_Scopes](about_Scopes.md)

[about_Throw](about_Throw.md)

[about_Trap](about_Trap.md)

