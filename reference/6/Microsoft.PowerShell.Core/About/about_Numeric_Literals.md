---
description: Целочисленные и вещественные числовые литералы могут иметь суффиксы типа и множителя.
Locale: en-US
ms.date: 04/09/2018
online version: https://docs.microsoft.com/powershell/module/microsoft.powershell.core/about/about_numeric_literals?view=powershell-6&WT.mc_id=ps-gethelp
schema: 2.0.0
title: О числовых литералах
ms.openlocfilehash: dc1a55dbec1f0de99e06011645e6884b37480233
ms.sourcegitcommit: 39c2a697228276d5dae39e540995fa479c2b5f39
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/05/2020
ms.locfileid: "93354835"
---
# <a name="about-numeric-literals"></a>О числовых литералах

Существует два вида числовых литералов: integer и Real. Оба могут иметь суффиксы типа и множителя.

## <a name="integer-literals"></a>Целочисленные литералы

Целочисленные литералы могут быть записаны в десятичной или шестнадцатеричной нотации. Шестнадцатеричные литералы начинаются с префикса, `0x` чтобы отличать их от десятичных чисел.

Целочисленные литералы могут иметь суффикс типа и суффикс множителя.

| Суффикс |            Значение             |          Примечание           |
| ------ | ------------------------------ | ----------------------- |
| да      | тип данных Byte со знаком          | Добавлено в PowerShell 6,2 |
| Uy     | тип данных Byte без знака        | Добавлено в PowerShell 6,2 |
| s      | short - тип данных                | Добавлено в PowerShell 6,2 |
| us     | короткий тип данных без знака       | Добавлено в PowerShell 6,2 |
| l      | тип данных Long                 |                         |
| u      | целое число без знака или тип данных Long | Добавлено в PowerShell 6,2 |
| ul     | тип данных Long без знака        | Добавлено в PowerShell 6,2 |
| kb     | множитель в килобайтах            |                         |
| mb     | множитель в мегабайтах            |                         |
| Гбайт     | множитель гигабайта            |                         |
| Тбайт     | терабайт, множитель            |                         |
| МС     | множитель петабайтного уровня            |                         |

Тип целочисленного литерала определяется его значением, суффиксом типа и суффиксом числового множителя.

Для целочисленного литерала без суффикса типа:

- Если значение может быть представлено типом `[int]` , то есть его типом.
- В противном случае, если значение может быть представлено типом `[long]` , то есть его тип.
- В противном случае, если значение может быть представлено типом `[decimal]` , то есть его тип.
- В противном случае он представлен типом `[double]` .

Для целочисленного литерала с суффиксом типа:

- Если суффикс типа — `u` , а значение может быть представлено типом, `[uint]` то его тип — `[uint]` .
- Если суффикс типа — `u` , а значение может быть представлено типом, `[ulong]` то его тип — `[ulong]` .
- Если его значение может быть представлено указанным типом, то это тип.
- В противном случае этот литерал имеет неправильный формат.

## <a name="real-literals"></a>Вещественные литералы

Реальные литералы могут быть записаны только в десятичной нотации. Эта нотация может содержать дробные значения, следующие за десятичной запятой и экспоненциальной нотацией, с использованием экспоненциальной части.

Экспоненциальная часть включает символ "e", за которым следует необязательный знак (+/-) и число, представляющее показатель степени. Например, литеральное значение `1e2` равно числовому значению 100.

Реальные литералы могут иметь суффикс типа и суффикс множителя.

| Суффикс |       Значение       |
| ------ | ------------------- |
| d      | тип данных decimal   |
| kb     | множитель в килобайтах |
| mb     | множитель в мегабайтах |
| Гбайт     | множитель гигабайта |
| Тбайт     | терабайт, множитель |
| МС     | множитель петабайтного уровня |

Существует два вида вещественных литералов: Double и Decimal. Они обозначаются отсутствием или присутствием соответственно для суффикса десятичного типа. PowerShell не поддерживает литеральное представление `[float]` значения. Двойной вещественный литерал имеет тип `[double]` . Десятичный вещественный литерал имеет тип `[decimal]` .
В дробной части вещественного десятичного литерала учитываются нули в конце.

Если значение числа цифр экспоненты в `[double]` вещественном литерале меньше минимального поддерживаемого значения, значение этого `[double]` литерала равно 0. Если значение числа цифр экспоненты в `[decimal]` вещественном литерале меньше минимального поддерживаемого значения, то литерал имеет неправильный формат. Если значение числа цифр экспоненты в `[double]` или `[decimal]` вещественном литерале больше поддерживаемого максимума, этот литерал имеет неправильный формат.

> [!NOTE]
> Синтаксис допускает наличие суффикса длинного типа в двойном вещественном литерале.
> PowerShell обрабатывает этот случай как целочисленный литерал, значение которого представлено типом `[long]` . Эта функция была сохранена для обеспечения обратной совместимости с более ранними версиями PowerShell. Однако программистам не рекомендуется использовать целочисленные литералы этой формы, так как они могут легко скрывать фактическое значение литерала. Например, `1.2L` имеет значение 1, `1.2345e1L` значение 12 и `1.2345e-5L` имеет значение 0, ни одно из этих значений сразу не очевидно.

## <a name="numeric-multipliers"></a>Числовые множители

Для удобства целочисленные и реальные литералы могут содержать числовой множитель, указывающий на один из множества часто используемых степеней 2. Числовой множитель можно записать в любом сочетании прописных или строчных букв.

Суффиксы множителя можно использовать в сочетании с `u` `ul` `l` суффиксами типов, и.

### <a name="multiplier-examples"></a>Примеры множителя

```
PS> 1kb
1024

PS> 1.30Dmb
1363148.80

PS> 0x10Gb
17179869184

PS> 1.4e23tb
1.5393162788864E+35

PS> 0x12Lpb
20266198323167232
```

## <a name="numeric-type-accelerators"></a>Сочетания числовых типов

PowerShell поддерживает следующие ускорители типов:

| Accelerator |         Примечание         |           Описание            |
| ----------- | -------------------- | -------------------------------- |
| `[byte]`    |                      | Byte (без знака)                  |
| `[sbyte]`   |                      | Byte (со знаком)                    |
| `[Int16]`   |                      | 16-разрядное целое число                   |
| `[short]`   | псевдоним для `[int16]`  | 16-разрядное целое число                   |
| `[UInt16]`  |                      | 16-разрядное целое число (без знака)        |
| `[ushort]`  | псевдоним для `[uint16]` | 16-разрядное целое число (без знака)        |
| `[Int32]`   |                      | 32-разрядное целое число                   |
| `[int]`     | псевдоним для `[int32]`  | 32-разрядное целое число                   |
| `[UInt32]`  |                      | 32-разрядное целое число (без знака)        |
| `[uint]`    | псевдоним для `[uint32]` | 32-разрядное целое число (без знака)        |
| `[Int64]`   |                      | 64-разрядное целое число                   |
| `[long]`    | псевдоним для `[int64]`  | 64-разрядное целое число                   |
| `[UInt64]`  |                      | 64-разрядное целое число (без знака)        |
| `[ulong]`   | псевдоним для `[uint64]` | 64-разрядное целое число (без знака)        |
| `[bigint]`  |                      | См. [структуру BigInteger][bigint]  |
| `[single]`  |                      | Одинарная точность с плавающей запятой  |
| `[float]`   | псевдоним для `[single]` | Одинарная точность с плавающей запятой  |
| `[double]`  |                      | Плавающая точка с двойной точностью  |
| `[decimal]` |                      | 128-разрядная с плавающей запятой           |

> [!NOTE]
> В PowerShell 6,2 были добавлены следующие ускорители типов: `[short]` , `[ushort]` , `[uint]` , `[ulong]` .

### <a name="working-with-other-numeric-types"></a>Работа с другими числовыми типами

Для работы с любыми другими числовыми типами необходимо использовать ускорители типов, которые не позволяют устранить некоторые проблемы. Например, большие целочисленные значения всегда анализируются как Double перед их приведением к любому другому типу.

```
PS> [bigint]111111111111111111111111111111111111111111111111111111
111111111111111100905595216014112456735339620444667904
```

Значение сначала анализируется как Double, что приводит к потере точности в более высоких диапазонах.
Чтобы избежать этой проблемы, введите значения в виде строк, а затем преобразуйте их:

```
PS> [bigint]'111111111111111111111111111111111111111111111111111111'
111111111111111111111111111111111111111111111111111111
```

## <a name="examples"></a>Примеры

Следующая таблица содержит несколько примеров числовых литералов и перечисляет их тип и значение.

|  Число  |  Type   |    Значение     |
| -------: | ------- | -----------: |
|      100 | Int32   |          100 |
|     100D | Decimal |          100 |
|     100l | Int64   |          100 |
|    100uL | UInt64  |          100 |
|    100us | UInt16  |          100 |
|    100uy | Byte    |          100 |
|     100y | SByte   |          100 |
|      1e2 | Double  |          100 |
|     1. E2 | Double  |          100 |
|    0x1e2 | Int32   |          482 |
|   0x1e2L | Int64   |          482 |
|   0x1e2D | Int32   |         7725 |
|     482D | Decimal |          482 |
|    482gb | Int64   | 517543559168 |
| 0x1e2lgb | Int64   | 517543559168 |

### <a name="commands-that-look-like-numeric-literals"></a>Команды, которые выглядят как числовые литералы

Любая команда, похожая на числовой литерал, должна выполняться с помощью оператора Call ( `&` ), в противном случае он интерпретируется как число связанного типа.

### <a name="access-properties-and-methods-of-numeric-objects"></a>Доступ к свойствам и методам числовых объектов

Для доступа к элементу числового литерала бывают случаи, когда необходимо заключить литерал в круглые скобки.

- Литерал не имеет десятичной запятой
- Литерал не содержит цифр после десятичной запятой
- У литерала нет суффикса

Например, следующий пример завершается ошибкой:

```
PS> 2.GetType().Name
At line:1 char:11
+ 2.GetType().Name
+           ~
An expression was expected after '('.
+ CategoryInfo          : ParserError: (:) [], ParentContainsErrorRecordException
+ FullyQualifiedErrorId : ExpectedExpression
```

Ниже приведены примеры работы.

```
PS> 2uL.GetType().Name
UInt64
PS> 1.234.GetType().Name
Double
PS> (2).GetType().Name
Int32
```

Первые два примера работают без заключения литерального значения в круглые скобки, так как средство синтаксического анализа PowerShell может определить, где заканчивается числовой литерал, и запустить метод **GetType** .

<!-- reference links -->
[bigint]: /dotnet/api/system.numerics.biginteger
