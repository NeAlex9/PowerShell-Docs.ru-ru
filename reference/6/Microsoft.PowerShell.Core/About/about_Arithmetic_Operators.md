---
description: Описывает операторы, выполняющие арифметические действия в PowerShell.
keywords: powershell,командлет
Locale: en-US
ms.date: 10/08/2020
online version: https://docs.microsoft.com/powershell/module/microsoft.powershell.core/about/about_arithmetic_operators?view=powershell-6&WT.mc_id=ps-gethelp
schema: 2.0.0
title: about_Arithmetic_Operators
ms.openlocfilehash: c7885e31e4b5b661473d5241b6629bbe05810824
ms.sourcegitcommit: f874dc1d4236e06a3df195d179f59e0a7d9f8436
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/13/2020
ms.locfileid: "93231577"
---
# <a name="about-arithmetic-operators"></a>Об арифметических операторах

## <a name="short-description"></a>КРАТКОЕ ОПИСАНИЕ
Описывает операторы, выполняющие арифметические действия в PowerShell.

## <a name="long-description"></a>ПОДРОБНОЕ ОПИСАНИЕ

Арифметические операторы вычисляют числовые значения. Можно использовать один или несколько арифметических операторов для добавления, вычитания, умножения и деления значений, а также для вычисления остатка (остатка от деления) операции деления.

Кроме того, оператор сложения ( `+` ) и оператор умножения ( `*` ) также работают с строками, массивами и хэш-таблицами. Оператор сложения объединяет входные данные. Оператор умножения возвращает несколько копий входных данных. Можно даже смешивать типы объектов в арифметическом операторе. Метод, используемый для вычисления инструкции, определяется типом самого левого объекта в выражении.

Начиная с PowerShell 2,0, все арифметические операторы работают с 64-разрядными числами.

Начиная с PowerShell 3,0, `-shr` `-shl` для поддержки побитовых арифметических операций в PowerShell добавляются (Shift-Right) и (Shift-Left).

PowerShell поддерживает следующие арифметические операторы:

|Оператор|Описание                       |Пример                      |
|--------|----------------------------------|-----------------------------|
| +      |Добавляет целые числа; объединяет       |`6 + 2`                      |
|        |строки, массивы и хэш-таблицы. |`"file" + "name"`            |
|        |                                  |`@(1, "one") + @(2.0, "two")`|
|        |                                  |`@{"one" = 1} + @{"two" = 2}`|
| -      |Вычитает одно значение из другого  |`6 - 2`                      |
|        |value                             |                             |
| -      |Делает число отрицательным числом  |`-6`                         |
|        |                                  |`(Get-Date).AddDays(-1)`     |
| *      |Умножение чисел или копирование строк  |`6 * 2`                      |
|        |и массивов с указанным числом   |`@("!") * 4`                 |
|        |раз.                         |`"!" * 3`                    |
| /      |Производит деление двух значений.               |`6 / 2`                      |
| %      |Модуль — возвращает остаток от|`7 % 2`                      |
|        |Операция деления.             |                             |
|-Band   |Побитовое И                       |`5 -band 3`                  |
|-бнот   |Побитовое НЕ                       |`-bnot 5`                    |
|-Бор    |Побитовое ИЛИ                        |`5 -bor 0x03`                |
|-бксор   |Побитовое исключающее ИЛИ                       |`5 -bxor 3`                  |
|-Шл    |Сдвигает биты влево           |`102 -shl 2`                 |
|-SHR    |Сдвигает биты вправо          |`102 -shr 2`                 |

Битовые операторы работают только с целочисленными типами.

## <a name="operator-precedence"></a>ПРИОРИТЕТ ОПЕРАТОРОВ

PowerShell обрабатывает арифметические операторы в следующем порядке:

|Приоритет|Оператор          |Описание                            |
|----------|------------------|---------------------------------------|
|1         | `()`             |Круглые скобки                            |
|2         | `-`              |Для отрицательного числа или унарного оператора|
|3         | `*`, `/`, `%`    |Для умножения и деления        |
|4         | `+`, `-`         |Для сложения и вычитания           |
|5         | `-band`, `-bnot` |Для побитовых операций                 |
|5         | `-bor`, `-bxor`  |Для побитовых операций                 |
|5         | `-shr`, `-shl`   |Для побитовых операций                 |

PowerShell обрабатывает выражения слева направо в соответствии с правилами приоритета. В следующих примерах показан результат применения правил приоритета.

|Выражение |Результат|
|-----------|------|
|`3+6/3*4`  |`11`  |
|`3+6/(3*4)`|`3.5` |
|`(3+6)/3*4`|`12`  |

Порядок, в котором PowerShell вычисляет выражения, может отличаться от других используемых языков программирования и сценариев. В следующем примере показана сложная инструкция присваивания.

```powershell
$a = 0
$b = @(1,2)
$c = @(-1,-2)

$b[$a] = $c[$a++]
```

В этом примере выражение `$a++` вычисляется раньше `$b[$a]` .
Вычисление `$a++` изменяет значение `$a` после его использования в операторе `$c[$a++]` , но до того, как оно будет использовано в `$b[$a]` . Переменная `$a` в `$b[$a]` равно, а `1` не `0` ; поэтому оператор присваивает значение `$b[1]` , а не `$b[0]` .

Приведенный выше код эквивалентен:

```powershell
$a = 0
$b = @(1,2)
$c = @(-1,-2)

$tmp = $c[$a]
$a = $a + 1
$b[$a] = $tmp
```

## <a name="division-and-rounding"></a>ДЕЛЕНИЕ И ОКРУГЛЕНИЕ

Если частная операция деления является целым числом, PowerShell Округляет значение до ближайшего целого числа. Если значение равно `.5` , оно округляет до ближайшего четного целого числа.

В следующем примере показан результат округления до ближайшего четного целого числа.

|Выражение      |Результат|
|----------------|------|
|`[int]( 5 / 2 )`|`2`   |
|`[int]( 7 / 2 )`|`4`   |

Обратите внимание, что **_5/2_ = 2,5** округляется до **2**. Но **_7/2_ = 3,5** округляется до **4**.

Можно использовать класс, `[Math]` чтобы получить разное поведение округления.

|                          Выражение                          | Результат |
| ------------------------------------------------------------ | ------ |
| `[int][Math]::Round(5 / 2,[MidpointRounding]::AwayFromZero)` | `3`    |
| `[int][Math]::Ceiling(5 / 2)`                                | `3`    |
| `[int][Math]::Floor(5 / 2)`                                  | `2`    |

Дополнительные сведения см. в описании метода [Math. Round](/dotnet/api/system.math.round) .

## <a name="adding-and-multiplying-non-numeric-types"></a>ДОБАВЛЕНИЕ И УМНОЖЕНИЕ НЕЧИСЛОВЫХ ТИПОВ

Можно добавлять числа, строки, массивы и хэш-таблицы. И можно умножить числа, строки и массивы. Однако нельзя умножить хэш-таблицы.

При добавлении строк, массивов или хэш-таблиц элементы объединяются. При сцеплении коллекций, таких как массивы или хэш-таблицы, создается новый объект, содержащий объекты из обеих коллекций. При попытке объединить хэш-таблицы с одним и тем же ключом операция завершается ошибкой.

Например, следующие команды создают два массива, а затем добавляют их:

```powershell
$a = 1,2,3
$b = "A","B","C"
$a + $b
```

```output
1
2
3
A
B
C
```

Также можно выполнять арифметические операции с объектами различных типов.
Операция, выполняемая PowerShell, определяется Microsoft .NET типом платформы самого левого объекта в операции. PowerShell пытается преобразовать все объекты в операции в тип .NET Framework первого объекта. Если при преобразовании объектов он будет выполнен, он выполняет операцию, соответствующую типу .NET Framework первого объекта. Если не удается преобразовать ни один из объектов, операция завершается ошибкой.

В следующих примерах демонстрируется использование операторов сложения и умножения. в операциях, включающих различные типы объектов. Предположим `$array = 1,2,3` :

|Выражение       |Результат                 |
|-----------------|-----------------------|
|`"file" + 16`    |`file16`               |
|`$array + 16`    |`1`,`2`,`3`,`16`       |
|`$array + "file"`|`1`,`2`,`3`,`file`     |
|`$array * 2`     |`1`,`2`,`3`,`1`,`2`,`3`|
|`"file" * 3`     |`filefilefile`         |

Поскольку метод, используемый для вычисления инструкций, определяется крайним левым объектом, Добавление и умножение в PowerShell не строго коммутативной. Например, не `(a + b)` всегда равно и не `(b + a)` `(ab)` всегда равно `(ba)` .

Этот принцип демонстрируется в следующих примерах:

|Выражение   |Результат                                               |
|-------------|-----------------------------------------------------|
|`"file" + 16`|`file16`                                             |
|`16 + "file"`|`Cannot convert value "file" to type "System.Int32".`|
|             |`Error: "Input string was not in a correct format."` |
|             |`At line:1 char:1`                                   |
|             |+ 16 + "файл"                                       |

Хэш-таблицы являются слегка отличающимися регистром. Можно добавить хэш-таблицы в другую хэш-таблицу при условии, что в добавленных хэш-таблицах нет повторяющихся ключей.

В следующем примере показано, как добавить хэш-таблицы друг в друга.

```powershell
$hash1 = @{a=1; b=2; c=3}
$hash2 = @{c1="Server01"; c2="Server02"}
$hash1 + $hash2
```

```output
Name                           Value
----                           -----
c2                             Server02
a                              1
b                              2
c1                             Server01
c                              3
```

В следующем примере возникает ошибка, так как один из ключей дублируется в обеих хэш-таблицах.

```powershell
$hash1 = @{a=1; b=2; c=3}
$hash2 = @{c1="Server01"; c="Server02"}
$hash1 + $hash2
```

```output
Item has already been added. Key in dictionary: 'c'  Key being added: 'c'
At line:3 char:1
+ $hash1 + $hash2
+ ~~~~~~~~~~~~~~~
    + CategoryInfo          : OperationStopped: (:) [], ArgumentException
    + FullyQualifiedErrorId : System.ArgumentException
```

Кроме того, можно добавить хэш-таблицу в массив. и вся хэш-таблица преобразуется в элемент массива.

```powershell
$array1 = @(0, "Hello World", [datetime]::Now)
$hash1 = @{a=1; b=2}
$array2 = $array1 + $hash1
$array2
```

```output
0
Hello World

Monday, June 12, 2017 3:05:46 PM

Key   : a
Value : 1
Name  : a

Key   : b
Value : 2
Name  : b
```

Однако в хэш-таблицу нельзя добавить любой другой тип.

```powershell
$hash1 + 2
```

```output
A hash table can only be added to another hash table.
At line:3 char:1
+ $hash1 + 2
```

Хотя операторы сложения очень полезны, используйте операторы присваивания для добавления элементов в хэш-таблицы и массивы. Дополнительные сведения см. в разделе [about_assignment_operators](about_Assignment_Operators.md). В следующих примерах для `+=` добавления элементов в массив используется оператор присваивания:

```powershell
$array = @()
(0..9).foreach{ $array += $_ }
$array
```

```output
0
1
2
```

## <a name="type-conversion-to-accommodate-result"></a>ПРЕОБРАЗОВАНИЕ ТИПОВ В СООТВЕТСТВИИ С РЕЗУЛЬТАТОМ

PowerShell автоматически выбирает .NET Framework числовой тип, который наилучшим образом выражает результат без потери точности. Пример:

```powershell
2 + 3.1

(2). GetType().FullName
(2 + 3.1).GetType().FullName
```

```output
5.1
System.Int32
System.Double
```

Если результат операции слишком велик для типа, тип результата расширяется в соответствии с результатом, как показано в следующем примере:

```powershell
(512MB).GetType().FullName
(512MB * 512MB).GetType().FullName
```

```output
System.Int32
System.Double
```

Тип результата не обязательно будет таким же, как и один из операндов. В следующем примере отрицательное значение не может быть приведено к целому числу без знака, а целое число без знака слишком велико для приведения к `Int32` :

```powershell
([int32]::minvalue + [uint32]::maxvalue).gettype().fullname
```

```output
System.Int64
```

В этом примере `Int64` может соответствовать обоим типам.

`System.Decimal`Тип является исключением. Если любой из операндов имеет десятичный тип, результат будет иметь тип Decimal. Если результат слишком велик для типа Decimal, он не будет приведен к типу Double. Вместо этого возникает ошибка.

|Выражение               |Результат                                         |
|-------------------------|-----------------------------------------------|
|`[Decimal]::maxvalue`    |`79228162514264337593543950335`                |
|`[Decimal]::maxvalue + 1`|`Value was either too large or too small for a`|
|                         |`Decimal.`                                     |

## <a name="arithmetic-operators-and-variables"></a>АРИФМЕТИЧЕСКИЕ ОПЕРАТОРЫ И ПЕРЕМЕННЫЕ

Кроме того, арифметические операторы можно использовать с переменными. Операторы действуют на значения переменных. В следующих примерах демонстрируется использование арифметических операторов с переменными:

| Выражение                                    |Результат      |
|-----------------------------------------------|------------|
|`$intA = 6`<br/>`$intB = 4`<br/>`$intA + $intB`|`10`        |
|`$a = "Power"`<br/>`$b = "Shell"`<br/>`$a + $b`|`PowerShell`|

## <a name="arithmetic-operators-and-commands"></a>АРИФМЕТИЧЕСКИЕ ОПЕРАТОРЫ И КОМАНДЫ

Обычно арифметические операторы используются в выражениях с числами, строками и массивами. Однако арифметические операторы также можно использовать с объектами, возвращаемыми командами, и со свойствами этих объектов.

В следующих примерах показано, как использовать арифметические операторы в выражениях с командами PowerShell:

```powershell
(get-date) + (new-timespan -day 1)
```

Оператор скобки вызывает принудительное вычисление `get-date` командлета и вычисление `new-timespan -day 1` выражения командлета в указанном порядке. Затем оба результата добавляются с помощью `+` оператора.

```powershell
Get-Process | Where-Object { ($_.ws * 2) -gt 50mb }
```

```output
Handles  NPM(K)    PM(K)      WS(K) VM(M)   CPU(s)     Id ProcessName
-------  ------    -----      ----- -----   ------     -- -----------
   1896      39    50968      30620   264 1,572.55   1104 explorer
  12802      78   188468      81032   753 3,676.39   5676 OUTLOOK
    660       9    36168      26956   143    12.20    988 PowerShell
    561      14     6592      28144   110 1,010.09    496 services
   3476      80    34664      26092   234 ...45.69    876 svchost
    967      30    58804      59496   416   930.97   2508 WINWORD
```

В приведенном выше выражении каждое рабочее пространство процесса ( `$_.ws` ) умножается на `2` ; и результат сравнивается с, `50mb` чтобы узнать, больше ли оно.

## <a name="bitwise-operators"></a>Побитовые операторы

PowerShell поддерживает стандартные битовые операторы, включая битовые и ( `-bAnd` ), включающие и исключающие побитовые ОПЕРАТОРЫ or ( `-bOr` и `-bXor` ), а также побитовое не ( `-bNot` ).

Начиная с PowerShell 2,0, все битовые операторы работают с 64-разрядными целыми числами.

Начиная с PowerShell 3,0, `-shr` `-shl` для поддержки побитовых арифметических операций в PowerShell появились (Shift-Right) и (Shift-Left).

PowerShell поддерживает следующие Побитовые операторы.

| Оператор | Описание            | Выражение   | Результат |
| -------- | ---------------------- | ------------ | ------ |
| `-band`  | Побитовое И            | `10 -band 3` | 2      |
| `-bor`   | Побитовое или (включительно) | `10 -bor 3`  | 11     |
| `-bxor`  | Побитовое или (Эксклюзивное) | `10 -bxor 3` | 9      |
| `-bnot`  | Побитовое НЕ            | `-bNot 10`   | -11    |
| `-shl`   | Сдвиг влево             | `102 -shl 2` | 408    |
| `-shr`   | Shift справа            | `102 -shr 1` | 51     |

Битовые операторы работают с двоичным форматом значения. Например, битовая структура для числа 10 — 00001010 (на основе 1 байта), а битовая структура для числа 3 — 00000011. При использовании побитового оператора для сравнения 10 и 3 отдельные биты в каждом байте сравниваются.

В побитовой операции AND полученный бит устанавливается в значение 1 только в том случае, если оба входных бита равны 1.

```
1010      (10)
0011      ( 3)
--------------  bAND
0010      ( 2)
```

При выполнении операции побитового или (включительно) полученный бит устанавливается в значение 1, если один или оба входных бита равны 1. Полученный бит имеет значение 0, только если оба входных бита имеют значение 0.

```
1010      (10)
0011      ( 3)
--------------  bOR (inclusive)
1011      (11)
```

В побитовой операции или (исключающей) полученный бит устанавливается в значение 1 только в том случае, если один входной бит равен 1.

```
1010      (10)
0011      ( 3)
--------------  bXOR (exclusive)
1001      ( 9)
```

Оператор побитового не является унарным оператором, который создает двоичный дополнение к значению. Бит 1 имеет значение 0, а бит 0 имеет значение 1.

Например, дополняющий двоичный код 0 равен-1, максимальное целое число без знака (0xFFFFFFFF) и двоичное дополнение-1 — 0.

```powershell
-bNot 10
```

```Output
-11
```

```
0000 0000 0000 1010  (10)
------------------------- bNOT
1111 1111 1111 0101  (-11, xfffffff5)
```

В операции побитового сдвига влево все биты перемещаются слева, где n — это значение правого операнда. В место размещения вставляется ноль.

Если левый операнд является целочисленным (32-разрядным) значением, младшие 5 разрядов правого операнда определяют, сколько битов левого операнда смещается.

Если левый операнд является длинным (64-битным) значением, младшие 6 разрядов правого операнда определяют, сколько битов левого операнда смещается.

|Выражение |Результат|Двоичный результат|
|-----------|------|-------------|
|`21 -shl 0`|21    |0001 0101    |
|`21 -shl 1`|42    |0010 1010    |
|`21 -shl 2`|84    |0101 0100    |

В операции побитового сдвига вправо все биты перемещаются справа, где "n" указывается правым операндом. Оператор сдвига вправо (-SHR) вставляет ноль в крайнее левое место при перемещении положительного или неподписанного значения вправо.

Если левый операнд является целочисленным (32-разрядным) значением, младшие 5 разрядов правого операнда определяют, сколько битов левого операнда смещается.

Если левый операнд является длинным (64-битным) значением, младшие 6 разрядов правого операнда определяют, сколько битов левого операнда смещается.

|Выражение              |Результат      |Двоичные данные     |Hex         |
|------------------------|------------|-----------|------------|
|`21 -shr 0`             | 21         | 0001 0101 | 0x15       |
|`21 -shr 1`             | 10         | 0000 1010 | 0x0A       |
|`21 -shr 2`             | 5          | 0000 0101 | 0x05       |
|`21 -shr 31`            | 0          | 0000 0000 | 0x00       |
|`21 -shr 32`            | 21         | 0001 0101 | 0x15       |
|`21 -shr 64`            | 21         | 0001 0101 | 0x15       |
|`21 -shr 65`            | 10         | 0000 1010 | 0x0A       |
|`21 -shr 66`            | 5          | 0000 0101 | 0x05       |
|`[int]::MaxValue -shr 1`| 1073741823 |           | 0x3FFFFFFF |
|`[int]::MinValue -shr 1`| — 1073741824|           | 0xC0000000 |
|`-1 -shr 1`             | -1         |           | 0xFFFFFFFF |

## <a name="see-also"></a>СМ. ТАКЖЕ

- [about_arrays](about_Arrays.md)
- [about_assignment_operators](about_Assignment_Operators.md)
- [about_comparison_operators](about_Comparison_Operators.md)
- [about_hash_tables](about_Hash_Tables.md)
- [about_operators](about_Operators.md)
- [about_variables](about_Variables.md)
- [Get-Дата](xref:Microsoft.PowerShell.Utility.Get-Date)
- [New-TimeSpan](xref:Microsoft.PowerShell.Utility.New-TimeSpan)
