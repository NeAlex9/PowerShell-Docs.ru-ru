---
description: Предоставляет сведения о заданиях, основанных на потоках PowerShell. Задание потока — это тип фонового задания, выполняющего команду или выражение в отдельном потоке в рамках текущего процесса сеанса.
keywords: powershell,командлет
Locale: en-US
ms.date: 10/16/2020
online version: 1.0.0
schema: 2.0.0
title: about_Thread_Jobs
ms.openlocfilehash: 4951ac2c14c0685fbf2ead16bc52c64096231260
ms.sourcegitcommit: 108686b166672cc08817c637dd93eb1ad830511d
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/17/2020
ms.locfileid: "93232962"
---
# <a name="about-thread-jobs"></a>О заданиях потоков

## <a name="short-description"></a>Краткое описание

Предоставляет сведения о заданиях, основанных на потоках PowerShell. Задание потока — это тип фонового задания, выполняющего команду или выражение в отдельном потоке в рамках текущего процесса сеанса.

## <a name="long-description"></a>Подробное описание

В этой статье объясняется, как выполнять задания потоков в PowerShell на локальном компьютере.
Сведения о выполнении фоновых заданий на локальном компьютере см. в разделе [about_Jobs](about_Jobs.md).

Запустите задание потока с помощью `Start-ThreadJob` командлета. Этот командлет доступен в модуле **среаджоб** , который поставляется с PowerShell.
`Start-ThreadJob` Возвращает один объект задания, который инкапсулирует выполняющуюся команду или скрипт, и может использоваться со всеми командлетами задания PowerShell.

## <a name="the-job-cmdlets"></a>Командлеты задания

|Командлет           |Описание                                            |
|-----------------|-------------------------------------------------------|
|`Start-ThreadJob`|Запускает задание потока на локальном компьютере.               |
|`Get-Job`        |Возвращает задания, запущенные в текущем сеансе.|
|`Receive-Job`    |Возвращает результаты заданий.                              |
|`Stop-Job`       |Останавливает выполняющееся задание.                                   |
|`Wait-Job`       |Подавляет командную строку до тех пор, пока одно или все задания не будут|
|                 |завершения.                                              |
|`Remove-Job`     |Удаляет задание.                                         |

## <a name="how-to-start-a-thread-job-on-the-local-computer"></a>Запуск задания потока на локальном компьютере

Чтобы запустить задание потока на локальном компьютере, используйте `Start-ThreadJob` командлет.

Чтобы написать `Start-ThreadJob` команду, заключите команду или скрипт, выполняемые заданием, в фигурные скобки ( `{ }` ).

Следующая команда запускает задание потока, которое выполняет `Get-Process` команду на локальном компьютере.

```powershell
Start-ThreadJob -ScriptBlock { Get-Process }
```

`Start-ThreadJob`Команда возвращает `ThreadJob` объект, представляющий выполняемое задание. Объект задания содержит полезные сведения о задании, включая текущее состояние выполнения. Он собирает результаты выполнения задания по мере формирования результатов.

## <a name="how-to-wait-for-a-job-to-complete-and-retrieve-job-results"></a>Как дождаться завершения задания и получить результаты задания

Вы можете использовать командлеты задания PowerShell, такие как `Wait-Job` и, `Receive-Job` чтобы дождаться завершения задания, а затем вернуть все результаты, созданные заданием.

Следующая команда запускает задание потока, которое выполняет `Get-Process` команду, затем ожидает завершения команды и возвращает все результаты данных, созданные командой.

```powershell
Start-ThreadJob -ScriptBlock { Get-Process } | Wait-Job | Receive-Job
```

## <a name="powershell-concurrency-and-jobs"></a>Параллелизм и задания PowerShell

PowerShell параллельно выполняет команды и скрипты с помощью заданий. Существует три решения на основе заданий, предоставляемые PowerShell для поддержки параллелизма.

|Задание            |Описание                                                  |
|---------------|-------------------------------------------------------------|
|`RemoteJob`    |Команда и сценарий выполняются на удаленном компьютере.                 |
|`BackgroundJob`|Команда и сценарий выполняются в отдельном процессе в локальной системе    |
|               |машине.                                                     |
|`ThreadJob`    |Команда и сценарий выполняются в отдельном потоке в том же  |
|               |процесс на локальном компьютере.                                |

Каждый тип задания имеет свои преимущества и недостатки. Удаленное выполнение сценария на отдельном компьютере или в отдельном процессе имеет большую изоляцию. Любые ошибки не влияют на другие выполняющиеся задания или на клиент, запустивший задание. Но на уровне удаленного взаимодействия добавляются дополнительные издержки, включая сериализацию объектов. Все объекты, передаваемые в удаленный сеанс и из него, должны быть сериализованы и десериализованы при передаче между клиентом и целевым сеансом. Операция сериализации может использовать много ресурсов вычислений и памяти для больших сложных объектов данных.

## <a name="powershell-thread-based-jobs"></a>Задания на основе потока PowerShell

Задания на основе потоков не так надежны, как удаленные и фоновые задания, так как они выполняются в одном и том же процессе в разных потоках. Если в одном задании есть критическая ошибка, которая приводит к сбою процесса, то все остальные задания в процессе также завершатся ошибкой.

Однако задания на основе потоков значительно меньше издержек. Им не нужно использовать удаленный уровень или сериализацию. В результате задания на основе потоков выполняются гораздо быстрее и используют гораздо меньшие ресурсы, чем другие типы заданий.

## <a name="thread-job-performance"></a>Производительность задания потока

Задания потоков выполняются быстрее и легче, чем другие типы заданий. Но они по-прежнему имеют накладные расходы, которые могут быть большими по сравнению с работой, выполняемой заданием.

PowerShell запускает команды и скрипты в сеансе. Только одна команда или сценарий может выполняться одновременно в сеансе. Поэтому при выполнении нескольких заданий каждое задание выполняется в отдельном сеансе. Каждый сеанс влияет на накладные расходы.

Задания потоков обеспечивают наилучшую производительность, когда работа, выполняемая ими, превышает издержки сеанса, используемого для выполнения задания. Существует два варианта соответствия этого критерия.

- Работа — это большое количество вычислительных ресурсов. выполнение скрипта для нескольких заданий потоков может использовать преимущества нескольких процессорных ядер и ускорить работу.

- Работа состоит из значительного ожидающего сценария, который тратит время на ожидание результатов ввода-вывода или удаленного вызова. Параллельное выполнение обычно завершается быстрее, чем при последовательном выполнении.

```powershell
(Measure-Command {
    1..1000 | ForEach { Start-ThreadJob { Write-Output "Hello $using:_" } } | Receive-Job -Wait
}).TotalMilliseconds
10457.962


(Measure-Command {
    1..1000 | ForEach-Object { "Hello: $_" }
}).TotalMilliseconds
24.9277
```

В первом примере показан цикл foreach, который создает задания потоков 1000, чтобы выполнить простую запись в строку. Из-за накладных расходов на задание выполнение займет более 33 секунд.

Во втором примере командлет выполняется `ForEach` для выполнения тех же операций 1000, и каждая строка записи выполняется последовательно без дополнительных издержек заданий. Она завершается всего за 25 миллисекунд.

```powershell
$logNames.count
10

Measure-Command {
    $logs = $logNames | ForEach {
        Start-ThreadJob {
            Get-WinEvent -LogName $using:_ -MaxEvents 5000 2>$null
        } -ThrottleLimit 10
    } | Wait-Job | Receive-Job
}

TotalMilliseconds : 115994.3 (1 minute 56 seconds)
$logs.Count
50000
```

В приведенном выше примере собираются до 5000 записей для 10 отдельных системных журналов. Поскольку сценарий включает чтение нескольких журналов, имеет смысл выполнять операции параллельно. И выполнение задания выполняется в два раза быстрее, как если бы сценарий выполнялся последовательно.

```powershell
Measure-Command {
    $logs = $logNames | ForEach-Object {
        Get-WinEvent -LogName $_ -MaxEvents 5000 2>$null
    }
}

TotalMilliseconds : 252398.4321 (4 minutes 12 seconds)
$logs.Count
50000
```

## <a name="thread-jobs-and-variables"></a>Задания и переменные потоков

Переменные передаются в задания потоков различными способами.

`Start-ThreadJob` может принимать переменные, передаваемые в командлет, переданные в блок скрипта через `$using` ключевое слово или передаваемые через параметр **ArgumentList** .

```powershell
$msg = "Hello"

$msg | Start-ThreadJob { $input | Write-Output } | Wait-Job | Receive-Job

Start-ThreadJob { Write-Output $using:msg } | Wait-Job | Receive-Job

Start-ThreadJob { param ([string] $message) Write-Output $message } -ArgumentList @($msg) |
  Wait-Job | Receive-Job
```

Так как задания потоков выполняются в одном процессе, любой ссылочный тип переменной, переданный в задание, должен обрабатываться аккуратно. Если он не является потокобезопасным объектом, ему никогда не следует присваивать значение, а метод и свойства никогда не должны вызываться для него.

```powershell
$threadSafeDictionary = [System.Collections.Concurrent.ConcurrentDictionary[string,object]]::new()
$jobs = Get-Process | ForEach {
    Start-ThreadJob {
        $proc = $using:_
        $dict = $using:threadSafeDictionary
        $dict.TryAdd($proc.ProcessName, $proc)
    }
}
$jobs | Wait-Job | Receive-Job

$threadSafeDictionary.Count
96

$threadSafeDictionary["pwsh"]

NPM(K)  PM(M)   WS(M) CPU(s)    Id SI ProcessName
------  -----   ----- ------    -- -- -----------
  112  108.25  124.43  69.75 16272  1 pwsh
```

В приведенном выше примере объект dotNet, являющийся потокобезопасным, передается `ConcurrentDictionary` всем дочерним заданиям для получения объектов процессов с уникальными именами. Поскольку это потокобезопасный объект, его можно безопасно использовать во время параллельного выполнения заданий в процессе.

## <a name="see-also"></a>См. также статью

- [about_Remote_Jobs](about_Remote_Jobs.md)
- [about_Thread_Jobs](about_Thread_Jobs.md)
- [about_Job_Details](about_Job_Details.md)
- [about_Remote](about_Remote.md)
- [about_PSSessions](about_PSSessions.md)
- [Start-Job](xref:Microsoft.PowerShell.Core.Start-Job)
- [Get-Job.](xref:Microsoft.PowerShell.Core.Get-Job)
- [Receive-Job.](xref:Microsoft.PowerShell.Core.Receive-Job)
- [Stop-Job.](xref:Microsoft.PowerShell.Core.Stop-Job)
- [Wait-Job](xref:Microsoft.PowerShell.Core.Wait-Job)
- [Remove-Job](xref:Microsoft.PowerShell.Core.Remove-Job)
