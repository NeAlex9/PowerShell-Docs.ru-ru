---
description: Описывает массивы, которые представляют собой структуры данных, предназначенные для хранения коллекций элементов.
keywords: powershell,командлет
Locale: en-US
ms.date: 08/26/2020
online version: https://docs.microsoft.com/powershell/module/microsoft.powershell.core/about/about_arrays?view=powershell-7&WT.mc_id=ps-gethelp
schema: 2.0.0
title: about_Arrays
ms.openlocfilehash: 2283c36d899c3ea743f6c379dc686ec583d7a36c
ms.sourcegitcommit: f874dc1d4236e06a3df195d179f59e0a7d9f8436
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/13/2020
ms.locfileid: "93231162"
---
# <a name="about-arrays"></a>О массивах

## <a name="short-description"></a>Краткое описание
Описывает массивы, которые представляют собой структуры данных, предназначенные для хранения коллекций элементов.

## <a name="long-description"></a>Полное описание

Массив — это структура данных, предназначенная для хранения коллекции элементов.
Элементы могут быть одного типа или разных типов.

Начиная с Windows PowerShell 3,0, коллекция из нуля или одного объекта имеет некоторые свойства массивов.

## <a name="creating-and-initializing-an-array"></a>Создание и инициализация массива

Чтобы создать и инициализировать массив, присвойте переменной несколько значений. Значения, хранящиеся в массиве, разделяются запятыми и отделены от имени переменной оператором присваивания ( `=` ).

Например, чтобы создать массив с именем `$A` , содержащий семь числовых значений (int), равных 22, 5, 10, 8, 12, 9 и 80, введите:

```powershell
$A = 22,5,10,8,12,9,80
```

Запятую также можно использовать для инициализации массива с одним элементом, поместив запятую перед отдельным элементом.

Например, чтобы создать один массив элементов с именем `$B` , содержащий единственное значение 7, введите:

```powershell
$B = ,7
```

Можно также создать и инициализировать массив с помощью оператора Range ( `..` ).
В следующем примере создается массив, содержащий значения от 5 до 8.

```powershell
$C = 5..8
```

В результате `$C` содержит четыре значения: 5, 6, 7 и 8.

Если тип данных не указан, PowerShell создает каждый массив как массив объектов ( **System. Object []** ). Чтобы определить тип данных массива, используйте метод **GetType ()** . Например, чтобы определить тип данных `$A` массива, введите:

```powershell
$A.GetType()
```

Чтобы создать строго типизированный массив, то есть массив, который может содержать только значения определенного типа, приведите переменную к типу массива, например **String []** , **Long []** или **Int32 []**. Для приведения массива перед именем переменной укажите тип массива, заключенный в квадратные скобки. Например, чтобы создать массив 32-разрядных целых чисел с именем `$ia` , содержащим четыре целых числа (1500, 2230, 3350 и 4000), введите:

```powershell
[int32[]]$ia = 1500,2230,3350,4000
```

В результате `$ia` массив может содержать только целые числа.

Можно создавать массивы, приводимые к любому поддерживаемому типу в Microsoft .NET Framework. Например, объекты, `Get-Process` получаемые для представления процессов, имеют тип **System. Diagnostics. Process** . Чтобы создать строго типизированный массив объектов Process, введите следующую команду:

```powershell
[Diagnostics.Process[]]$zz = Get-Process
```

## <a name="the-array-sub-expression-operator"></a>Оператор "часть выражения массива"

Оператор "вложенное выражение массива" создает массив из инструкций внутри него. Независимо от оператора внутри оператора, оператор помещает его в массив. Даже при наличии нуля или одного объекта.

Синтаксис оператора Array выглядит следующим образом:

```syntax
@( ... )
```

Оператор Array можно использовать для создания массива из нуля или одного объекта. Пример:

```powershell
$a = @("Hello World")
$a.Count
```

```Output
1
```

```powershell
$b = @()
$b.Count
```

```Output
0
```

Оператор Array полезен в сценариях при получении объектов, но неизвестно, сколько объектов вы получаете. Пример:

```powershell
$p = @(Get-Process Notepad)
```

Дополнительные сведения о операторе "часть выражения массива" см. в разделе [about_Operators](about_Operators.md).

## <a name="accessing-and-using-array-elements"></a>Доступ к элементам массива и использование

### <a name="reading-an-array"></a>Чтение массива

Можно ссылаться на массив, используя имя его переменной. Чтобы отобразить все элементы в массиве, введите имя массива. Например, предполагается, что `$a` это массив, содержащий целые числа 0, 1, 2, до 9; введите:

```powershell
$a
```

```Output
0
1
2
3
4
5
6
7
8
9
```

Можно ссылаться на элементы в массиве с помощью индекса, начиная с позиции 0. Заключите номер индекса в квадратные скобки. Например, чтобы отобразить первый элемент в `$a` массиве, введите:

```powershell
$a[0]
```

```Output
0
```

Чтобы отобразить третий элемент в `$a` массиве, введите:

```powershell
$a[2]
```

```Output
2
```

Можно извлечь часть массива с помощью оператора Range для индекса. Например, чтобы получить второй массив для пятого элемента массива, введите:

```powershell
$a[1..4]
```

```Output
1
2
3
4
```

Число отрицательных чисел от конца массива. Например, "-1" относится к последнему элементу массива. Чтобы отобразить последние три элемента массива в порядке возрастания, введите:

```powershell
$a = 0 .. 9
$a[-3..-1]
```

```Output
7
8
9
```

Если ввести отрицательные индексы в порядке убывания, выходные данные будут изменены.

```powershell
$a = 0 .. 9
$a[-1..-3]
```

```Output
9
8
7
```

Однако при использовании этой нотации будьте осторожны. Нотация выполняет цикл от конечной границы до начала массива.

```powershell
$a = 0 .. 9
$a[2..-2]
```

```Output
2
1
0
9
8
```

Кроме того, одна из распространенных ошибок состоит в том, чтобы предположить `$a[0..-2]` , что ссылается на все элементы массива, за исключением последнего. Он относится к первым, последним и вторым элементам в массиве.

Оператор «плюс» () можно использовать `+` для объединения диапазонов со списком элементов в массиве. Например, чтобы отобразить элементы с позициями индекса 0, 2 и 4 до 6, введите:

```powershell
$a = 0 .. 9
$a[0,2+4..6]
```

```Output
0
2
4
5
6
```

Кроме того, для перечисления нескольких диапазонов и отдельных элементов можно использовать оператор «плюс». Например, для перечисления элементов от 0 до 2, от 4 до шести и элемента в восьмом позиционированном типе:

```powershell
$a = 0..9
$a[+0..2+4..6+8]
```

```Output
0
1
2
4
5
6
8
```

### <a name="iterations-over-array-elements"></a>Итерации по элементам массива

Можно также использовать циклические конструкции, такие как циклы ForEach, for и while, для ссылки на элементы в массиве. Например, чтобы использовать цикл ForEach для вывода элементов в `$a` массиве, введите:

```powershell
$a = 0..9
foreach ($element in $a) {
  $element
}
```

```Output
0
1
2
3
4
5
6
7
8
9
```

Цикл foreach выполняет итерацию по массиву и возвращает каждое значение в массиве, пока не достигнет конца массива.

Цикл for полезен при увеличении счетчиков при проверке элементов в массиве. Например, чтобы использовать цикл for для возврата всех остальных значений в массиве, введите:

```powershell
$a = 0..9
for ($i = 0; $i -le ($a.length - 1); $i += 2) {
  $a[$i]
}
```

```Output
0
2
4
6
8
```

Можно использовать цикл while для вывода элементов в массиве до тех пор, пока определенное условие не станет истинным. Например, чтобы отобразить элементы в `$a` массиве, если индекс массива меньше 4, введите:

```powershell
$a = 0..9
$i=0
while($i -lt 4) {
  $a[$i];
  $i++
}
```

```Output
0
1
2
3
```

## <a name="properties-of-arrays"></a>Свойства массивов

### <a name="count-or-length-or-longlength"></a>Количество или длина или Лонгленгс

Чтобы определить, сколько элементов находится в массиве, используйте `Length` свойство или его `Count` псевдоним. `Longlength` может использоваться, если массив содержит более 2 147 483 647 элементов.

```powershell
$a = 0..9
$a.Count
$a.Length
```

```Output
10
10
```

### <a name="rank"></a>Ранг

Возвращает число измерений в массиве. Большинство массивов в PowerShell имеют только одно измерение. Даже если вы считаете, что создаете многомерный массив; как в следующем примере:

```powershell
$a = @(
  @(0,1),
  @("b", "c"),
  @(Get-Process)
)

[int]$r = $a.Rank
"`$a rank: $r"
```

```Output
$a rank: 1
```

В следующем примере показано создание действительного многомерного массива с помощью .NET Framework.

```powershell
[int[,]]$rank2 = [int[,]]::new(5,5)
$rank2.rank
```

```Output
2
```

## <a name="methods-of-arrays"></a>Методы массивов

### <a name="clear"></a>Clear

Устанавливает все значения элементов в _значение по умолчанию_ для типа элемента массива.
Метод Clear () не сбрасывает размер массива.

В следующем примере `$a` представлен массив объектов.

```powershell
$a = 1, 2, 3
$a.Clear()
$a | % { $null -eq $_ }
```

```Output
True
True
True
```

В этом примере `$intA` явным образом вводится для хранения целых чисел.

```powershell
[int[]] $intA = 1, 2, 3
$intA.Clear()
$intA
```

```Output
0
0
0
```

### <a name="foreach"></a>ForEach

Позволяет перебирать все элементы в массиве и выполнять заданную операцию для каждого элемента массива.

Метод ForEach имеет несколько перегрузок, выполняющих различные операции.

```
ForEach(scriptblock expression)
ForEach(scriptblock expression, object[] arguments)
ForEach(type convertToType)
ForEach(string propertyName)
ForEach(string propertyName, object[] newValue)
ForEach(string methodName)
ForEach(string methodName, object[] arguments)
```

#### <a name="foreachscriptblock-expression"></a>ForEach (выражение ScriptBlock)

#### <a name="foreachscriptblock-expression-object-arguments"></a>ForEach (выражение ScriptBlock, аргументы объекта [])

Этот метод был добавлен в PowerShell v4.

> [!NOTE]
> Синтаксис требует использования блока скрипта. Круглые скобки необязательны, если блок ScriptBlock является единственным параметром. Кроме того, не должно быть пробелов между методом и открывающей круглой скобкой или фигурной скобкой.

В следующем примере показано, как использовать метод ForEach. В этом случае целью является создание квадратного значения элементов в массиве.

```powershell
$a = @(0 .. 3)
$a.ForEach({ $_ * $_})
```

```Output
0
1
4
9
```

Как и `-ArgumentList` параметр параметра `ForEach-Object` , `arguments` параметр позволяет передавать массив аргументов в блок сценария, настроенный для их принятия.

Дополнительные сведения о поведении **ArgumentList** см. в разделе [about_Splatting](about_Splatting.md#splatting-with-arrays).

#### <a name="foreachtype-converttotype"></a>ForEach (тип Конверттотипе)

`ForEach`Метод можно использовать для приведения элементов к другому типу. в следующем примере показано, как преобразовать список строковых дат в `[DateTime]` тип.

```powershell
@("1/1/2017", "2/1/2017", "3/1/2017").ForEach([datetime])
```

```Output

Sunday, January 1, 2017 12:00:00 AM
Wednesday, February 1, 2017 12:00:00 AM
Wednesday, March 1, 2017 12:00:00 AM
```

#### <a name="foreachstring-propertyname"></a>ForEach (строка propertyName)

#### <a name="foreachstring-propertyname-object-newvalue"></a>ForEach (строка propertyName, объект [] newValue)

`ForEach`Метод также можно использовать для быстрого получения или установки значений свойств для каждого элемента в коллекции.

```powershell
# Set all LastAccessTime properties of files to the current date.
(dir 'C:\Temp').ForEach('LastAccessTime', (Get-Date))
# View the newly set LastAccessTime of all items, and find Unique entries.
(dir 'C:\Temp').ForEach('LastAccessTime') | Get-Unique
```

```Output
Wednesday, June 20, 2018 9:21:57 AM
```

#### <a name="foreachstring-methodname"></a>ForEach (String methodName)

#### <a name="foreachstring-methodname-object-arguments"></a>ForEach (String имя_метода, Object [] аргументы)

Наконец, `ForEach` методы можно использовать для выполнения метода для каждого элемента в коллекции.

```powershell
("one", "two", "three").ForEach("ToUpper")
```

```Output
ONE
TWO
THREE
```

Как и `-ArgumentList` параметр параметра `ForEach-Object` , `arguments` параметр позволяет передавать массив аргументов в блок сценария, настроенный для их принятия.

> [!NOTE]
> Начиная с Windows PowerShell 3,0. получение свойств и исполнение методов для каждого элемента коллекции также можно выполнить с помощью "методов скалярных объектов и коллекций". Дополнительные сведения об этом можно узнать здесь [about_methods](about_methods.md).

### <a name="where"></a>Where

Позволяет фильтровать или выбирать элементы массива. Скрипт должен иметь значение, отличное от: ноль (0), пустая строка `$false` или, `$null` чтобы элемент отображался после элемента `Where`

Существует одно определение для `Where` метода.

```
Where(scriptblock expression[, WhereOperatorSelectionMode mode
                            [, int numberToReturn]])
```

> [!NOTE]
> Синтаксис требует использования блока скрипта. Круглые скобки необязательны, если блок ScriptBlock является единственным параметром. Кроме того, не должно быть пробелов между методом и открывающей круглой скобкой или фигурной скобкой.

`Expression`Для фильтрации необходим блок ScriptBlock, `mode` необязательный аргумент позволяет выбрать дополнительные возможности выбора, а `numberToReturn` необязательный аргумент позволяет ограничить количество элементов, возвращаемых фильтром.

Допустимые значения для `mode` :

- По умолчанию (0) — возврат всех элементов
- First (1) — возврат первого элемента
- Last (2) — Возврат последнего элемента
- SkipUntil (3) — пропустить элементы до тех пор, пока условие не будет равно true, возвращает оставшиеся элементы.
- До (4) — возврат всех элементов до истинного условия
- Split (5) — Возврат массива из двух элементов
  - Первый элемент содержит совпадающие элементы
  - Второй элемент содержит оставшиеся элементы

В следующем примере показано, как выбрать все нечетные числа из массива.

```powershell
(0..9).Where{ $_ % 2 }
```

```Output
1
3
5
7
9
```

В этом примере показано, как выбрать непустые строки.

```powershell
('hi', '', 'there').Where({$_.Length})
```

```Output
hi
there
```

#### <a name="default"></a>По умолчанию

`Default`Режим фильтрует элементы с помощью `Expression` ScriptBlock.

Если `numberToReturn` предоставлено значение, оно указывает максимальное число возвращаемых элементов.

```powershell
# Get the zip files in the current users profile, sorted by LastAccessTime.
$Zips = dir $env:userprofile -Recurse '*.zip' | Sort-Object LastAccessTime
# Get the least accessed file over 100MB
$Zips.Where({$_.Length -gt 100MB}, 'Default', 1)
```

> [!NOTE]
> `Default`Режим и `First` режим возвращают первые `numberToReturn` элементы () и могут использоваться взаимозаменяемыми.

#### <a name="last"></a>Последний

```powershell
$h = (Get-Date).AddHours(-1)
$logs = dir 'C:\' -Recurse '*.log' | Sort-Object CreationTime
# Find the last 5 log files created in the past hour.
$logs.Where({$_.CreationTime -gt $h}, 'Last', 5)
```

#### <a name="skipuntil"></a>SkipUntil

`SkipUntil`Режим пропускает все объекты в коллекции до тех пор, пока объект не передаст фильтр выражений блока скрипта. Затем он возвращает **все** остальные элементы сбора, не проверяя их. _Тестируется только один передающий элемент_.

Это означает, что возвращаемая коллекция содержит как _передающие_ , так и _непройденные_ элементы, которые не были проверены.

Количество возвращаемых элементов может быть ограничено путем передачи значения в `numberToReturn` аргумент.

```powershell
$computers = "Server01", "Server02", "Server03", "localhost", "Server04"
# Find the first available online server.
$computers.Where({ Test-Connection $_ }, 'SkipUntil', 1)
```

```Output
localhost
```

#### <a name="until"></a>Вплот

`Until`Режим инвертирует `SkipUntil` режим.  Он возвращает **все** элементы в коллекции, пока элемент не передаст выражение блока скрипта. Когда элемент _передает_ выражение ScriptBlock, `Where` метод останавливает обработку элементов.

Это означает, что вы получаете первый набор _непередающих_ элементов из `Where` метода. _После_ передачи одного элемента остальные не проверяются и не возвращаются.

Количество возвращаемых элементов может быть ограничено путем передачи значения в `numberToReturn` аргумент.

```powershell
# Retrieve the first set of numbers less than or equal to 10.
(1..50).Where({$_ -gt 10}, 'Until')
# This would perform the same operation.
(1..50).Where({$_ -le 10})
```

```Output
1
2
3
4
5
6
7
8
9
10
```

> [!NOTE]
> `Until`И, и `SkipUntil` работают не в ходе тестирования пакета элементов.
>
> `Until` Возвращает элементы **перед** первым _прохождением_.
>
> `SkipUntil` Возвращает все элементы **после** первого _прохода_ , включая первый передающий элемент.

#### <a name="split"></a>Разделение

`Split`Режим разделяет или группирует элементы коллекции в две отдельные коллекции. Те, которые передают выражение ScriptBlock, и те, которые не имеют.

Если `numberToReturn` указан параметр, то первая коллекция содержит _передаваемые_ элементы, а не превысить указанное значение.

Остальные объекты, даже те, которые **передают** фильтр выражения, возвращаются во второй коллекции.

```powershell
$running, $stopped = (Get-Service).Where({$_.Status -eq 'Running'}, 'Split')
$running
```

```Output
Status   Name               DisplayName
------   ----               -----------
Running  Appinfo            Application Information
Running  AudioEndpointBu... Windows Audio Endpoint Builder
Running  Audiosrv           Windows Audio
...
```

```powershell
$stopped
```

```Output
Status   Name               DisplayName
------   ----               -----------
Stopped  AJRouter           AllJoyn Router Service
Stopped  ALG                Application Layer Gateway Service
Stopped  AppIDSvc           Application Identity
...
```

## <a name="get-the-members-of-an-array"></a>Получение элементов массива

Чтобы получить свойства и методы массива, такие как свойство Length и метод **SetValue** , используйте параметр **InputObject** `Get-Member` командлета.

При передаче массива в `Get-Member` оболочка PowerShell отправляет элементы по одной за раз и `Get-Member` возвращает тип каждого элемента в массиве (игнорируя дубликаты).

При использовании параметра **InputObject** `Get-Member` возвращает элементы массива.

Например, следующая команда возвращает элементы `$a` переменной массива.

```powershell
Get-Member -InputObject $a
```

Кроме того, элементы массива можно получить, введя запятую (,) перед значением, перенаправленным в `Get-Member` командлет. Запятая делает массив вторым элементом массива массивов. PowerShell передает массивы по одному за раз и `Get-Member` возвращает элементы массива. Как и в следующих двух примерах.

```powershell
,$a | Get-Member

,(1,2,3) | Get-Member
```

## <a name="manipulating-an-array"></a>Управление массивом

Можно изменить элементы в массиве, добавить элемент в массив и объединить значения из двух массивов в третий массив.

Чтобы изменить значение определенного элемента в массиве, укажите имя массива и индекс элемента, который требуется изменить, а затем используйте оператор присваивания ( `=` ), чтобы указать новое значение для элемента. Например, чтобы изменить значение второго элемента в `$a` массиве (позиция с индексом 1) на 10, введите:

```powershell
$a[1] = 10
```

Для изменения значения можно также использовать метод **SetValue** массива. Следующий пример изменяет второе значение (позиция индекса 1) `$a` массива на 500:

```powershell
$a.SetValue(500,1)
```

Оператор можно использовать `+=` для добавления элемента в массив. В следующем примере показано, как добавить элемент в `$a` массив.

```powershell
$a = @(0..4)
$a += 5
```

> [!NOTE]
> При использовании `+=` оператора PowerShell фактически создает новый массив со значениями исходного массива и добавленного значения. Это может вызвать проблемы с производительностью, если операция повторяется несколько раз или размер массива слишком велик.

Удалять элементы из массива несложно, но можно создать новый массив, содержащий только выбранные элементы существующего массива. Например, чтобы создать `$t` массив со всеми элементами в `$a` массиве, за исключением значения в позиции 2 индекса, введите:

```powershell
$t = $a[0,1 + 3..($a.length - 1)]
```

Чтобы объединить два массива в один, используйте оператор «плюс» ( `+` ). Следующий пример создает два массива, объединяет их, а затем отображает полученный объединенный массив.

```powershell
$x = 1,3
$y = 5,9
$z = $x + $y
```

В результате `$z` массив содержит 1, 3, 5 и 9.

Чтобы удалить массив, присвойте значение `$null` массиву. Следующая команда удаляет массив в `$a` переменной.

`$a = $null`

Можно также использовать `Remove-Item` командлет, но присваивание значения `$null` выполняется быстрее, особенно для больших массивов.

## <a name="arrays-of-zero-or-one"></a>Массивы 0 или 1

Начиная с Windows PowerShell 3,0, коллекция с нулевым или одним объектом имеет свойство Count и length. Кроме того, можно индексировать в массив одного объекта. Эта функция позволяет избежать ошибок скрипта, происходящих, когда команда, ожидающую сбор, получает менее двух элементов.

Эта функция демонстрируется в следующих примерах.

### <a name="zero-objects"></a>Нуль объектов

```powershell
$a = $null
$a.Count
$a.Length
```

```Output
0
0
```

### <a name="one-object"></a>Один объект

```powershell
$a = 4
$a.Count
$a.Length
$a[0]
$a[-1]
```

```Output
1
1
4
4
```

## <a name="indexing-support-for-systemtuple-objects"></a>Поддержка индексирования для объектов System. Tuple

В PowerShell 6,1 добавлена поддержка индексированного доступа к объектам **кортежей** , аналогичная массивам.
Пример:

```powershell
PS> $tuple = [Tuple]::Create(1, 'test')
PS> $tuple[0]
1
PS> $tuple[1]
test
PS> $tuple[0..1]
1
test
PS> $tuple[-1]
test
```

В отличие от массивов и других объектов коллекции, объекты **кортежей** обрабатываются как один объект при передаче через конвейер или с помощью параметров, поддерживающих массивы объектов.

Дополнительные сведения см. в разделе [System. Tuple](/dotnet/api/system.tuple).

## <a name="see-also"></a>См. также статью

- [about_Assignment_Operators](about_Assignment_Operators.md)
- [about_Hash_Tables](about_Hash_Tables.md)
- [about_Operators](about_Operators.md)
- [about_For](about_For.md)
- [about_Foreach](about_Foreach.md)
- [about_While](about_While.md)
