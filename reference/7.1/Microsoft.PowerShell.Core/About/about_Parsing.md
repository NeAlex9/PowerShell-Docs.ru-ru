---
description: Описывает, как PowerShell выполняет синтаксический анализ команд.
keywords: powershell,командлет
Locale: en-US
ms.date: 09/14/2020
online version: https://docs.microsoft.com/powershell/module/microsoft.powershell.core/about/about_parsing?view=powershell-7.1&WT.mc_id=ps-gethelp
schema: 2.0.0
title: about_Parsing
ms.openlocfilehash: 7f68a1f29ecb6a4562ae9f9a024365a2b1744a79
ms.sourcegitcommit: f874dc1d4236e06a3df195d179f59e0a7d9f8436
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/13/2020
ms.locfileid: "93231838"
---
# <a name="about-parsing"></a>Сведения о синтаксическом анализе

## <a name="short-description"></a>КРАТКОЕ ОПИСАНИЕ
Описывает, как PowerShell выполняет синтаксический анализ команд.

## <a name="long-description"></a>ПОДРОБНОЕ ОПИСАНИЕ

При вводе команды в командной строке PowerShell разбивает текст команды на ряд сегментов, называемых _токенами_ , а затем определяет способ интерпретации каждого маркера.

Например, если ввести:

```powershell
Write-Host book
```

PowerShell разбивает команду на два токена, и `Write-Host` `book` и интерпретирует каждый маркер независимо друг от друга, используя один из двух основных режимов анализа: режим выражения и режим аргументов.

> [!NOTE]
> Так как PowerShell анализирует ввод команды, он пытается разрешить имена команд в командлеты или собственные исполняемые файлы. Если имя команды не имеет точного совпадения, PowerShell добавляется `Get-` к команде в качестве глагола по умолчанию. Например, PowerShell анализируется `Process` как `Get-Process` . Не рекомендуется использовать эту функцию по следующим причинам.
>
> - Это неэффективно. В результате PowerShell будет выполнять поиск несколько раз.
> - Внешние программы с тем же именем разрешаются первыми, поэтому вы не можете выполнить предполагаемый командлет.
> - `Get-Help` и `Get-Command` не распознают имена без команд.

### <a name="expression-mode"></a>Режим выражения

Режим выражения предназначен для объединения выражений, необходимых для обработки значений в языке сценариев. Выражения — это представления значений в синтаксисе PowerShell, которые могут быть простыми или составными, например:

Литеральные выражения — это прямые представления их значений. 

```powershell
'hello', 32
```

Переменные выражения содержат значение переменной, на которую они ссылаются: 

```powershell
$x, $script:path
```
Операторы объединяют другие выражения для оценки: 

```powershell
- 12, -not $Quiet, 3 + 7, $input.Length -gt 1
```

- _Символьные строковые литералы_ должны содержаться в кавычках.
- _Числа_ обрабатываются как числовые значения, а не как последовательность символов (за исключением экранирования).
- _Операторы_ , включая унарные операторы, такие как `-` и `-not` , и бинарные операторы, такие как `+` и `-gt` , обрабатываются как операторы и применяют соответствующие операции к их аргументам (операндам).
- _Выражения атрибутов и преобразований_ анализируются как выражения и применяются к подчиненным выражениям, например `[int] '7'` .
- _Ссылки на переменные_ оцениваются по их значениям, но _Сплаттинг_ (т. е. предварительно заполненные наборы параметров) запрещены и вызывают ошибку синтаксического анализатора.
- Все остальное будет рассматриваться как вызываемая команда.

### <a name="argument-mode"></a>Режим аргументов

При синтаксическом анализе PowerShell сначала выполняет интерпретацию входных данных как выражения. Но при обнаружении вызова команды синтаксический анализ продолжится в режиме аргументов.

Режим аргументов предназначен для синтаксического анализа аргументов и параметров команд в среде оболочки. Все входные данные обрабатываются как расширяемая строка, если она не использует один из следующих синтаксисов:

- Знак доллара ( `$` ) начинает ссылку на переменную (только если за ней следует допустимое имя переменной, в противном случае оно интерпретируется как часть расширяемой строки).
- Кавычки ( `'` и `"` ) начало строковых значений
- Круглые скобки ( `(` и `)` ) разграничения новые выражения.
- Оператор части выражения ( `$(` ... `)` ) обозначает Embedded Expressions.
- В фигурные скобки ( `{` и `}` ) разграничения новые блоки скриптов.
- Начальная подпись at ( `@` ) начинает синтаксис выражений, таких как сплаттинг ( `@args` ), Arrays ( `@(1,2,3)` ) и hash Tables ( `@{a=1;b=2}` ).
- Запятые ( `,` ) предоставляют списки, переданные в виде массивов, за исключением случаев, когда вызываемая команда является собственным приложением. в этом случае они рассматриваются как часть расширяемой строки. Начальные, последовательные или конечные запятые не поддерживаются.

<!--
01234567890123456789012345678901234567890123456789012345678901234567890123456789
-->
Значения внедренных выражений преобразуются в строки.

В следующей таблице приведены несколько примеров значений, обрабатываемых в режиме выражений и в режиме аргументов, а также вычисление этих значений. Предполагается, что значение переменной `a` равно `4` .

|       Пример        |    Режим    |      Результат       |
| -------------------- | ---------- | ----------------- |
| `2`                  | Выражение | 2 (целое число)       |
| `` `2``              | Expression | "2" (команда)     |
| `echo 2`             | Expression | 2 (целое число)       |
| `2+2`                | Expression | 4 (целое число)       |
| `echo 2+2`           | Аргумент   | "2 + 2" (строка)    |
| `echo(2+2)`          | Expression | 4 (целое число)       |
| `$a`                 | Expression | 4 (целое число)       |
| `echo $a`            | Expression | 4 (целое число)       |
| `$a+2`               | Expression | 6 (целое число)       |
| `echo $a+2`          | Аргумент   | 4 + 2 (строка)      |
| `$-`                 | Аргумент   | "$-" (команда)    |
| `echo $-`            | Аргумент   | "$-" (строка)     |
| `a$a`                | Expression | "a $ a" (команда)   |
| `echo a$a`           | Аргумент   | "A4" (строка)     |
| `a'$a'`              | Expression | "a $ a" (команда)   |
| `echo a'$a'`         | Аргумент   | "a $ a" (строка)    |
| `a"$a"`              | Expression | "a $ a" (команда)   |
| `echo a"$a"`         | Аргумент   | "A4" (строка)     |
| `a$(2)`              | Expression | "a $ (2)" (команда) |
| `echo a$(2)`         | Аргумент   | "a2" (строка)     |

Каждый токен может интерпретироваться как некоторый тип объекта, например Boolean или String. PowerShell пытается определить тип объекта из выражения.
Тип объекта зависит от типа параметра, который требуется команде, и от того, знает ли PowerShell, как преобразовать аргумент в правильный тип. В следующей таблице приведены несколько примеров типов, назначенных значениям, возвращаемым выражениями.

|       Пример          |    Режим    |     Результат      |
| ---------------------- | ---------- | --------------- |
| `Write-Output !1`      | — аргумент   | "! 1" (строка)   |
| `Write-Output (!1)`    | expression | False (логическое значение) |
| `Write-Output (2)`     | expression | 2 (целое число)     |
| `Set-Variable AB A,B`  | — аргумент   | "A", "B" (массив) |
| `CMD /CECHO A,B`       | — аргумент   | "A, B" (строка)  |
| `CMD /CECHO $AB`       | expression | "A", "B" (массив) |
| `CMD /CECHO :$AB`      | — аргумент   | ": A B" (строка) |

Символ "точка-анализ" ( `--%` ), представленный в powershell 3,0, направляет PowerShell для отключения от интерпретации входных данных как команд или выражений PowerShell.

При вызове исполняемой программы в PowerShell перед программными аргументами поместите символ "точка-анализ". Этот метод гораздо проще, чем использование escape-символов для предотвращения неточной интерпретации.

Когда обнаруживает символ "точка-анализ", PowerShell считает остальные символы в строке как литералы. Единственной интерпретацией, которую он выполняет, является замена значений для переменных среды, использующих стандартную нотацию Windows, например `%USERPROFILE%` .

Символ "точка-анализ" действует только до следующей новой строки или символа конвейера. Нельзя использовать символ продолжения ( `` ` `` ), чтобы расширить его действие, или использовать разделитель команд ( `;` ) для завершения его воздействия.

Например, следующая команда вызывает программу **icacls** .

```powershell
icacls X:\VMS /grant Dom\HVAdmin:(CI)(OI)F
```

Чтобы выполнить эту команду в PowerShell 2,0, необходимо использовать escape-символы, чтобы запретить PowerShell правильно интерпретировать круглые скобки.

```powershell
icacls X:\VMS /grant Dom\HVAdmin:`(CI`)`(OI`)F
```

Начиная с PowerShell 3,0 можно использовать символ "прерывать анализ".

```powershell
icacls X:\VMS --% /grant Dom\HVAdmin:(CI)(OI)F
```

PowerShell отправляет следующую командную строку в программу **icacls** :

`X:\VMS /grant Dom\HVAdmin:(CI)(OI)F`

> [!NOTE]
> Символ для отмены синтаксического анализа предназначен только для платформ Windows.

## <a name="see-also"></a>СМ. ТАКЖЕ

[about_Command_Syntax](about_Command_Syntax.md)
