---
description: Описание регулярных выражений в PowerShell.
keywords: powershell,командлет
Locale: en-US
ms.date: 03/10/2020
online version: https://docs.microsoft.com/powershell/module/microsoft.powershell.core/about/about_regular_expressions?view=powershell-5.1&WT.mc_id=ps-gethelp
schema: 2.0.0
title: about_Regular_Expressions
ms.openlocfilehash: 84eefe224912cca96e6637eb6e3f239ef66b25bc
ms.sourcegitcommit: f874dc1d4236e06a3df195d179f59e0a7d9f8436
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/13/2020
ms.locfileid: "93232326"
---
# <a name="about-regular-expressions"></a>О регулярных выражениях

## <a name="short-description"></a>Краткое описание
Описание регулярных выражений в PowerShell.

## <a name="long-description"></a>Подробное описание

> [!NOTE]
> В этой статье мы покажем синтаксис и методы использования регулярных выражений в PowerShell, но не все описанные выше синтаксисы. Более полный справочник см. в разделе [Справочник по языку регулярных выражений](/dotnet/standard/base-types/regular-expression-language-quick-reference).

Регулярное выражение — это шаблон, используемый для сопоставления текста. Он может состоять из литеральных символов, операторов и других конструкций.

В этой статье демонстрируется синтаксис регулярных выражений в PowerShell. PowerShell имеет несколько операторов и командлетов, использующих регулярные выражения. Дополнительные сведения о синтаксисе и использовании см. по ссылкам ниже.

- [Select-String](xref:Microsoft.PowerShell.Utility.Select-String)
- [операторы match и-Replace](about_Comparison_Operators.md)
- [-Split](about_Split.md)
- [Оператор Switch с параметром-Regex](about_Switch.md)

По умолчанию регулярные выражения PowerShell не учитывают регистр. Каждый приведенный выше метод имеет другой способ принудительного учета регистра.

|       Метод       |                      Чувствительность к регистру                      |
| ------------------ | ---------------------------------------------------------- |
| `Select-String`    | использовать `-CaseSensitive` параметр                                |
| инструкция `switch` | Используйте `-casesensitive` параметр                            |
| операторы          | Добавить префикс с **"c"** ( `-cmatch` , `-csplit` или `-creplace` ) |

### <a name="character-literals"></a>Символьные литералы

Регулярное выражение может быть литеральным символом или строкой. Выражение приводит к тому, что подсистема сопоставляет текст, указанный в точности.

```powershell
# This statement returns true because book contains the string "oo"
'book' -match 'oo'
```

### <a name="character-classes"></a>Категории знаков

Хотя символьные литералы работают, если вам известно точное шаблон, классы символов позволяют быть менее конкретными.

#### <a name="character-groups"></a>Группы символов

`[character group]` позволяет сопоставить любое число символов один раз, в то время как `[^character group]` только символы, не находящиеся в группе.

```powershell
# This expression returns true if the pattern matches big, bog, or bug.
'big' -match 'b[iou]g'
```

Если список символов для сопоставления содержит символ дефиса ( `-` ), он должен находиться в начале или в конце списка, чтобы отличать его от выражения диапазона символов.

#### <a name="character-ranges"></a>Диапазоны символов

Шаблон также может быть диапазоном символов. Символы могут быть алфавитными `[A-Z]` , числовыми `[0-9]` или даже основанными на ASCII `[ -~]` (все печатные символы).

```powershell
# This expression returns true if the pattern matches any 2 digit number.
42 -match '[0-9][0-9]'
```

#### <a name="numbers"></a>Числа

`\d`Класс символов будет соответствовать любой десятичной цифре. И наоборот, `\D` будет соответствовать любой цифре, отличной от десятичной.

```powershell
# This expression returns true if it matches a server name.
# (Server-01 - Server-99).
'Server-01' -match 'Server-\d\d'
```

#### <a name="word-characters"></a>Символы слов

`\w`Класс символов будет соответствовать любому символу слова `[a-zA-Z_0-9]` . Для соответствия любому символу, не являющемуся буквой, используйте `\W` .

```powershell
# This expression returns true.
# The pattern matches the first word character 'B'.
'Book' -match '\w'
```

#### <a name="wildcards"></a>подстановочные знаки;

Точка ( `.` ) является символом-шаблоном в регулярных выражениях. Он будет соответствовать любому символу, кроме новой строки ( `\n` ).

```powershell
# This expression returns true.
# The pattern matches any 4 characters except the newline.
'a1\ ' -match '....'
```

#### <a name="whitespace"></a>Пробелы

Пробелы сопоставляются с помощью `\s` класса символов. Все символы, отличные от пробельных, сопоставляются с помощью `\S` . Также можно использовать символы пространства литерала `' '` .

```powershell
# This expression returns true.
# The pattern uses both methods to match the space.
' - ' -match '\s- '
```

### <a name="quantifiers"></a>Квантификаторы

Кванторы контролируют, сколько экземпляров каждого элемента должно присутствовать во входной строке.

Ниже перечислены некоторые кванторы, доступные в PowerShell.

| Квантификатор |                Описание                |
| ---------- | ----------------------------------------- |
| `*`        | Ноль или более раз.                       |
| `+`        | Один или несколько раз.                        |
| `?`        | Ноль или один раз.                         |
| `{n,m}`    | Как минимум `n` , но не более `m` раз. |

Звездочка ( `*` ) соответствует предыдущему элементу ноль или более раз. Результатом является то, что даже входная строка без элемента будет совпадать.

```powershell
# This returns true for all account name strings even if the name is absent.
'ACCOUNT NAME:    Administrator' -match 'ACCOUNT NAME:\s*\w*'
```

Знак "плюс" ( `+` ) соответствует предыдущему элементу один или более раз.

```powershell
# This returns true if it matches any server name.
'DC-01' -match '[A-Z]+-\d\d'
```

Вопросительный знак `?` соответствует предыдущему элементу ноль или один раз. Как и звездочка `*` , она даже будет сопоставлять строки, в которых отсутствует элемент.

```powershell
# This returns true for any server name, even server names without dashes.
'SERVER01' -match '[A-Z]+-?\d\d'
```

`{n, m}`Квантификатор можно использовать несколькими различными способами, чтобы обеспечить детальный контроль над квантификатором. Второй элемент `m` и запятая `,` являются необязательными.

| Квантификатор |                Описание                 |
| ---------- | ------------------------------------------ |
| `{n}`      | Совпадение ровно `n` число раз.         |
| `{n,}`     | Совпадение по КРАЙНЕй мере с `n` числом раз.        |
| `{n,m}`    | Совпадение между `n` и `m` числом раз. |

```powershell
# This returns true if it matches any phone number.
'111-222-3333' -match '\d{3}-\d{3}-\d{4}'
```

### <a name="anchors"></a>Привязки

Привязки позволяют вызвать успешное или неудачное выполнение соответствия в зависимости от того, где находится строка во входной строке.

Двумя часто используемыми привязками являются `^` и `$` . Курсор `^` соответствует началу строки и `$` , который соответствует концу строки. Привязки позволяют сопоставлять текст в определенной позиции, одновременно удаляя ненужные символы.

```powershell
# The pattern expects the string 'fish' to be the only thing on the line.
# This returns FALSE.
'fishing' -match '^fish$'
```

> [!NOTE]
> При определении регулярного выражения `$` , содержащего привязку, обязательно заключите регулярное выражение в одинарные кавычки ( `'` ) вместо двойных кавычек ( `"` ) или PowerShell развернет выражение как переменную.

При использовании привязок в PowerShell следует понимать разницу между параметрами **SingleLine** и **многострочных** регулярных выражений.

- **Многострочный** : многострочный режим заставляет `^` и `$` сопоставлять НАЧАЛЬную конец каждой строки, а не начало и конец входной строки.
- **SingleLine** : режим SingleLine обрабатывает входную строку как **SingleLine**.
  Он заставляет `.` символ соответствовать каждому символу (включая символы новой строки) вместо того, чтобы сопоставлять каждый символ, кроме символа новой строки `\n` .

Дополнительные сведения об этих параметрах и способах их использования см. в статье [Язык регулярных выражений — краткий справочник](/dotnet/standard/base-types/regular-expression-language-quick-reference).

### <a name="escaping-characters"></a>Экранирование символов

Обратная косая черта ( `\` ) используется для экранирования символов, поэтому они не анализируются обработчиком регулярных выражений.

Зарезервированы следующие символы: `[]().\^$|?*+{}` .

Эти символы в шаблонах необходимо экранировановать, чтобы они совпадали с ними во входных строках.

```powershell
# This returns true and matches numbers with at least 2 digits of precision.
# The decimal point is escaped using the backslash.
'3.141' -match '3\.\d{2,}'
```

Существует статический метод класса Regex, который может поэкранировать текст.

```powershell
[regex]::escape('3.\d{2,}')
```

```Output
3\.\\d\{2,}
```

> [!NOTE]
> Это приводит к экранированию всех зарезервированных символов регулярного выражения, включая существующие обратные косые черты, используемые в классах символов. Обязательно используйте его только в той части шаблона, которая необходима для экранирования.

#### <a name="other-character-escapes"></a>Другие escape-символы

Существуют также зарезервированные escape-символы, которые можно использовать для сопоставления специальных символьных типов.

Ниже приведены несколько часто используемых escape-символов:

|Escape-последовательность символов  |Описание  |
|---------|---------|
|`\t`|Соответствует символу табуляции|
|`\n`|Соответствует символу новой строки|
|`\r`|Соответствует символу возврата каретки|

### <a name="groups-captures-and-substitutions"></a>Группы, записи и подстановки

Конструкции группирования разделяют входную строку на подстроки, которые можно записывать или игнорировать. Сгруппированные подстроки называются частью выражения. По умолчанию части выражения фиксируются в нумерованных группах, но также можно назначать им имена.

Конструкция группирования — это регулярное выражение, заключенное в круглые скобки. Захватывается любой текст, совпадающий с вложенным регулярным выражением. В следующем примере входной текст будет разбиваться на две группы записи.

```powershell
'The last logged on user was CONTOSO\jsmith' -match '(.+was )(.+)'
```

```Output
True
```

Используйте `$Matches` автоматическую переменную **Hashtable** для получения захваченного текста.
Текст, представляющий полное совпадение, хранится в разделе Key `0` .

```powershell
$Matches.0
```

```Output
The last logged on user was CONTOSO\jsmith
```

Записи хранятся в числовых **целочисленных** ключах, которые увеличиваются слева направо. Запись `1` содержит весь текст до имени пользователя, а запись `2` содержит только имя пользователя.

```powershell
$Matches
```

```Output
Name                           Value
----                           -----
2                              CONTOSO\jsmith
1                              The last logged on user was
0                              The last logged on user was CONTOSO\jsmith
```

> [!IMPORTANT]
> `0`Ключ является **целым числом**. Для доступа к сохраненному значению можно использовать любой метод **Hashtable** .
>
> ```
> PS> 'Good Dog' -match 'Dog'
> True
>
> PS> $Matches[0]
> Dog
>
> PS> $Matches.Item(0)
> Dog
>
> PS> $Matches.0
> Dog
> ```

#### <a name="named-captures"></a>Именованные записи

По умолчанию записи хранятся в возрастающем числовом порядке, слева направо.
Можно также присвоить **имя** захваченной группе. Это **имя** станет ключом в `$Matches` автоматической переменной **Hashtable** .

Внутри захваченной группы используйте `?<keyname>` для хранения захваченных данных с именованным ключом.

```
PS> $string = 'The last logged on user was CONTOSO\jsmith'
PS> $string -match 'was (?<domain>.+)\\(?<user>.+)'
True

PS> $Matches

Name                           Value
----                           -----
domain                         CONTOSO
user                           jsmith
0                              was CONTOSO\jsmith

PS> $Matches.domain
CONTOSO

PS> $Matches.user
jsmith
```

В следующем примере хранится последняя версия **SuccessAudit** из журнала безопасности Windows. Указанное регулярное выражение извлекает имя пользователя и домен из сообщения и сохраняет их в ключах: **N** для Name и **D** для domain.

```powershell
$log = (Get-EventLog -LogName Security -Newest 1 -InstanceId 4689).message
$r = '(?s).*Account Name:\s*(?<N>.*).*Account Domain:\s*(?<D>[A-Z,0-9]*)'
$log -match $r
```

```Output
True
```

```powershell
$Matches
```

```Output
Name                           Value
----                           -----
D                              CONTOSO
N                              jsmith
0                              A process has exited....
```

Дополнительные сведения см. [в разделе конструкции группирования в регулярных выражениях](/dotnet/standard/base-types/grouping-constructs-in-regular-expressions).

#### <a name="substitutions-in-regular-expressions"></a>Подстановки в регулярных выражениях

Использование регулярных выражений с `-replace` оператором позволяет динамически заменять текст с помощью захваченного текста.

`<input> -replace <original>, <substitute>`

- `<input>`: Искомая строка
- `<original>`: Регулярное выражение, используемое для поиска во входной строке
- `<substitute>`: Выражение подстановки регулярного выражения для замены совпадений, обнаруженных во входной строке.

> [!NOTE]
> `<original>` `<substitute>` Операнды и подчиняются правилам обработчика регулярных выражений, таких как Экранирование символов.

В строке можно ссылаться на захваченные группы `<substitute>` . Подстановка выполняется с помощью `$` символа перед идентификатором группы.

Существуют два способа ссылки на группы записи по **числу** и **имени**.

- По **числу** групп записи нумеруются слева направо.

  ```powershell
  'John D. Smith' -replace '(\w+) (\w+)\. (\w+)', '$1.$2.$3@contoso.com'
  ```

  ```Output
  John.D.Smith@contoso.com
  ```

- По именам групп также можно ссылаться **по имени.**

  ```powershell
  'CONTOSO\Administrator' -replace '\w+\\(?<user>\w+)', 'FABRIKAM\${user}'
  ```

  ```Output
  FABRIKAM\Administrator
  ```

`$&`Выражение представляет весь текст, соответствующий.

```powershell
'Gobble' -replace 'Gobble', '$& $&'
```

```Output
Gobble Gobble
```

> [!WARNING]
> Поскольку `$` символ используется в расширении строки, необходимо использовать литеральные строки с подстановкой или Escape- `$` символ при использовании двойных кавычек.
>
> ```powershell
> 'Hello World' -replace '(\w+) \w+', '$1 Universe'
> "Hello World" -replace "(\w+) \w+", "`$1 Universe"
> ```
>
> ```Output
> Hello Universe
> Hello Universe
> ```
>
> Кроме того, если требуется `$` использовать в качестве литерального символа, используйте `$$` вместо обычных escape-символов. При использовании двойных кавычек все экземпляры во `$` избежание неправильной замены.
>
> ```powershell
> '5.72' -replace '(.+)', '$$$1'
> "5.72" -replace "(.+)", "`$`$`$1"
> ```
>
> ```Output
> $5.72
> $5.72
> ```

Дополнительные сведения см. [в разделе подстановки в регулярных выражениях](/dotnet/standard/base-types/substitutions-in-regular-expressions).

## <a name="see-also"></a>См. также статью

[about_Comparison_Operators](about_Comparison_Operators.md)

[about_Operators](about_Operators.md)
