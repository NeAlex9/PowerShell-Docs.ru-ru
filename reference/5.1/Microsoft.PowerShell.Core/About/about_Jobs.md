---
description: Содержит сведения о том, как фоновые задания PowerShell выполняют команду или выражение в фоновом режиме без взаимодействия с текущим сеансом.
keywords: powershell,командлет
Locale: en-US
ms.date: 10/16/2020
online version: https://docs.microsoft.com/powershell/module/microsoft.powershell.core/about/about_jobs?view=powershell-5.1&WT.mc_id=ps-gethelp
schema: 2.0.0
title: about_Jobs
ms.openlocfilehash: a2fba9024f9b365c79ea5d59d6840a72ba1f8b21
ms.sourcegitcommit: 108686b166672cc08817c637dd93eb1ad830511d
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/17/2020
ms.locfileid: "93232949"
---
# <a name="about-jobs"></a>О заданиях

## <a name="short-description"></a>Краткое описание
Содержит сведения о том, как фоновые задания PowerShell выполняют команду или выражение в фоновом режиме без взаимодействия с текущим сеансом.

## <a name="long-description"></a>Подробное описание

PowerShell параллельно выполняет команды и скрипты с помощью заданий. Существует три решения на основе заданий, предоставляемые PowerShell для поддержки параллелизма.

|Задание            |Описание                                                  |
|---------------|-------------------------------------------------------------|
|`RemoteJob`    |Команда и сценарий выполняются на удаленном компьютере.                 |
|`BackgroundJob`|Команда и сценарий выполняются в отдельном процессе в локальной системе    |
|               |машине.                                                     |
|`ThreadJob`    |Команда и сценарий выполняются в отдельном потоке в том же  |
|               |процесс на локальном компьютере.                                |

Каждый тип задания имеет свои преимущества и недостатки. Удаленное выполнение сценария на отдельном компьютере или в отдельном процессе имеет большую изоляцию. Любые ошибки не влияют на другие выполняющиеся задания или на клиент, запустивший задание. Но на уровне удаленного взаимодействия добавляются дополнительные издержки, включая сериализацию объектов. Все объекты, передаваемые в удаленный сеанс и из него, должны быть сериализованы и десериализованы при передаче между клиентом и целевым сеансом. Операция сериализации может использовать много ресурсов вычислений и памяти для больших сложных объектов данных.

В этом разделе объясняется, как выполнять фоновые задания в PowerShell на локальном компьютере. Сведения о выполнении фоновых заданий на удаленных компьютерах см. в разделе [about_Remote_Jobs](about_Remote_Jobs.md). Дополнительные сведения о заданиях потоков см. в разделе [about_Thread_Jobs](/powershell/module/microsoft.powershell.core/about/about_Thread_Jobs).

Когда вы запускаете фоновое задание, Командная строка возвращается немедленно, даже если выполнение задания занимает длительное время. Пока задание выполняется, можно продолжать работу с данным сеансом.

## <a name="the-job-cmdlets"></a>Командлеты задания

|Командлет          |Описание                                            |
|----------------|-------------------------------------------------------|
|`Start-Job`     |Запускает фоновое задание на локальном компьютере.           |
|`Get-Job`       |Возвращает фоновые задания, запущенные в      |
|                |текущий сеанс.                                       |
|`Receive-Job`   |Возвращает результаты фоновых заданий.                   |
|`Stop-Job`      |Останавливает фоновое задание.                                |
|`Wait-Job`      |Подавляет командную строку до тех пор, пока одно или все задания не будут|
|                |завершения.                                              |
|`Remove-Job`    |Удаляет фоновое задание.                              |
|`Invoke-Command`|Параметр **AsJob** создает фоновое задание на  |
|                |удаленный компьютер. Можно использовать `Invoke-Command` для запуска   |
|                |Любая команда задания удаленно, включая `Start-Job` .       |

## <a name="how-to-start-a-job-on-the-local-computer"></a>Запуск задания на локальном компьютере

Чтобы запустить фоновое задание на локальном компьютере, используйте `Start-Job` командлет.

Чтобы написать `Start-Job` команду, заключите команду, которая выполняется заданием, в фигурные скобки ( `{}` ). Используйте параметр **ScriptBlock** для указания команды.

Следующая команда запускает фоновое задание, которое выполняет `Get-Process` команду на локальном компьютере.

```powershell
Start-Job -ScriptBlock {Get-Process}
```

`Start-Job`Команда возвращает объект, представляющий задание. Объект задания содержит полезную информацию о задании, но не содержит результатов его выполнения.

Сохраните объект задания в переменной, а затем используйте его вместе с другими командлетами задания для управления фоновыми заданиями. Следующая команда запускает объект задания и сохраняет результирующий объект задания в `$job` переменной.

```powershell
$job = Start-Job -ScriptBlock {Get-Process}
```

Можно также использовать `Get-Job` командлет для получения объектов, представляющих задания, запущенные в текущем сеансе. `Get-Job` возвращает тот же объект задания, который `Start-Job` возвращает.

## <a name="getting-job-objects"></a>Получение объектов заданий

Чтобы получить объект, который представляет фоновые задания, запущенные в текущем сеансе, используйте `Get-Job` командлет. Без параметров `Get-Job` возвращает все задания, запущенные в текущем сеансе.

Например, следующая команда возвращает задания в текущем сеансе.

```powershell
PS C:> Get-Job

Id  Name  PSJobTypeName State      HasMoreData  Location   Command
--  ----  ------------- -----      -----------  --------   -------
1   Job1  BackgroundJob Running    True         localhost  Get-Process
```

Можно также сохранить объект задания в переменной и использовать его для представления задания в более поздней команде. Следующая команда возвращает задание с ИДЕНТИФИКАТОРом 1 и сохраняет его в `$job` переменной.

```powershell
$job = Get-Job -Id 1
```

Объект задания содержит состояние задания, которое указывает, завершено ли задание. Завершенное задание имеет состояние " **завершено** " или " **сбой** ". Задание также может быть **заблокировано** или **заработано** .

```powershell
Get-Job

Id  Name  PSJobTypeName State      HasMoreData  Location   Command
--  ----  ------------- -----      -----------  --------   -------
1   Job1  BackgroundJob Complete   True         localhost  Get-Process
```

## <a name="getting-the-results-of-a-job"></a>Получение результатов задания

При выполнении фонового задания результаты не отображаются немедленно. Вместо этого `Start-Job` командлет возвращает объект задания, который представляет задание, но не содержит результаты. Чтобы получить результаты фонового задания, используйте `Receive-Job` командлет.

Следующая команда использует `Receive-Job` командлет для получения результатов задания. Для обнаружения задания используется объект задания, сохраненный в `$job` переменной.

```powershell
Receive-Job -Job $job
```

`Receive-Job`Командлет возвращает результаты задания.

```
Handles  NPM(K)    PM(K)      WS(K) VM(M)   CPU(s)    Id ProcessName
-------  ------    -----      ----- -----   ------    -- -----------
    103       4    11328       9692    56           1176 audiodg
    804      14    12228      14108   100   101.74  1740 CcmExec
    668       7     2672       6168   104    32.26   488 csrss
# ...
```

Результаты задания также можно сохранить в переменной. Следующая команда сохраняет результаты задания в `$job` переменной в `$results` переменной.

```powershell
$results = Receive-Job -Job $job
```

Кроме того, результаты задания можно сохранить в файле с помощью оператора перенаправления ( `>` ) или `Out-File` командлета. Следующая команда использует оператор перенаправления для сохранения результатов задания в `$job` переменной в `Results.txt` файле.

```powershell
Receive-Job -Job $job > results.txt
```

## <a name="getting-and-keeping-partial-job-results"></a>Получение и хранение результатов частичной работы

`Receive-Job`Командлет возвращает результаты фонового задания. Если задание завершено, `Receive-Job` получает результаты всех заданий. Если задание по-прежнему выполняется, `Receive-Job` получает результаты, которые были созданы до сих пор. `Receive-Job`Чтобы получить оставшиеся результаты, можно выполнить команды еще раз.

Если `Receive-Job` возвращает результаты, по умолчанию он удаляет результаты из кэша, в котором хранятся результаты задания. Если выполнить другую `Receive-Job` команду, вы получите только те результаты, которые еще не были получены.

Следующие команды показывают результаты `Receive-Job` выполнения команд до завершения задания.

```powershell
C:\PS> Receive-Job -Job $job

Handles  NPM(K)    PM(K)      WS(K) VM(M)   CPU(s)     Id ProcessName
-------  ------    -----      ----- -----   ------     -- -----------
    103       4    11328       9692    56            1176 audiodg
    804      14    12228      14108   100   101.74   1740 CcmExec

C:\PS> Receive-Job -Job $job

Handles  NPM(K)    PM(K)      WS(K) VM(M)   CPU(s)     Id ProcessName
-------  ------    -----      ----- -----   ------     -- -----------
    68       3     2632        664    29     0.36   1388 ccmsetup
   749      22    21468      19940   203   122.13   3644 communicator
   905       7     2980       2628    34   197.97    424 csrss
  1121      25    28408      32940   174   430.14   3048 explorer
```

Чтобы предотвратить `Receive-Job` Удаление возвращаемых результатов задания, используйте параметр **держитесь** . В результате `Receive-Job` возвращает все результаты, которые были созданы до этого времени.

Приведенные ниже команды демонстрируют последствия использования параметра **сохранения** для задания, которое еще не завершено.

```powershell
C:\PS> Receive-Job -Job $job -Keep

Handles  NPM(K)    PM(K)      WS(K) VM(M)   CPU(s)     Id ProcessName
-------  ------    -----      ----- -----   ------     -- -----------
    103       4    11328       9692    56            1176 audiodg
    804      14    12228      14108   100   101.74   1740 CcmExec

C:\PS> Receive-Job -Job $job -Keep

Handles  NPM(K)    PM(K)      WS(K) VM(M)   CPU(s)     Id ProcessName
-------  ------    -----      ----- -----   ------     -- -----------
    103       4    11328       9692    56            1176 audiodg
    804      14    12228      14108   100   101.74   1740 CcmExec
     68       3     2632        664    29     0.36   1388 ccmsetup
    749      22    21468      19940   203   122.13   3644 communicator
    905       7     2980       2628    34   197.97    424 csrss
   1121      25    28408      32940   174   430.14   3048 explorer
```

## <a name="waiting-for-the-results"></a>Ожидание результатов

При выполнении команды, выполнение которой занимает много времени, можно использовать свойства объекта задания, чтобы определить, когда задание завершено. Следующая команда использует `Get-Job` объект для получения всех фоновых заданий в текущем сеансе.

```powershell
Get-Job
```

Результаты отображаются в таблице. Состояние задания отображается в столбце **состояние** .

```
Id Name  PSJobTypeName State    HasMoreData Location  Command
-- ----  ------------- -----    ----------- --------  -------
1  Job1  BackgroundJob Complete True        localhost Get-Process
2  Job2  BackgroundJob Running  True        localhost Get-EventLog -Log ...
3  Job3  BackgroundJob Complete True        localhost dir -Path C:\* -Re...
```

В этом случае свойство State показывает, что задание 2 все еще выполняется. Если вы использовали `Receive-Job` командлет для получения результатов задания прямо сейчас, результаты будут неполными. Можно `Receive-Job` многократно использовать командлет для получения всех результатов. По умолчанию при каждом использовании вы получаете только те результаты, которые еще не были получены, но можно использовать параметр **сохранения** `Receive-Job` командлета для сохранения результатов, даже если они уже были получены.

Можно записать частичные результаты в файл, а затем добавить новые результаты по мере их поступления или же подождать и проверить состояние задания позже.

Можно использовать параметр **Wait** `Receive-Job` командлета, который не возвращает командную строку, пока задание не будет завершено и все результаты будут доступны.

Можно также использовать `Wait-Job` командлет для ожидания любого или всех результатов задания. `Wait-Job` позволяет ожидать определенного задания, для всех заданий или для выполнения всех заданий.

Следующая команда использует `Wait-Job` командлет для ожидания задания с **идентификатором** .
10.

```powershell
Wait-Job -ID 10
```

В результате Командная строка PowerShell подавляется до завершения задания.

Можно также дождаться заранее определенного периода времени. Эта команда использует параметр **timeout** , чтобы ограничить время ожидания 120 секунд. По истечении этого времени Командная строка возвращает значение, но задание продолжит выполняться в фоновом режиме.

```powershell
Wait-Job -ID 10 -Timeout 120
```

## <a name="stopping-a-job"></a>Остановка задания

Чтобы прерывать фоновое задание, используйте `Stop-Job` командлет. Следующая команда запускает задание для получения каждой записи в журнале системных событий. Объект задания сохраняется в `$job` переменной.

```powershell
$job = Start-Job -ScriptBlock {Get-EventLog -Log System}
```

Следующая команда останавливает задание. Он использует оператор конвейера ( `|` ) для отправки задания в переменной в `$job` `Stop-Job` .

```powershell
$job | Stop-Job
```

## <a name="deleting-a-job"></a>Удаление задания

Чтобы удалить фоновое задание, используйте `Remove-Job` командлет. Следующая команда удаляет задание в `$job` переменной.

```powershell
Remove-Job -Job $job
```

## <a name="investigating-a-failed-job"></a>Исследование невыполненного задания

Чтобы узнать, почему не удалось выполнить задание, используйте свойство **Reason** объекта Job.

Следующая команда запускает задание без требуемых учетных данных. Объект задания сохраняется в `$job` переменной.

```powershell
$job = Start-Job -ScriptBlock {New-Item -Path HKLM:\Software\MyCompany}

Id Name  PSJobTypeName State  HasMoreData  Location  Command
-- ----  ------------- -----  -----------  --------  -------
1  Job1  BackgroundJob Failed False        localhost New-Item -Path HKLM:...
```

Следующая команда использует свойство Reason для поиска ошибки, вызвавшей сбой задания.

```powershell
$job.ChildJobs[0].JobStateInfo.Reason
```

В этом случае задание завершилось сбоем, так как удаленный компьютер требует явных учетных данных для выполнения команды. Значение свойства **Reason** :

Сбой подключения к удаленному серверу со следующим сообщением об ошибке: "отказано в доступе".

## <a name="see-also"></a>См. также статью

- [about_Remote_Jobs](about_Remote_Jobs.md)
- [about_Thread_Jobs](/powershell/module/microsoft.powershell.core/about/about_Thread_Jobs)
- [about_Job_Details](about_Job_Details.md)
- [about_Remote](about_Remote.md)
- [about_PSSessions](about_PSSessions.md)
- [Start-Job](xref:Microsoft.PowerShell.Core.Start-Job)
- [Get-Job.](xref:Microsoft.PowerShell.Core.Get-Job)
- [Receive-Job.](xref:Microsoft.PowerShell.Core.Receive-Job)
- [Stop-Job.](xref:Microsoft.PowerShell.Core.Stop-Job)
- [Wait-Job](xref:Microsoft.PowerShell.Core.Wait-Job)
- [Remove-Job](xref:Microsoft.PowerShell.Core.Remove-Job)
- [Invoke-Command](xref:Microsoft.PowerShell.Core.Invoke-Command)
