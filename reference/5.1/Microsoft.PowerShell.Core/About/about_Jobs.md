---
description: Содержит сведения о том, как фоновые задания PowerShell выполняют команду или выражение в фоновом режиме без взаимодействия с текущим сеансом.
keywords: powershell,командлет
Locale: en-US
ms.date: 11/11/2020
online version: https://docs.microsoft.com/powershell/module/microsoft.powershell.core/about/about_jobs?view=powershell-5.1&WT.mc_id=ps-gethelp
schema: 2.0.0
title: about_Jobs
ms.openlocfilehash: bce65f0bd173f936e868c3bef048ecac3f4f4ca6
ms.sourcegitcommit: aac365f7813756e16b59322832a904e703e0465b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/12/2020
ms.locfileid: "94524433"
---
# <a name="about-jobs"></a>О заданиях

## <a name="short-description"></a>Краткое описание
Содержит сведения о том, как фоновые задания PowerShell выполняют команду или выражение в фоновом режиме без взаимодействия с текущим сеансом.

## <a name="long-description"></a>Подробное описание

PowerShell параллельно выполняет команды и скрипты с помощью заданий. Существует три типа заданий, предоставляемых PowerShell для поддержки параллелизма.

- `RemoteJob` — Команды и сценарии выполняются в удаленном сеансе. Дополнительные сведения см. в разделе [about_Remote_Jobs](about_Remote_Jobs.md).
- `BackgroundJob` — Команды и скрипты выполняются в отдельном процессе на локальном компьютере.
- `PSTaskJob` или `ThreadJob` — команды и скрипты выполняются в отдельном потоке в том же процессе на локальном компьютере. Дополнительные сведения см. в разделе [about_Thread_Jobs](/powershell/module/ThreadJob/about_Thread_Jobs).

Удаленное выполнение сценариев на отдельном компьютере или в отдельном процессе обеспечивает высокую изоляцию. Любые ошибки, возникающие в удаленном задании, не влияют на другие выполняющиеся задания или родительский сеанс, запускающий задание. Однако на уровне удаленного взаимодействия добавляются дополнительные издержки, в том числе сериализация объектов. Все объекты сериализуются и десериализуются, так как они передаются между родительским сеансом и удаленным сеансом (Job). Сериализация больших сложных объектов данных может потреблять большие объемы ресурсов вычислений и памяти и передавать большие объемы данных по сети.

Задания на основе потоков не так надежны, как удаленные и фоновые задания, так как они выполняются в одном и том же процессе в разных потоках. Если в одном задании есть критическая ошибка, которая приводит к сбою процесса, то все остальные задания в этом процессе завершаются.

Однако задания на основе потоков нуждаются в меньшей нагрузке. Они не используют удаленный уровень или сериализацию. Результирующие объекты возвращаются в виде ссылок на активные объекты в текущем сеансе. Без такой нагрузки задания на основе потоков выполняются быстрее и используют меньше ресурсов, чем другие типы заданий.

> [!IMPORTANT]
> Родительский сеанс, создавший задание, также отслеживает состояние задания и собирает данные конвейера. Дочерний процесс задания завершается родительским процессом после того, как задание достигнет завершенного состояния. Если родительский сеанс завершается, все выполняющиеся дочерние задания завершаются вместе с их дочерними процессами.

Существует два способа обойти эту ситуацию.

1. Используйте `Invoke-Command` для создания заданий, выполняемых в отключенных сеансах. Дополнительные сведения см. в разделе [about_Remote_Jobs](about_Remote_Jobs.md).
1. Используйте `Start-Process` для создания нового процесса, а не задания. Дополнительные сведения см. в разделе [Start-Process](xref:Microsoft.PowerShell.Management.Start-Process).

## <a name="the-job-cmdlets"></a>Командлеты задания

|Командлет          |Описание                                            |
|----------------|-------------------------------------------------------|
|`Start-Job`     |Запускает фоновое задание на локальном компьютере.           |
|`Get-Job`       |Возвращает фоновые задания, запущенные в      |
|                |текущий сеанс.                                       |
|`Receive-Job`   |Возвращает результаты фоновых заданий.                   |
|`Stop-Job`      |Останавливает фоновое задание.                                |
|`Wait-Job`      |Подавляет командную строку до тех пор, пока одно или все задания не будут|
|                |завершения.                                              |
|`Remove-Job`    |Удаляет фоновое задание.                              |
|`Invoke-Command`|Параметр **AsJob** создает фоновое задание на  |
|                |удаленный компьютер. Можно использовать `Invoke-Command` для запуска   |
|                |Любая команда задания удаленно, включая `Start-Job` .       |

## <a name="how-to-start-a-job-on-the-local-computer"></a>Запуск задания на локальном компьютере

Чтобы запустить фоновое задание на локальном компьютере, используйте `Start-Job` командлет.

Чтобы написать `Start-Job` команду, заключите команду, которая выполняется заданием, в фигурные скобки ( `{}` ). Используйте параметр **ScriptBlock** для указания команды.

Следующая команда запускает фоновое задание, которое выполняет `Get-Process` команду на локальном компьютере.

```powershell
Start-Job -ScriptBlock {Get-Process}
```

Когда вы запускаете фоновое задание, Командная строка возвращается немедленно, даже если выполнение задания занимает длительное время. Пока задание выполняется, можно продолжать работу с данным сеансом.

`Start-Job`Команда возвращает объект, представляющий задание. Объект задания содержит полезную информацию о задании, но не содержит результатов его выполнения.

Вы можете сохранить объект задания в переменной, а затем использовать его вместе с другими командлетами **задания** для управления фоновыми заданиями. Следующая команда запускает объект задания и сохраняет результирующий объект задания в `$job` переменной.

```powershell
$job = Start-Job -ScriptBlock {Get-Process}
```

## <a name="getting-job-objects"></a>Получение объектов заданий

`Get-Job`Командлет возвращает объекты, представляющие фоновые задания, которые были запущены в текущем сеансе. Без параметров `Get-Job` возвращает все задания, запущенные в текущем сеансе.

```powershell
Get-Job
```

Объект задания содержит состояние задания, которое указывает, завершено ли задание. Завершенное задание имеет состояние " **завершено** " или " **сбой** ". Задание также может быть **заблокировано** или **заработано**.

```Output
Id  Name  PSJobTypeName State      HasMoreData  Location   Command
--  ----  ------------- -----      -----------  --------   -------
1   Job1  BackgroundJob Complete   True         localhost  Get-Process
```

Вы можете сохранить объект задания в переменной и использовать его для представления задания в более поздней команде. Следующая команда возвращает задание с ИДЕНТИФИКАТОРом 1 и сохраняет его в `$job` переменной.

```powershell
$job = Get-Job -Id 1
```

## <a name="getting-the-results-of-a-job"></a>Получение результатов задания

При выполнении фонового задания результаты не отображаются немедленно. Чтобы получить результаты фонового задания, используйте `Receive-Job` командлет.

В следующем примере `Receive-Job` командлет получает результаты задания с помощью объекта задания в `$job` переменной.

```powershell
Receive-Job -Job $job
```

```Output
Handles  NPM(K)    PM(K)      WS(K) VM(M)   CPU(s)    Id ProcessName
-------  ------    -----      ----- -----   ------    -- -----------
    103       4    11328       9692    56           1176 audiodg
    804      14    12228      14108   100   101.74  1740 CcmExec
    668       7     2672       6168   104    32.26   488 csrss
...
```

Результаты задания можно сохранить в переменной. Следующая команда сохраняет результаты задания в `$job` переменной в `$results` переменной.

```powershell
$results = Receive-Job -Job $job
```

### <a name="getting-and-keeping-partial-job-results"></a>Получение и хранение результатов частичной работы

`Receive-Job`Командлет возвращает результаты фонового задания. Если задание завершено, `Receive-Job` получает результаты всех заданий. Если задание по-прежнему выполняется, `Receive-Job` получает результаты, которые были созданы до сих пор. `Receive-Job`Чтобы получить оставшиеся результаты, можно выполнить команды еще раз.

По умолчанию `Receive-Job` удаляет результаты из кэша, в котором хранятся результаты задания. При `Receive-Job` повторном запуске вы получаете только новые результаты, поступившие после первого запуска.

Следующие команды показывают результаты `Receive-Job` выполнения команд до завершения задания.

```powershell
C:\PS> Receive-Job -Job $job

Handles  NPM(K)    PM(K)      WS(K) VM(M)   CPU(s)     Id ProcessName
-------  ------    -----      ----- -----   ------     -- -----------
    103       4    11328       9692    56            1176 audiodg
    804      14    12228      14108   100   101.74   1740 CcmExec

C:\PS> Receive-Job -Job $job

Handles  NPM(K)    PM(K)      WS(K) VM(M)   CPU(s)     Id ProcessName
-------  ------    -----      ----- -----   ------     -- -----------
    68       3     2632        664    29     0.36   1388 ccmsetup
   749      22    21468      19940   203   122.13   3644 communicator
   905       7     2980       2628    34   197.97    424 csrss
  1121      25    28408      32940   174   430.14   3048 explorer
```

Используйте параметр **держитесь** , чтобы предотвратить `Receive-Job` Удаление возвращаемых результатов задания. Приведенные ниже команды демонстрируют последствия использования параметра **сохранения** для задания, которое еще не завершено.

```powershell
C:\PS> Receive-Job -Job $job -Keep

Handles  NPM(K)    PM(K)      WS(K) VM(M)   CPU(s)     Id ProcessName
-------  ------    -----      ----- -----   ------     -- -----------
    103       4    11328       9692    56            1176 audiodg
    804      14    12228      14108   100   101.74   1740 CcmExec

C:\PS> Receive-Job -Job $job -Keep

Handles  NPM(K)    PM(K)      WS(K) VM(M)   CPU(s)     Id ProcessName
-------  ------    -----      ----- -----   ------     -- -----------
    103       4    11328       9692    56            1176 audiodg
    804      14    12228      14108   100   101.74   1740 CcmExec
     68       3     2632        664    29     0.36   1388 ccmsetup
    749      22    21468      19940   203   122.13   3644 communicator
    905       7     2980       2628    34   197.97    424 csrss
   1121      25    28408      32940   174   430.14   3048 explorer
```

### <a name="waiting-for-the-results"></a>Ожидание результатов

При выполнении команды, выполнение которой занимает много времени, можно использовать свойства объекта задания, чтобы определить, когда задание завершено. Следующая команда использует `Get-Job` объект для получения всех фоновых заданий в текущем сеансе.

```powershell
Get-Job
```

Результаты отображаются в таблице. Состояние задания отображается в столбце **состояние** .

```Output
Id Name  PSJobTypeName State    HasMoreData Location  Command
-- ----  ------------- -----    ----------- --------  -------
1  Job1  BackgroundJob Complete True        localhost Get-Process
2  Job2  BackgroundJob Running  True        localhost Get-EventLog -Log ...
3  Job3  BackgroundJob Complete True        localhost dir -Path C:\* -Re...
```

В этом случае свойство **State** показывает, что задание 2 все еще выполняется. Если вы использовали `Receive-Job` командлет для получения результатов задания прямо сейчас, результаты будут неполными. Можно `Receive-Job` многократно использовать командлет для получения всех результатов. Чтобы определить, когда задание завершено, используйте свойство **State** .

Можно также использовать параметр **Wait** `Receive-Job` командлета. При использовании этого параметра командлет не возвращает командную строку, пока задание не будет завершено и все результаты будут доступны.

Можно также использовать `Wait-Job` командлет для ожидания любого или всех результатов задания. `Wait-Job` позволяет ожидать одно или несколько конкретных заданий или всех заданий.
Следующая команда использует `Wait-Job` командлет для ожидания задания с **идентификатором** .
10.

```powershell
Wait-Job -ID 10
```

В результате Командная строка PowerShell подавляется до завершения задания.

Можно также дождаться заранее определенного периода времени. Эта команда использует параметр **timeout** , чтобы ограничить время ожидания 120 секунд. По истечении этого времени Командная строка возвращает значение, но задание продолжит выполняться в фоновом режиме.

```powershell
Wait-Job -ID 10 -Timeout 120
```

## <a name="stopping-a-job"></a>Остановка задания

Чтобы прерывать фоновое задание, используйте `Stop-Job` командлет. Следующая команда запускает задание для получения каждой записи в журнале системных событий. Объект задания сохраняется в `$job` переменной.

```powershell
$job = Start-Job -ScriptBlock {Get-EventLog -Log System}
```

Следующая команда останавливает задание. Он использует оператор конвейера ( `|` ) для отправки задания в переменной в `$job` `Stop-Job` .

```powershell
$job | Stop-Job
```

## <a name="deleting-a-job"></a>Удаление задания

Чтобы удалить фоновое задание, используйте `Remove-Job` командлет. Следующая команда удаляет задание в `$job` переменной.

```powershell
Remove-Job -Job $job
```

## <a name="investigating-a-failed-job"></a>Исследование невыполненного задания

Задания могут завершаться сбоем по многим причинам. Объект задания содержит свойство **Reason** , содержащее сведения о причине сбоя.

В следующем примере запускается задание без требуемых учетных данных.

```powershell
$job = Start-Job -ScriptBlock {New-Item -Path HKLM:\Software\MyCompany}
Get-Job $job

Id Name  PSJobTypeName State  HasMoreData  Location  Command
-- ----  ------------- -----  -----------  --------  -------
1  Job1  BackgroundJob Failed False        localhost New-Item -Path HKLM:...
```

Проверьте свойство **Reason** , чтобы найти ошибку, вызвавшую сбой задания.

```powershell
$job.ChildJobs[0].JobStateInfo.Reason
```

В этом случае задание завершилось сбоем, так как удаленный компьютер требует явных учетных данных для выполнения команды. Свойство **Reason** содержит следующее сообщение:

> Сбой подключения к удаленному серверу со следующим сообщением об ошибке: "отказано в доступе".

## <a name="see-also"></a>См. также раздел

- [about_Remote_Jobs](about_Remote_Jobs.md)
- [about_Thread_Jobs](/powershell/module/microsoft.powershell.core/about/about_Thread_Jobs)
- [about_Job_Details](about_Job_Details.md)
- [about_Remote](about_Remote.md)
- [about_PSSessions](about_PSSessions.md)
- [Start-Job](xref:Microsoft.PowerShell.Core.Start-Job)
- [Get-Job.](xref:Microsoft.PowerShell.Core.Get-Job)
- [Receive-Job.](xref:Microsoft.PowerShell.Core.Receive-Job)
- [Stop-Job.](xref:Microsoft.PowerShell.Core.Stop-Job)
- [Wait-Job](xref:Microsoft.PowerShell.Core.Wait-Job)
- [Remove-Job](xref:Microsoft.PowerShell.Core.Remove-Job)
- [Invoke-Command](xref:Microsoft.PowerShell.Core.Invoke-Command)
