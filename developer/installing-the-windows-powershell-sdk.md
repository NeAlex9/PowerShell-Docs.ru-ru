---
title: Установка пакета SDK для Windows PowerShell
ms.date: 09/13/2016
ms.topic: article
ms.openlocfilehash: da1b3dbb8a599aee2cdbab9115aedcab0b4c78c9
ms.sourcegitcommit: e7445ba8203da304286c591ff513900ad1c244a4
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "62082487"
---
# <a name="installing-the-windows-powershell-sdk"></a>Установка пакета SDK для Windows PowerShell

Область применения. Windows PowerShell 2.0, Windows PowerShell 3.0

В следующей статье описывается, как установить пакет PowerShell SDK на разные версии Windows.

## <a name="installing-windows-powershell-30-sdk-for-windows-8-and-windows-server-2012"></a>Установка пакета SDK для Windows PowerShell 3.0 в Windows 8 и Windows Server 2012

Windows PowerShell 3.0 устанавливается автоматически вместе с Windows 8 и Windows Server 2012. Вы также можете скачать и установить ссылочные сборки для Windows PowerShell 3.0 в составе Windows 8 SDK. Эти сборки позволяют написать командлеты, поставщики и ведущие программы для Windows PowerShell 3.0. При установке Windows SDK для Windows 8 сборки Windows PowerShell автоматически устанавливаются в папку ссылочной сборки, в "\Program Files (x86)\Reference Assemblies\Microsoft\WindowsPowerShell\3.0". Дополнительные сведения см. в разделе пакет SDK для Windows 8 сайт загрузки. Примеры кода Windows PowerShell также доступны в Центре разработки.
Дополнительные сведения см. на странице примеров кода классических на сайте центра разработки.

Кроме того, Windows PowerShell 3.0 обратно совместим с Windows PowerShell 2.0 SDK, в который входит ряд примеров кода. Дополнительные сведения о том, как скачать Windows PowerShell 2.0 SDK, см. ниже. (Обратите внимание, что, хотя примеры кода 2.0 совместимы с Windows 8 и Windows PowerShell 3.0, невозможно установить Windows PowerShell 2.0 на платформу Windows 8.)

## <a name="installing-windows-powershell-30-sdk-for-windows-7-and-windows-server-2008-r2"></a>Установка пакета SDK для Windows PowerShell 3.0 в Windows 7 и Windows Server 2008 R2

Вместе с Windows 7 и Windows Server 2008 R2 автоматически устанавливается PowerShell 2.0. Вы также можете установить PowerShell 3.0 в этих системах. (Дополнительные сведения см. в разделе Установка Windows PowerShell.). Как описано выше, вы также можете установить Windows 8 SDK на Windows 7 и Windows Server 2008 R2.

## <a name="installing-windows-powershell-20-sdk-for-windows-7-vista-xp-server-2003-and-server-2008"></a>Установка пакета SDK для Windows PowerShell 2.0 в Windows 7, Windows Vista, Windows XP, Windows Server 2003 и Windows Server 2008

Установка пакета SDK для Windows PowerShell 2.0 предоставляет эталонные сборки, необходимые для написания командлетов, поставщиков и ведущих приложений, а также пример кода C#, который можно использовать в качестве начальной точки при написании кода.

Чтобы установить этот пакет SDK, см. в разделе Windows PowerShell 2.0 SDK.

### <a name="reference-assemblies"></a>Эталонные сборки

Ссылочные сборки устанавливаются в следующий каталог по умолчанию: c:\Program Files\Reference Assemblies\Microsoft\WindowsPowerShell\V1.0.

> [!NOTE]
>
> Код, который компилируется с использованием сборок Windows PowerShell 2.0, нельзя загрузить в установках Windows PowerShell 1.0. Но код, который компилируется в сборках Windows PowerShell 1.0, можно загрузить в установках Windows PowerShell 2.0.


### <a name="samples"></a>примеры

Примеры кода устанавливаются в следующий каталог по умолчанию: C:\Program Files\Microsoft SDKs\Windows\v7.0\Samples\sysmgmt\WindowsPowerShell\. В следующих разделах приводится краткое описание каждого примера.

#### <a name="cmdlet-samples"></a>Примеры командлетов

- GetProcessSample01 - показано, как написать простой командлет, который получает все процессы на локальном компьютере.
- GetProcessSample02 - показано, как добавить параметры в командлет. Командлет принимает одно или несколько имен процессов и возвращает соответствующие процессы.
- GetProcessSample03 - показано, как добавить параметры, которые принимают входные данные из конвейера.
- GetProcessSample04 - показано, как обрабатывать устранимые ошибки.
- GetProcessSample05 - показано, как отобразить список указанных процессов.
- SelectObject - показано, как написать фильтр, позволяющий отобрать только определенные объекты.
- SelectString - показано, как искать в файлах указанных шаблонов.
- StopProcessSample01 - показано, как реализовать параметр PassThru и как запросить отзывы пользователей вызовами методов ShouldProcess и ShouldContinue. Пользователи указывать параметр PassThru, когда пользователь хочет заставить командлет вернуть объект,
- StopProcessSample02 - показано, как остановить определенный процесс.
- StopProcessSample03 - показано, как объявить псевдонимы для параметров и поддерживает подстановочные знаки.
- StopProcessSample04 - показано, как объявлять набор параметров, объект, который командлет принимает в качестве входных данных и способы указания параметра по умолчанию, настроенный для использования.

#### <a name="remoting-samples"></a>Примеры удаленного взаимодействия

- RemoteRunspace01 - показано, как создавать удаленное пространство выполнения, который используется для удаленного подключения.
- RemoteRunspacePool01 - показано, как создать пул удаленных пространств выполнения и одновременного выполнения нескольких команд с помощью этого пула.
- Serialization01 - показано, как проанализировать существующий класс .NET и убедитесь, что информация из определенных открытых свойств этого класса сохранялась в сериализации/десериализации.
- Serialization02 - показано, как проанализировать существующий класс .NET и убедитесь, что, сведения из экземпляра этого класса сохранялась в сериализации/десериализации при данные еще не недоступна в открытых свойствах класса.
- Serialization03 - показано, как проанализировать существующий класс .NET и убедитесь, что экземпляры этого класса и производных классов десериализуются (извлечены) в динамические объекты .NET.

#### <a name="event-samples"></a>Примеры событий

- Event01 - показано, как создать командлет для регистрации событий, наследуя от ObjectEventRegistrationBase.
- Event02 - показано, как в показано, как получать уведомления о событиях Windows PowerShell, которые создаются на удаленных компьютерах. Она использует событие PSEventReceived через класс пространства выполнения.

#### <a name="hosting-application-samples"></a>Примеры размещения приложений

- Runspace01 - показано, как использовать класс PowerShell для запуска `Get-Process` командлет синхронно.
`Get-Process` Командлет возвращает объекты процессов для каждого процесса, запущенного на локальном компьютере.
- Runspace02 - показано, как использовать класс PowerShell для запуска `Get-Process` и `Sort-Object` командлеты синхронно. `Get-Process` Командлет возвращает объекты процессов для каждого процесса, запущенного на локальном компьютере и `Sort-Object` сортирует объекты на основе их идентификатор свойства. Результаты этих команд отображаются с помощью элемента управления DataGridView.
- Runspace03 - показано, как использовать класс PowerShell для синхронного запуска скрипта и как обрабатывать устранимые ошибки. Скрипт получает список имен процессов, а затем извлекает эти процессы. Результаты выполнения скрипта, включая вызванные им устранимые ошибки, отображаются в окне консоли.
- Runspace04 - показано, как использовать класс PowerShell для выполнения команд и как перехватить ошибки, возникающие при выполнении команды завершения. Выполняются две команды, и последняя получает недопустимый аргумент параметра. В результате объекты не возвращаются и создается неустранимая ошибка.
- Runspace05 - показано, как добавить оснастку в объект InitialSessionState, чтобы командлет оснастки был доступен при открытии пространства выполнения. Оснастка предоставляет командлет Get-Proc (определенный в образце GetProcessSample01), который запускается синхронно с помощью объекта PowerShell.
- Runspace06 - показано, как добавить модуль в объект InitialSessionState таким образом, чтобы модуль был загружен при открытии пространства выполнения. Модуль предоставляет командлет Get-Proc (определенный в образце GetProcessSample02), который запускается синхронно с помощью объекта PowerShell.
- Runspace07 - показано, как создать пространство выполнения, а затем использовать его для синхронного запуска двух командлетов с помощью объекта PowerShell.
- Runspace08 - показано, как добавить команды и аргументы в конвейер объект PowerShell и запустить команды синхронно.
- Runspace09 - показано, как добавить скрипт в конвейер объект PowerShell и запустить скрипт асинхронно. События используются для обработки выходных данных скрипта.
- Runspace10 - показано, как создать состояние исходного сеанса по умолчанию, как добавить командлет в InitialSessionState, как создать пространство выполнения с использованием начального состояния сеанса и как для выполнения команды с помощью объекта PowerShell.
- Runspace11 - показано, как использовать класс ProxyCommand для создания прокси-команды, которая вызывает существующий командлет, но ограничивает набор доступных параметров. Прокси-команда затем добавляется в начальное состояние сеанса, который используется для создания ограниченного пространства выполнения. Это означает, что пользователь может получить доступ к функциям командлета только с помощью прокси-команды.
- PowerShell01 - показано, как создать ограниченное пространство выполнения с помощью объекта InitialSessionState.
- PowerShell02 - показано, как использовать пул пространств выполнения для одновременного выполнения нескольких команд.

#### <a name="host-samples"></a>Примеры узлов

- Host01 - показано, как реализовать ведущее приложение, которое использует пользовательский узел. В этом примере создается пространство выполнения, который использует пользовательский узел, а затем PowerShell API используется для запуска сценария, который вызывает «exit». Затем ведущее приложение анализирует выходные данные скрипта и выводит на экран результаты.
- Host02 - показано, как написать ведущее приложение, использующее среду выполнения Windows PowerShell вместе с реализацией пользовательского узла. Ведущее приложение задает в качестве региональных параметров немецкий язык, запускает `Get-Process` командлета и отображает результаты в виде вы отобразились бы при использовании pwrsh.exe, а затем выводит текущие дату и время на немецком языке.
- Host03 - показано, как сборку интерактивного консольного ведущего приложения, читает команды из командной строки, выполняет команды и затем отображает результаты на консоль.
- Host04 - показано, как сборку интерактивного консольного ведущего приложения, читает команды из командной строки, выполняет команды и затем отображает результаты на консоль. Это приложение также поддерживает отображение запросов, позволяющих пользователю выбрать несколько вариантов.
- Узел05 - показано, как сборку интерактивного консольного ведущего приложения, читает команды из командной строки, выполняет команды и затем отображает результаты на консоль. Это ведущее приложение также поддерживает вызовы удаленных компьютеров с помощью `Enter-PsSession` и `Exit-PsSession` командлетов.
- Host06 - показано, как сборку интерактивного консольного ведущего приложения, читает команды из командной строки, выполняет команды и затем отображает результаты на консоль. Кроме того, в этом примере используются интерфейсы API создателя токенов для указания цвета текста, вводимого пользователем.

#### <a name="provider-samples"></a>Примеры поставщиков

- AccessDBProviderSample01 - показано, как объявить класс поставщика, производный непосредственно от класса CmdletProvider. Он приводится здесь только для полноты картины.

- AccessDBProviderSample02 - показано, как перезаписать методы NewDrive и RemoveDrive, для поддержки вызовов в `New-PSDrive` и `Remove-PSDrive` командлетов. Класс поставщика в этом примере является производным от класса DriveCmdletProvider.

- AccessDBProviderSample03 - показано, как перезаписать методы GetItem и SetItem, для поддержки вызовов в `Get-Item` и `Set-Item` командлетов. Класс поставщика в этом примере является производным от класса ItemCmdletProvider.

- AccessDBProviderSample04 - показано, как перезаписать методы контейнера для поддержки вызовов в `Copy-Item`, `Get-ChildItem`, `New-Item`, и `Remove-Item` командлетов. Эти методы должны быть реализованы, когда хранилище данных содержит элементы, являющиеся контейнерами. Контейнер — это группа дочерних элементов в составе общего родительского элемента. Класс поставщика в этом примере является производным от класса ItemCmdletProvider.

- AccessDBProviderSample05 - показано, как перезаписать методы контейнера для поддержки вызовов в `Move-Item` и `Join-Path` командлетов. Эти методы должны быть реализованы, когда пользователю требуется переместить элементы в контейнере, если хранилище данных содержит вложенные контейнеры. Класс поставщика в этом примере является производным от класса NavigationCmdletProvider.

- AccessDBProviderSample06 - показано, как перезаписать методы содержимого для поддержки вызовов в `Clear-Content`, `Get-Content`, и `Set-Content` командлетов. Эти методы должны быть реализованы, когда пользователю требуется управлять содержимым элементов в хранилище данных. Класс поставщика в этом примере является производным от класса NavigationCmdletProvider, и он реализует интерфейс IContentCmdletProvider.
