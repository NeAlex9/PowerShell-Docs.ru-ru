---
title: Создание контейнера поставщика Windows PowerShell | Документация Майкрософт
ms.custom: ''
ms.date: 09/13/2016
ms.reviewer: ''
ms.suite: ''
ms.tgt_pltfrm: ''
ms.topic: article
helpviewer_keywords:
- providers [PowerShell Programmer's Guide], container provider
- container providers [PowerShell Programmer's Guide]
ms.assetid: a7926647-0d18-45b2-967e-b31f92004bc4
caps.latest.revision: 5
ms.openlocfilehash: 33effed9a96cf1b9ee5f1a50b60a1937526db9d1
ms.sourcegitcommit: caac7d098a448232304c9d6728e7340ec7517a71
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/16/2019
ms.locfileid: "58055025"
---
# <a name="creating-a-windows-powershell-container-provider"></a><span data-ttu-id="d8740-102">Создание поставщика контейнеров Windows PowerShell</span><span class="sxs-lookup"><span data-stu-id="d8740-102">Creating a Windows PowerShell Container Provider</span></span>

<span data-ttu-id="d8740-103">В этом разделе описывается создание поставщика Windows PowerShell, которая может работать в хранилищах данных многоуровневой.</span><span class="sxs-lookup"><span data-stu-id="d8740-103">This topic describes how to create a Windows PowerShell provider that can work on multi-layer data stores.</span></span> <span data-ttu-id="d8740-104">Для этого типа хранилища данных верхнем уровне хранилища содержит корневых элементов, и каждый последующий уровень называется узлом дочерних элементов.</span><span class="sxs-lookup"><span data-stu-id="d8740-104">For this type of data store, the top level of the store contains the root items and each subsequent level is referred to as a node of child items.</span></span> <span data-ttu-id="d8740-105">Позволяя пользователям работать на эти дочерние узлы, пользователь может иерархически взаимодействовать через хранилище данных.</span><span class="sxs-lookup"><span data-stu-id="d8740-105">By allowing the user to work on these child nodes, a user can interact hierarchically through the data store.</span></span>

<span data-ttu-id="d8740-106">Поставщики, которые могут работать в хранилищах многоуровневыми данными, называются контейнера поставщиков Windows PowerShell.</span><span class="sxs-lookup"><span data-stu-id="d8740-106">Providers that can work on multi-level data stores are referred to as Windows PowerShell container providers.</span></span> <span data-ttu-id="d8740-107">Однако имейте в виду, что поставщик контейнеров Windows PowerShell может использоваться только в том случае, если имеется один контейнер (не вложенные контейнеры) с элементами в его.</span><span class="sxs-lookup"><span data-stu-id="d8740-107">However, be aware that a Windows PowerShell container provider can be used only when there is one container (no nested containers) with items in it.</span></span> <span data-ttu-id="d8740-108">Если имеются вложенные контейнеры, необходимо реализовать поставщик навигации Windows PowerShell.</span><span class="sxs-lookup"><span data-stu-id="d8740-108">If there are nested containers, then you must implement a Windows PowerShell navigation provider.</span></span> <span data-ttu-id="d8740-109">Дополнительные сведения о реализации поставщик навигации Windows PowerShell см. в разделе [Создание поставщика Windows PowerShell навигации](./creating-a-windows-powershell-navigation-provider.md).</span><span class="sxs-lookup"><span data-stu-id="d8740-109">For more information about implementing Windows PowerShell navigation provider, see [Creating a Windows PowerShell Navigation Provider](./creating-a-windows-powershell-navigation-provider.md).</span></span>

> [!NOTE]
> <span data-ttu-id="d8740-110">Вы можете скачать C# исходный файл (AccessDBSampleProvider04.cs) для данного поставщика, с помощью Microsoft Windows программное обеспечение Development Kit для Windows Vista и компоненты среды выполнения .NET Framework 3.0.</span><span class="sxs-lookup"><span data-stu-id="d8740-110">You can download the C# source file (AccessDBSampleProvider04.cs) for this provider using the Microsoft Windows Software Development Kit for Windows Vista and .NET Framework 3.0 Runtime Components.</span></span> <span data-ttu-id="d8740-111">Инструкции по загрузке см. в разделе [как установка Windows PowerShell и загрузки пакета SDK для Windows PowerShell](/powershell/developer/installing-the-windows-powershell-sdk).</span><span class="sxs-lookup"><span data-stu-id="d8740-111">For download instructions, see [How to Install Windows PowerShell and Download the Windows PowerShell SDK](/powershell/developer/installing-the-windows-powershell-sdk).</span></span>
>
> <span data-ttu-id="d8740-112">Скачанный исходные файлы доступны в  **\<примеры PowerShell >** каталога.</span><span class="sxs-lookup"><span data-stu-id="d8740-112">The downloaded source files are available in the **\<PowerShell Samples>** directory.</span></span>
>
> <span data-ttu-id="d8740-113">Дополнительные сведения о других реализаций поставщика Windows PowerShell, см. в разделе [проектирование ваш поставщик PowerShell Windows](./designing-your-windows-powershell-provider.md).</span><span class="sxs-lookup"><span data-stu-id="d8740-113">For more information about other Windows PowerShell provider implementations, see [Designing Your Windows PowerShell Provider](./designing-your-windows-powershell-provider.md).</span></span>

<span data-ttu-id="d8740-114">Поставщик контейнеров Windows PowerShell, описанные здесь определяет базу данных в качестве ее единый контейнер, в таблицах и строках базы данных, определяемый как элементы контейнера.</span><span class="sxs-lookup"><span data-stu-id="d8740-114">The Windows PowerShell container provider described here defines the database as its single container, with the tables and rows of the database defined as items of the container.</span></span>

> [!CAUTION]
> <span data-ttu-id="d8740-115">Имейте в виду, что такой подход предполагает базу, которая содержит поле с именем Идентификатором и типом поля является LongInteger.</span><span class="sxs-lookup"><span data-stu-id="d8740-115">Be aware that this design assumes a database that has a field with the name ID, and that the type of the field is LongInteger.</span></span>

<span data-ttu-id="d8740-116">Ниже приведен список разделов этой статьи.</span><span class="sxs-lookup"><span data-stu-id="d8740-116">Here is a list of the sections in this topic.</span></span> <span data-ttu-id="d8740-117">Если вы не знакомы с разработка контейнера поставщика Windows PowerShell, прочтите эту информацию в порядке, в котором он отображается.</span><span class="sxs-lookup"><span data-stu-id="d8740-117">If you are unfamiliar with writing a Windows PowerShell container provider, please read this information in the order that it appears.</span></span> <span data-ttu-id="d8740-118">Тем не менее если вы знакомы с разработка контейнера поставщика Windows PowerShell, перейдите непосредственно к сведениям, вам потребуется.</span><span class="sxs-lookup"><span data-stu-id="d8740-118">However, if you are familiar with writing a Windows PowerShell container provider, please go directly to the information that you need.</span></span>

- [<span data-ttu-id="d8740-119">Определение класса поставщика контейнера Windows PowerShell</span><span class="sxs-lookup"><span data-stu-id="d8740-119">Defining a Windows PowerShell Container Provider Class</span></span>](#Defining-a-Windows-PowerShell-Container-Provider-Class)

- [<span data-ttu-id="d8740-120">Определение базовой функциональности</span><span class="sxs-lookup"><span data-stu-id="d8740-120">Defining Base Functionality</span></span>](#defining-base-functionality)

- [<span data-ttu-id="d8740-121">Получение дочерних элементов</span><span class="sxs-lookup"><span data-stu-id="d8740-121">Retrieving Child Items</span></span>](#Retrieving-Child-Items)

- [<span data-ttu-id="d8740-122">Присоединение динамических параметров в `Get-ChildItem` командлета</span><span class="sxs-lookup"><span data-stu-id="d8740-122">Attaching Dynamic Parameters to the `Get-ChildItem` Cmdlet</span></span>](#Attaching-Dynamic-Parameters-to-the-Get-ChildItem-Cmdlet)

- [<span data-ttu-id="d8740-123">Получение имен дочерних элементов</span><span class="sxs-lookup"><span data-stu-id="d8740-123">Retrieving Child Item Names</span></span>](#Retrieving-Child-Item-Names)

- <span data-ttu-id="d8740-124">[Присоединение динамических параметров в `Get-ChildItem` командлет (имя)](#Attaching-Dynamic-Parameters-to-the-Get-ChildItem-Cmdlet-(Name))</span><span class="sxs-lookup"><span data-stu-id="d8740-124">[Attaching Dynamic Parameters to the `Get-ChildItem` Cmdlet (Name)](#Attaching-Dynamic-Parameters-to-the-Get-ChildItem-Cmdlet-(Name))</span></span>

- [<span data-ttu-id="d8740-125">Переименование элементов</span><span class="sxs-lookup"><span data-stu-id="d8740-125">Renaming Items</span></span>](#Renaming-Items)

- [<span data-ttu-id="d8740-126">Присоединение динамических параметров в `Rename-Item` командлета</span><span class="sxs-lookup"><span data-stu-id="d8740-126">Attaching Dynamic Parameters to the  `Rename-Item` Cmdlet</span></span>](#Attaching-Dynamic-Parameters-to-the-Rename-Item-Cmdlet)

- [<span data-ttu-id="d8740-127">Создание новых элементов</span><span class="sxs-lookup"><span data-stu-id="d8740-127">Creating New Items</span></span>](#Creating-New-Items)

- [<span data-ttu-id="d8740-128">Присоединение динамических параметров в `New-Item` командлета</span><span class="sxs-lookup"><span data-stu-id="d8740-128">Attaching Dynamic Parameters to the `New-Item` Cmdlet</span></span>](#Attaching-Dynamic-Parameters-to-the-New-Item-Cmdlet)

- [<span data-ttu-id="d8740-129">Удаление элементов</span><span class="sxs-lookup"><span data-stu-id="d8740-129">Removing a Items</span></span>](#Removing-Items)

- [<span data-ttu-id="d8740-130">Присоединение динамических параметров в `Remove-Item` командлета</span><span class="sxs-lookup"><span data-stu-id="d8740-130">Attaching Dynamic Parameters to the `Remove-Item` Cmdlet</span></span>](#Attaching-Dynamic-Parameters-to-the-Remove-Item-Cmdlet)

- [<span data-ttu-id="d8740-131">Запрос для дочерних элементов</span><span class="sxs-lookup"><span data-stu-id="d8740-131">Querying for Child Items</span></span>](#Querying-for-Child-Items)

- [<span data-ttu-id="d8740-132">Копирование элементов</span><span class="sxs-lookup"><span data-stu-id="d8740-132">Coping Items</span></span>](#Copying-Items)

- [<span data-ttu-id="d8740-133">Присоединение динамических параметров в `Copy-Item` командлета</span><span class="sxs-lookup"><span data-stu-id="d8740-133">Attaching Dynamic Parameters to the  `Copy-Item` Cmdlet</span></span>](#Attaching-Dynamic-Parameters-to-the-Copy-Item-Cmdlet)

- [<span data-ttu-id="d8740-134">Пример кода</span><span class="sxs-lookup"><span data-stu-id="d8740-134">Code Sample</span></span>](#Code-Sample)

- [<span data-ttu-id="d8740-135">Создание поставщика Windows PowerShell</span><span class="sxs-lookup"><span data-stu-id="d8740-135">Building the Windows PowerShell Provider</span></span>](#Building-the-Windows-PowerShell-Provider)

- [<span data-ttu-id="d8740-136">Проверка поставщика в Windows PowerShell</span><span class="sxs-lookup"><span data-stu-id="d8740-136">Testing the Windows PowerShell Provider</span></span>](#Testing-the-Windows-PowerShell-Provider)

## <a name="defining-a-windows-powershell-container-provider-class"></a><span data-ttu-id="d8740-137">Определение класса поставщика контейнера Windows PowerShell</span><span class="sxs-lookup"><span data-stu-id="d8740-137">Defining a Windows PowerShell Container Provider Class</span></span>

<span data-ttu-id="d8740-138">Поставщик контейнеров Windows PowerShell необходимо определить класс .NET, который является производным от [System.Management.Automation.Provider.Containercmdletprovider](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider) базового класса.</span><span class="sxs-lookup"><span data-stu-id="d8740-138">A Windows PowerShell container provider must define a .NET class that derives from the [System.Management.Automation.Provider.Containercmdletprovider](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider) base class.</span></span> <span data-ttu-id="d8740-139">Вот определение класса для поставщика контейнера Windows PowerShell, описанные в этом разделе.</span><span class="sxs-lookup"><span data-stu-id="d8740-139">Here is the class definition for the Windows PowerShell container provider described in this section.</span></span>

```csharp
   [CmdletProvider("AccessDB", ProviderCapabilities.None)]
   public class AccessDBProvider : ContainerCmdletProvider
```

[!code-csharp[AccessDBProviderSample04.cs](../../powershell-sdk-samples/SDK-2.0/csharp/AccessDBProviderSample04/AccessDBProviderSample04.cs#L34-L35 "AccessDBProviderSample04.cs")]

<span data-ttu-id="d8740-140">Обратите внимание, что в это определение класса [System.Management.Automation.Provider.Cmdletproviderattribute](/dotnet/api/System.Management.Automation.Provider.CmdletProviderAttribute) атрибут содержит два параметра.</span><span class="sxs-lookup"><span data-stu-id="d8740-140">Notice that in this class definition, the [System.Management.Automation.Provider.Cmdletproviderattribute](/dotnet/api/System.Management.Automation.Provider.CmdletProviderAttribute) attribute includes two parameters.</span></span> <span data-ttu-id="d8740-141">Первый параметр указывает понятное имя для поставщика, который используется Windows PowerShell.</span><span class="sxs-lookup"><span data-stu-id="d8740-141">The first parameter specifies a user-friendly name for the provider that is used by Windows PowerShell.</span></span> <span data-ttu-id="d8740-142">Второй параметр указывает специальной совместимости с Windows PowerShell, которые предоставляет поставщик среды выполнения Windows PowerShell во время обработки команды.</span><span class="sxs-lookup"><span data-stu-id="d8740-142">The second parameter specifies the Windows PowerShell specific capabilities that the provider exposes to the Windows PowerShell runtime during command processing.</span></span> <span data-ttu-id="d8740-143">Для этого поставщика нет конкретных возможности Windows PowerShell, которые добавляются.</span><span class="sxs-lookup"><span data-stu-id="d8740-143">For this provider, there are no Windows PowerShell specific capabilities that are added.</span></span>

## <a name="defining-base-functionality"></a><span data-ttu-id="d8740-144">Определение базовой функциональности</span><span class="sxs-lookup"><span data-stu-id="d8740-144">Defining Base Functionality</span></span>

<span data-ttu-id="d8740-145">Как описано в разделе [проектирование ваш поставщик PowerShell Windows](./designing-your-windows-powershell-provider.md), [System.Management.Automation.Provider.Containercmdletprovider](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider) класс является производным от несколько других классов, которые предоставлены функциональные возможности другого поставщика.</span><span class="sxs-lookup"><span data-stu-id="d8740-145">As described in [Designing Your Windows PowerShell Provider](./designing-your-windows-powershell-provider.md), the [System.Management.Automation.Provider.Containercmdletprovider](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider) class derives from several other classes that provided different provider functionality.</span></span> <span data-ttu-id="d8740-146">Поставщик контейнеров Windows PowerShell, таким образом, необходимо определить все функциональные возможности, предоставляемые этими классами.</span><span class="sxs-lookup"><span data-stu-id="d8740-146">A Windows PowerShell container provider, therefore, needs to define all of the functionality provided by those classes.</span></span>

<span data-ttu-id="d8740-147">Чтобы реализовать функциональные возможности для добавления сведений инициализации сеанса, а также для освобождения ресурсов, которые используются поставщиком, см. в разделе [создание является базовым поставщиком Windows PowerShell](./creating-a-basic-windows-powershell-provider.md).</span><span class="sxs-lookup"><span data-stu-id="d8740-147">To implement functionality for adding session-specific initialization information and for releasing resources that are used by the provider, see [Creating a Basic Windows PowerShell Provider](./creating-a-basic-windows-powershell-provider.md).</span></span> <span data-ttu-id="d8740-148">Тем не менее большинство поставщиков (включая поставщика, описанные здесь) можно использовать реализацию по умолчанию эта функция, предоставляемая Windows PowerShell.</span><span class="sxs-lookup"><span data-stu-id="d8740-148">However, most providers (including the provider described here) can use the default implementation of this functionality that is provided by Windows PowerShell.</span></span>

<span data-ttu-id="d8740-149">Чтобы получить доступ к хранилищу данных, поставщик должен реализовывать методы [System.Management.Automation.Provider.Drivecmdletprovider](/dotnet/api/System.Management.Automation.Provider.DriveCmdletProvider) базового класса.</span><span class="sxs-lookup"><span data-stu-id="d8740-149">To get access to the data store, the provider must implement the methods of the [System.Management.Automation.Provider.Drivecmdletprovider](/dotnet/api/System.Management.Automation.Provider.DriveCmdletProvider) base class.</span></span> <span data-ttu-id="d8740-150">Дополнительные сведения о реализации этих методов см. в разделе [Создание поставщика диска Windows PowerShell](./creating-a-windows-powershell-drive-provider.md).</span><span class="sxs-lookup"><span data-stu-id="d8740-150">For more information about implementing these methods, see [Creating an Windows PowerShell Drive Provider](./creating-a-windows-powershell-drive-provider.md).</span></span>

<span data-ttu-id="d8740-151">Для работы с элементами в хранилище данных, например начало, параметр и очистка элементов, поставщик должен реализовывать методы, предоставленные [System.Management.Automation.Provider.Itemcmdletprovider](/dotnet/api/System.Management.Automation.Provider.ItemCmdletProvider) базового класса.</span><span class="sxs-lookup"><span data-stu-id="d8740-151">To manipulate the items of a data store, such as getting, setting, and clearing items, the provider must implement the methods provided by the [System.Management.Automation.Provider.Itemcmdletprovider](/dotnet/api/System.Management.Automation.Provider.ItemCmdletProvider) base class.</span></span> <span data-ttu-id="d8740-152">Дополнительные сведения о реализации этих методов см. в разделе [Создание поставщика Windows PowerShell элемента](./creating-a-windows-powershell-item-provider.md).</span><span class="sxs-lookup"><span data-stu-id="d8740-152">For more information about implementing these methods, see [Creating an Windows PowerShell Item Provider](./creating-a-windows-powershell-item-provider.md).</span></span>

## <a name="retrieving-child-items"></a><span data-ttu-id="d8740-153">Получение дочерних элементов</span><span class="sxs-lookup"><span data-stu-id="d8740-153">Retrieving Child Items</span></span>

<span data-ttu-id="d8740-154">Для получения дочернего элемента, поставщик контейнеров Windows PowerShell необходимо переопределить [System.Management.Automation.Provider.Containercmdletprovider.Getchilditems\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.GetChildItems) метод для поддержки вызовов из `Get-ChildItem` командлета.</span><span class="sxs-lookup"><span data-stu-id="d8740-154">To retrieve a child item, the Windows PowerShell container provider must override the [System.Management.Automation.Provider.Containercmdletprovider.Getchilditems\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.GetChildItems) method to support calls from the `Get-ChildItem` cmdlet.</span></span> <span data-ttu-id="d8740-155">Этот метод извлекает дочерние элементы из хранилища данных и записывает их в конвейер, как объекты.</span><span class="sxs-lookup"><span data-stu-id="d8740-155">This method retrieves child items from the data store and writes them to the pipeline as objects.</span></span> <span data-ttu-id="d8740-156">Если `recurse` указан параметр командлета, этот метод извлекает все дочерние элементы, независимо от того, какой уровень, они состоятся.</span><span class="sxs-lookup"><span data-stu-id="d8740-156">If the `recurse` parameter of the cmdlet is specified, the method retrieves all children regardless of what level they are at.</span></span> <span data-ttu-id="d8740-157">Если `recurse` параметр не указан, этот метод извлекает только один уровень дочерних элементов.</span><span class="sxs-lookup"><span data-stu-id="d8740-157">If the `recurse` parameter is not specified, the method retrieves only a single level of children.</span></span>

<span data-ttu-id="d8740-158">Вот реализация [System.Management.Automation.Provider.Containercmdletprovider.Getchilditems\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.GetChildItems) метода для данного поставщика.</span><span class="sxs-lookup"><span data-stu-id="d8740-158">Here is the implementation of the [System.Management.Automation.Provider.Containercmdletprovider.Getchilditems\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.GetChildItems) method for this provider.</span></span> <span data-ttu-id="d8740-159">Обратите внимание на то, что этот метод получает дочерние элементы во всех таблицах базы данных, когда путь указывает базы данных Access, а также получает дочерние элементы из строки этой таблицы, если путь указывает на таблицу данных.</span><span class="sxs-lookup"><span data-stu-id="d8740-159">Notice that this method retrieves the child items in all database tables when the path indicates the Access database, and retrieves the child items from the rows of that table if the path indicates a data table.</span></span>

```csharp
protected override void GetChildItems(string path, bool recurse)
{
    // If path represented is a drive then the children in the path are
    // tables. Hence all tables in the drive represented will have to be
    // returned
    if (PathIsDrive(path))
    {
        foreach (DatabaseTableInfo table in GetTables())
        {
            WriteItemObject(table, path, true);

            // if the specified item exists and recurse has been set then
            // all child items within it have to be obtained as well
            if (ItemExists(path) && recurse)
            {
                GetChildItems(path + pathSeparator + table.Name, recurse);
            }
        } // foreach (DatabaseTableInfo...
    } // if (PathIsDrive...
    else
    {
        // Get the table name, row number and type of path from the
        // path specified
        string tableName;
        int rowNumber;

        PathType type = GetNamesFromPath(path, out tableName, out rowNumber);

        if (type == PathType.Table)
        {
            // Obtain all the rows within the table
            foreach (DatabaseRowInfo row in GetRows(tableName))
            {
                WriteItemObject(row, path + pathSeparator + row.RowNumber,
                        false);
            } // foreach (DatabaseRowInfo...
        }
        else if (type == PathType.Row)
        {
            // In this case the user has directly specified a row, hence
            // just give that particular row
            DatabaseRowInfo row = GetRow(tableName, rowNumber);
            WriteItemObject(row, path + pathSeparator + row.RowNumber,
                        false);
        }
        else
        {
            // In this case, the path specified is not valid
            ThrowTerminatingInvalidPathException(path);
        }
    } // else
} // GetChildItems
```

[!code-csharp[AccessDBProviderSample04.cs](../../powershell-sdk-samples/SDK-2.0/csharp/AccessDBProviderSample04/AccessDBProviderSample04.cs#L311-L362 "AccessDBProviderSample04.cs")]

#### <a name="things-to-remember-about-implementing-getchilditems"></a><span data-ttu-id="d8740-160">О чем следует помнить о реализации GetChildItems</span><span class="sxs-lookup"><span data-stu-id="d8740-160">Things to Remember About Implementing GetChildItems</span></span>

<span data-ttu-id="d8740-161">Следующие условия могут относиться к реализации [System.Management.Automation.Provider.Containercmdletprovider.Getchilditems\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.GetChildItems):</span><span class="sxs-lookup"><span data-stu-id="d8740-161">The following conditions may apply to your implementation of [System.Management.Automation.Provider.Containercmdletprovider.Getchilditems\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.GetChildItems):</span></span>

- <span data-ttu-id="d8740-162">При определении класса поставщика, поставщик контейнеров Windows PowerShell может объявлять возможностей поставщика ExpandWildcards фильтра, Include и Exclude, из [System.Management.Automation.Provider.Providercapabilities](/dotnet/api/System.Management.Automation.Provider.ProviderCapabilities) перечисления.</span><span class="sxs-lookup"><span data-stu-id="d8740-162">When defining the provider class, a Windows PowerShell container provider might declare provider capabilities of ExpandWildcards, Filter, Include, or Exclude, from the [System.Management.Automation.Provider.Providercapabilities](/dotnet/api/System.Management.Automation.Provider.ProviderCapabilities) enumeration.</span></span> <span data-ttu-id="d8740-163">В этих случаях реализация [System.Management.Automation.Provider.Containercmdletprovider.Getchilditems\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.GetChildItems) метод должен соответствовать требованиям указанного пути, передаваемые методу возможности.</span><span class="sxs-lookup"><span data-stu-id="d8740-163">In these cases, the implementation of the [System.Management.Automation.Provider.Containercmdletprovider.Getchilditems\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.GetChildItems) method needs to ensure that the path passed to the method meets the requirements of the specified capabilities.</span></span> <span data-ttu-id="d8740-164">Чтобы сделать это, метод должен получить доступ к соответствующее свойство, например, [System.Management.Automation.Provider.Cmdletprovider.Exclude\*](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.Exclude) и [ System.Management.Automation.Provider.Cmdletprovider.Include\*](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.Include) свойства.</span><span class="sxs-lookup"><span data-stu-id="d8740-164">To do this, the method should access the appropriate property, for example, the [System.Management.Automation.Provider.Cmdletprovider.Exclude\*](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.Exclude) and [System.Management.Automation.Provider.Cmdletprovider.Include\*](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.Include) properties.</span></span>

- <span data-ttu-id="d8740-165">Реализация этого метода должна быть учтена в любой форме доступ к элементу, может сделать элемент видимым для пользователя.</span><span class="sxs-lookup"><span data-stu-id="d8740-165">The implementation of this method should take into account any form of access to the item that might make the item visible to the user.</span></span> <span data-ttu-id="d8740-166">Например, если пользователь имеет доступ на запись в файл через поставщик FileSystem (указанного в Windows PowerShell), но не доступ на чтение, файл по-прежнему существует и [System.Management.Automation.Provider.Itemcmdletprovider.Itemexists\*](/dotnet/api/System.Management.Automation.Provider.ItemCmdletProvider.ItemExists) возвращает `true`.</span><span class="sxs-lookup"><span data-stu-id="d8740-166">For example, if a user has write access to a file through the FileSystem provider (supplied by Windows PowerShell), but not read access, the file still exists and [System.Management.Automation.Provider.Itemcmdletprovider.Itemexists\*](/dotnet/api/System.Management.Automation.Provider.ItemCmdletProvider.ItemExists) returns `true`.</span></span> <span data-ttu-id="d8740-167">Реализация может потребоваться проверка параметров родительского элемента, чтобы увидеть, могут быть перечислены дочерние.</span><span class="sxs-lookup"><span data-stu-id="d8740-167">Your implementation might require the checking of a parent item to see if the child can be enumerated.</span></span>

- <span data-ttu-id="d8740-168">При написании несколько элементов, [System.Management.Automation.Provider.Containercmdletprovider.Getchilditems\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.GetChildItems) метод может занять некоторое время.</span><span class="sxs-lookup"><span data-stu-id="d8740-168">When writing multiple items, the [System.Management.Automation.Provider.Containercmdletprovider.Getchilditems\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.GetChildItems) method can take some time.</span></span> <span data-ttu-id="d8740-169">Можно спроектировать ваш поставщик нужно записать элементы с помощью [System.Management.Automation.Provider.Cmdletprovider.Writeitemobject\*](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.WriteItemObject) метод одной за раз.</span><span class="sxs-lookup"><span data-stu-id="d8740-169">You can design your provider to write the items using the [System.Management.Automation.Provider.Cmdletprovider.Writeitemobject\*](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.WriteItemObject) method one at a time.</span></span> <span data-ttu-id="d8740-170">При использовании этого метода будет представлять элементы для пользователя в потоке.</span><span class="sxs-lookup"><span data-stu-id="d8740-170">Using this technique will present the items to the user in a stream.</span></span>

- <span data-ttu-id="d8740-171">Реализация [System.Management.Automation.Provider.Containercmdletprovider.Getchilditems\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.GetChildItems) отвечает за Предотвращение бесконечной рекурсии, при наличии циклических ссылок и т.п.</span><span class="sxs-lookup"><span data-stu-id="d8740-171">Your implementation of [System.Management.Automation.Provider.Containercmdletprovider.Getchilditems\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.GetChildItems) is responsible for preventing infinite recursion when there are circular links, and the like.</span></span> <span data-ttu-id="d8740-172">Завершающий соответствующее исключение должно вызываться для отражения таких условий.</span><span class="sxs-lookup"><span data-stu-id="d8740-172">An appropriate terminating exception should be thrown to reflect such a condition.</span></span>

## <a name="attaching-dynamic-parameters-to-the-get-childitem-cmdlet"></a><span data-ttu-id="d8740-173">Присоединение динамических параметров в командлет Get-ChildItem</span><span class="sxs-lookup"><span data-stu-id="d8740-173">Attaching Dynamic Parameters to the Get-ChildItem Cmdlet</span></span>

<span data-ttu-id="d8740-174">Иногда `Get-ChildItem` командлет, который вызывает [System.Management.Automation.Provider.Containercmdletprovider.Getchilditems\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.GetChildItems) требуются дополнительные параметры, заданные динамически во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="d8740-174">Sometimes the `Get-ChildItem` cmdlet that calls [System.Management.Automation.Provider.Containercmdletprovider.Getchilditems\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.GetChildItems) requires additional parameters that are specified dynamically at runtime.</span></span> <span data-ttu-id="d8740-175">Для обеспечения этих динамических параметров, необходимо реализовать поставщик контейнеров Windows PowerShell [System.Management.Automation.Provider.Containercmdletprovider.Getchilditemsdynamicparameters\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.GetChildItemsDynamicParameters) метод.</span><span class="sxs-lookup"><span data-stu-id="d8740-175">To provide these dynamic parameters, the Windows PowerShell container provider must implement the [System.Management.Automation.Provider.Containercmdletprovider.Getchilditemsdynamicparameters\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.GetChildItemsDynamicParameters) method.</span></span> <span data-ttu-id="d8740-176">Этот метод получает динамические параметры для элемента в заданный путь и возвращает объект, имеющий свойства и поля с разбор атрибутов, аналогично классу командлета или [ System.Management.Automation.Runtimedefinedparameterdictionary](/dotnet/api/System.Management.Automation.RuntimeDefinedParameterDictionary) объекта.</span><span class="sxs-lookup"><span data-stu-id="d8740-176">This method retrieves dynamic parameters for the item at the indicated path and returns an object that has properties and fields with parsing attributes similar to a cmdlet class or a [System.Management.Automation.Runtimedefinedparameterdictionary](/dotnet/api/System.Management.Automation.RuntimeDefinedParameterDictionary) object.</span></span> <span data-ttu-id="d8740-177">Среда выполнения Windows PowerShell использует возвращенный объект для добавления параметров к `Get-ChildItem` командлета.</span><span class="sxs-lookup"><span data-stu-id="d8740-177">The Windows PowerShell runtime uses the returned object to add the parameters to the `Get-ChildItem` cmdlet.</span></span>

<span data-ttu-id="d8740-178">Этот поставщик контейнеров Windows PowerShell не реализует этот метод.</span><span class="sxs-lookup"><span data-stu-id="d8740-178">This Windows PowerShell container provider does not implement this method.</span></span> <span data-ttu-id="d8740-179">Однако следующий код является реализация по умолчанию этот метод.</span><span class="sxs-lookup"><span data-stu-id="d8740-179">However, the following code is the default implementation of this method.</span></span>

<!-- TODO!!!: review snippet reference  [!CODE [Msh_samplestestcmdlets#testprovidergetchilditemsdynamicparameters](Msh_samplestestcmdlets#testprovidergetchilditemsdynamicparameters)]  -->

## <a name="retrieving-child-item-names"></a><span data-ttu-id="d8740-180">Получение имен дочерних элементов</span><span class="sxs-lookup"><span data-stu-id="d8740-180">Retrieving Child Item Names</span></span>

<span data-ttu-id="d8740-181">Чтобы получить имена дочерних элементов, необходимо переопределить поставщик контейнеров Windows PowerShell [System.Management.Automation.Provider.Containercmdletprovider.Getchildnames\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.GetChildNames) метод для поддержки вызовов из `Get-ChildItem`командлет при его `Name` указан параметр.</span><span class="sxs-lookup"><span data-stu-id="d8740-181">To retrieve the names of child items, the Windows PowerShell container provider must override the [System.Management.Automation.Provider.Containercmdletprovider.Getchildnames\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.GetChildNames) method to support calls from the `Get-ChildItem` cmdlet when its `Name` parameter is specified.</span></span> <span data-ttu-id="d8740-182">Этот метод извлекает имена дочерних элементов для указанных имен путь или дочернего элемента для всех контейнеров, если `returnAllContainers` указан параметр командлета.</span><span class="sxs-lookup"><span data-stu-id="d8740-182">This method retrieves the names of the child items for the specified path or child item names for all containers if the `returnAllContainers` parameter of the cmdlet is specified.</span></span> <span data-ttu-id="d8740-183">Имя дочернего приведен фрагмент конечного пути.</span><span class="sxs-lookup"><span data-stu-id="d8740-183">A child name is the leaf portion of a path.</span></span> <span data-ttu-id="d8740-184">Например «abc.dll» имеет имя дочернего c:\windows\system32\abc.dll путь.</span><span class="sxs-lookup"><span data-stu-id="d8740-184">For example, the child name for the path c:\windows\system32\abc.dll is "abc.dll".</span></span> <span data-ttu-id="d8740-185">Дочерний каталог c:\windows\system32 называется «system32».</span><span class="sxs-lookup"><span data-stu-id="d8740-185">The child name for the directory c:\windows\system32 is "system32".</span></span>

<span data-ttu-id="d8740-186">Вот реализация [System.Management.Automation.Provider.Containercmdletprovider.Getchildnames\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.GetChildNames) метода для данного поставщика.</span><span class="sxs-lookup"><span data-stu-id="d8740-186">Here is the implementation of the [System.Management.Automation.Provider.Containercmdletprovider.Getchildnames\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.GetChildNames) method for this provider.</span></span> <span data-ttu-id="d8740-187">Обратите внимание на то, что этот метод извлекает имена таблиц, если указанный путь указывает базы данных Access (диск) и номера строк, если путь указывает на таблицу.</span><span class="sxs-lookup"><span data-stu-id="d8740-187">Notice that the method retrieves table names if the specified path indicates the Access database (drive) and row numbers if the path indicates a table.</span></span>

```csharp
protected override void GetChildNames(string path,
                            ReturnContainers returnContainers)
{
    // If the path represented is a drive, then the child items are
    // tables. get the names of all the tables in the drive.
    if (PathIsDrive(path))
    {
        foreach (DatabaseTableInfo table in GetTables())
        {
            WriteItemObject(table.Name, path, true);
        } // foreach (DatabaseTableInfo...
    } // if (PathIsDrive...
    else
    {
        // Get type, table name and row number from path specified
        string tableName;
        int rowNumber;

        PathType type = GetNamesFromPath(path, out tableName, out rowNumber);

        if (type == PathType.Table)
        {
            // Get all the rows in the table and then write out the
            // row numbers.
            foreach (DatabaseRowInfo row in GetRows(tableName))
            {
                WriteItemObject(row.RowNumber, path, false);
            } // foreach (DatabaseRowInfo...
        }
        else if (type == PathType.Row)
        {
            // In this case the user has directly specified a row, hence
            // just give that particular row
            DatabaseRowInfo row = GetRow(tableName, rowNumber);

            WriteItemObject(row.RowNumber, path, false);
        }
        else
        {
            ThrowTerminatingInvalidPathException(path);
        }
    } // else
} // GetChildNames
```

[!code-csharp[AccessDBProviderSample04.cs](../../powershell-sdk-samples/SDK-2.0/csharp/AccessDBProviderSample04/AccessDBProviderSample04.cs#L369-L411 "AccessDBProviderSample04.cs")]

#### <a name="things-to-remember-about-implementing-getchildnames"></a><span data-ttu-id="d8740-188">О чем следует помнить о реализации GetChildNames</span><span class="sxs-lookup"><span data-stu-id="d8740-188">Things to Remember About Implementing GetChildNames</span></span>

<span data-ttu-id="d8740-189">Следующие условия могут относиться к реализации [System.Management.Automation.Provider.Containercmdletprovider.Getchilditems\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.GetChildItems):</span><span class="sxs-lookup"><span data-stu-id="d8740-189">The following conditions may apply to your implementation of [System.Management.Automation.Provider.Containercmdletprovider.Getchilditems\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.GetChildItems):</span></span>

- <span data-ttu-id="d8740-190">При определении класса поставщика, поставщик контейнеров Windows PowerShell может объявлять возможностей поставщика ExpandWildcards фильтра, Include и Exclude, из [System.Management.Automation.Provider.Providercapabilities](/dotnet/api/System.Management.Automation.Provider.ProviderCapabilities) перечисления.</span><span class="sxs-lookup"><span data-stu-id="d8740-190">When defining the provider class, a Windows PowerShell container provider might declare provider capabilities of ExpandWildcards, Filter, Include, or Exclude, from the [System.Management.Automation.Provider.Providercapabilities](/dotnet/api/System.Management.Automation.Provider.ProviderCapabilities) enumeration.</span></span> <span data-ttu-id="d8740-191">В этих случаях реализация [System.Management.Automation.Provider.Containercmdletprovider.Getchilditems\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.GetChildItems) метод должен соответствовать требованиям указанного пути, передаваемые методу возможности.</span><span class="sxs-lookup"><span data-stu-id="d8740-191">In these cases, the implementation of the [System.Management.Automation.Provider.Containercmdletprovider.Getchilditems\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.GetChildItems) method needs to ensure that the path passed to the method meets the requirements of the specified capabilities.</span></span> <span data-ttu-id="d8740-192">Чтобы сделать это, метод должен получить доступ к соответствующее свойство, например, [System.Management.Automation.Provider.Cmdletprovider.Exclude\*](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.Exclude) и [ System.Management.Automation.Provider.Cmdletprovider.Include\*](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.Include) свойства.</span><span class="sxs-lookup"><span data-stu-id="d8740-192">To do this, the method should access the appropriate property, for example, the [System.Management.Automation.Provider.Cmdletprovider.Exclude\*](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.Exclude) and [System.Management.Automation.Provider.Cmdletprovider.Include\*](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.Include) properties.</span></span>

  > [!NOTE]
  > <span data-ttu-id="d8740-193">Исключение этого правила возникает, когда `returnAllContainers` указан параметр командлета.</span><span class="sxs-lookup"><span data-stu-id="d8740-193">An exception to this rule occurs when the `returnAllContainers` parameter of the cmdlet is specified.</span></span> <span data-ttu-id="d8740-194">В этом случае метод должен получать любое имя дочернего контейнера, даже если он не соответствует значения [System.Management.Automation.Provider.Cmdletprovider.Filter\*](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.Filter), [ System.Management.Automation.Provider.Cmdletprovider.Include\*](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.Include), или [System.Management.Automation.Provider.Cmdletprovider.Exclude\*](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.Exclude) свойства.</span><span class="sxs-lookup"><span data-stu-id="d8740-194">In this case, the method should retrieve any child name for a container, even if it does not match the values of the [System.Management.Automation.Provider.Cmdletprovider.Filter\*](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.Filter), [System.Management.Automation.Provider.Cmdletprovider.Include\*](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.Include), or [System.Management.Automation.Provider.Cmdletprovider.Exclude\*](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.Exclude) properties.</span></span>

- <span data-ttu-id="d8740-195">По умолчанию переопределения этого метода не должен извлекать имена объектов, которые обычно скрыты от пользователя, если не [System.Management.Automation.Provider.Cmdletprovider.Force\*](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.Force) указано свойство.</span><span class="sxs-lookup"><span data-stu-id="d8740-195">By default, overrides of this method should not retrieve names of objects that are generally hidden from the user unless the [System.Management.Automation.Provider.Cmdletprovider.Force\*](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.Force) property is specified.</span></span> <span data-ttu-id="d8740-196">Если указанный путь указывает на контейнер, [System.Management.Automation.Provider.Cmdletprovider.Force\*](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.Force) свойство не является обязательным.</span><span class="sxs-lookup"><span data-stu-id="d8740-196">If the specified path indicates a container, the [System.Management.Automation.Provider.Cmdletprovider.Force\*](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.Force) property is not required.</span></span>

- <span data-ttu-id="d8740-197">Реализация [System.Management.Automation.Provider.Containercmdletprovider.Getchildnames\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.GetChildNames) отвечает за Предотвращение бесконечной рекурсии, при наличии циклических ссылок и т.п.</span><span class="sxs-lookup"><span data-stu-id="d8740-197">Your implementation of [System.Management.Automation.Provider.Containercmdletprovider.Getchildnames\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.GetChildNames) is responsible for preventing infinite recursion when there are circular links, and the like.</span></span> <span data-ttu-id="d8740-198">Завершающий соответствующее исключение должно вызываться для отражения таких условий.</span><span class="sxs-lookup"><span data-stu-id="d8740-198">An appropriate terminating exception should be thrown to reflect such a condition.</span></span>

## <a name="attaching-dynamic-parameters-to-the-get-childitem-cmdlet-name"></a><span data-ttu-id="d8740-199">Присоединение динамических параметров в командлет Get-ChildItem (имя)</span><span class="sxs-lookup"><span data-stu-id="d8740-199">Attaching Dynamic Parameters to the Get-ChildItem Cmdlet (Name)</span></span>

<span data-ttu-id="d8740-200">Иногда `Get-ChildItem` командлета (с `Name` параметр) требуются дополнительные параметры, заданные динамически во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="d8740-200">Sometimes the `Get-ChildItem` cmdlet (with the `Name` parameter) requires additional parameters that are specified dynamically at runtime.</span></span> <span data-ttu-id="d8740-201">Для обеспечения этих динамических параметров, необходимо реализовать поставщик контейнеров Windows PowerShell [System.Management.Automation.Provider.Containercmdletprovider.Getchildnamesdynamicparameters\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.GetChildNamesDynamicParameters) метод.</span><span class="sxs-lookup"><span data-stu-id="d8740-201">To provide these dynamic parameters, the Windows PowerShell container provider must implement the [System.Management.Automation.Provider.Containercmdletprovider.Getchildnamesdynamicparameters\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.GetChildNamesDynamicParameters) method.</span></span> <span data-ttu-id="d8740-202">Этот метод получает динамические параметры для элемента в заданный путь и возвращает объект, имеющий свойства и поля с разбор атрибутов, аналогично классу командлета или [ System.Management.Automation.Runtimedefinedparameterdictionary](/dotnet/api/System.Management.Automation.RuntimeDefinedParameterDictionary) объекта.</span><span class="sxs-lookup"><span data-stu-id="d8740-202">This method retrieves the dynamic parameters for the item at the indicated path and returns an object that has properties and fields with parsing attributes similar to a cmdlet class or a [System.Management.Automation.Runtimedefinedparameterdictionary](/dotnet/api/System.Management.Automation.RuntimeDefinedParameterDictionary) object.</span></span> <span data-ttu-id="d8740-203">Среда выполнения Windows PowerShell использует возвращенный объект для добавления параметров к `Get-ChildItem` командлета.</span><span class="sxs-lookup"><span data-stu-id="d8740-203">The Windows PowerShell runtime uses the returned object to add the parameters to the `Get-ChildItem` cmdlet.</span></span>

<span data-ttu-id="d8740-204">Этот поставщик не реализует этот метод.</span><span class="sxs-lookup"><span data-stu-id="d8740-204">This provider does not implement this method.</span></span> <span data-ttu-id="d8740-205">Однако следующий код является реализация по умолчанию этот метод.</span><span class="sxs-lookup"><span data-stu-id="d8740-205">However, the following code is the default implementation of this method.</span></span>

<!-- TODO!!!: review snippet reference  [!CODE [Msh_samplestestcmdlets#testprovidergetchildnamesdynamicparameters](Msh_samplestestcmdlets#testprovidergetchildnamesdynamicparameters)]  -->

## <a name="renaming-items"></a><span data-ttu-id="d8740-206">Переименование элементов</span><span class="sxs-lookup"><span data-stu-id="d8740-206">Renaming Items</span></span>

<span data-ttu-id="d8740-207">Чтобы переименовать элемент, необходимо переопределить поставщик контейнеров Windows PowerShell [System.Management.Automation.Provider.Containercmdletprovider.Renameitem\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.RenameItem) метод для поддержки вызовов из `Rename-Item` командлета.</span><span class="sxs-lookup"><span data-stu-id="d8740-207">To rename an item, a Windows PowerShell container provider must override the [System.Management.Automation.Provider.Containercmdletprovider.Renameitem\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.RenameItem) method to support calls from the `Rename-Item` cmdlet.</span></span> <span data-ttu-id="d8740-208">Этот метод изменяет имя элемента по указанному пути к предоставлен новое имя.</span><span class="sxs-lookup"><span data-stu-id="d8740-208">This method changes the name of the item at the specified path to the new name provided.</span></span> <span data-ttu-id="d8740-209">Новое имя всегда должен быть относительно родительского элемента (контейнер).</span><span class="sxs-lookup"><span data-stu-id="d8740-209">The new name must always be relative to the parent item (container).</span></span>

<span data-ttu-id="d8740-210">Этот поставщик не переопределяет [System.Management.Automation.Provider.Containercmdletprovider.Renameitem\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.RenameItem) метод.</span><span class="sxs-lookup"><span data-stu-id="d8740-210">This provider does not override the [System.Management.Automation.Provider.Containercmdletprovider.Renameitem\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.RenameItem) method.</span></span> <span data-ttu-id="d8740-211">Тем не менее ниже приведен пример реализации по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="d8740-211">However, the following is the default implementation.</span></span>

<!-- TODO!!!: review snippet reference  [!CODE [Msh_samplestestcmdlets#testproviderrenameitem](Msh_samplestestcmdlets#testproviderrenameitem)]  -->

#### <a name="things-to-remember-about-implementing-renameitem"></a><span data-ttu-id="d8740-212">О чем следует помнить о реализации RenameItem</span><span class="sxs-lookup"><span data-stu-id="d8740-212">Things to Remember About Implementing RenameItem</span></span>

<span data-ttu-id="d8740-213">Следующие условия могут относиться к реализации [System.Management.Automation.Provider.Containercmdletprovider.Renameitem\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.RenameItem):</span><span class="sxs-lookup"><span data-stu-id="d8740-213">The following conditions may apply to your implementation of [System.Management.Automation.Provider.Containercmdletprovider.Renameitem\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.RenameItem):</span></span>

- <span data-ttu-id="d8740-214">При определении класса поставщика, поставщик контейнеров Windows PowerShell может объявлять возможностей поставщика ExpandWildcards фильтра, Include и Exclude, из [System.Management.Automation.Provider.Providercapabilities](/dotnet/api/System.Management.Automation.Provider.ProviderCapabilities) перечисления.</span><span class="sxs-lookup"><span data-stu-id="d8740-214">When defining the provider class, a Windows PowerShell container provider might declare provider capabilities of ExpandWildcards, Filter, Include, or Exclude, from the [System.Management.Automation.Provider.Providercapabilities](/dotnet/api/System.Management.Automation.Provider.ProviderCapabilities) enumeration.</span></span> <span data-ttu-id="d8740-215">В этих случаях реализация [System.Management.Automation.Provider.Containercmdletprovider.Getchilditems\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.GetChildItems) метод должен соответствовать требованиям указанного пути, передаваемые методу возможности.</span><span class="sxs-lookup"><span data-stu-id="d8740-215">In these cases, the implementation of the [System.Management.Automation.Provider.Containercmdletprovider.Getchilditems\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.GetChildItems) method needs to ensure that the path passed to the method meets the requirements of the specified capabilities.</span></span> <span data-ttu-id="d8740-216">Чтобы сделать это, метод должен получить доступ к соответствующее свойство, например, [System.Management.Automation.Provider.Cmdletprovider.Exclude\*](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.Exclude) и [ System.Management.Automation.Provider.Cmdletprovider.Include\*](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.Include) свойства.</span><span class="sxs-lookup"><span data-stu-id="d8740-216">To do this, the method should access the appropriate property, for example, the [System.Management.Automation.Provider.Cmdletprovider.Exclude\*](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.Exclude) and [System.Management.Automation.Provider.Cmdletprovider.Include\*](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.Include) properties.</span></span>

- <span data-ttu-id="d8740-217">[System.Management.Automation.Provider.Containercmdletprovider.Renameitem\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.RenameItem) метод предназначен для изменения имени только элемент, а не для операции перемещения.</span><span class="sxs-lookup"><span data-stu-id="d8740-217">The [System.Management.Automation.Provider.Containercmdletprovider.Renameitem\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.RenameItem) method is intended for the modification of the name of an item only, and not for move operations.</span></span> <span data-ttu-id="d8740-218">Реализация метода следует писать ошибку, если `newName` содержит разделители путей или иначе могут привести к записи родительского расположения.</span><span class="sxs-lookup"><span data-stu-id="d8740-218">Your implementation of the method should write an error if the `newName` parameter contains path separators, or might otherwise cause the item to change its parent location.</span></span>

- <span data-ttu-id="d8740-219">По умолчанию переопределения этого метода нельзя переименовывать объекты Если [System.Management.Automation.Provider.Cmdletprovider.Force\*](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.Force) указано свойство.</span><span class="sxs-lookup"><span data-stu-id="d8740-219">By default, overrides of this method should not rename objects unless the [System.Management.Automation.Provider.Cmdletprovider.Force\*](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.Force) property is specified.</span></span> <span data-ttu-id="d8740-220">Если указанный путь указывает на контейнер, [System.Management.Automation.Provider.Cmdletprovider.Force\*](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.Force) свойство не является обязательным.</span><span class="sxs-lookup"><span data-stu-id="d8740-220">If the specified path indicates a container, the [System.Management.Automation.Provider.Cmdletprovider.Force\*](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.Force) property is not required.</span></span>

- <span data-ttu-id="d8740-221">Реализация [System.Management.Automation.Provider.Containercmdletprovider.Renameitem\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.RenameItem) метод должен вызывать [System.Management.Automation.Provider.Cmdletprovider.ShouldProcess](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.ShouldProcess) и проверьте его возвращаемое значение перед внесением любых изменений в хранилище данных.</span><span class="sxs-lookup"><span data-stu-id="d8740-221">Your implementation of the [System.Management.Automation.Provider.Containercmdletprovider.Renameitem\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.RenameItem) method should call [System.Management.Automation.Provider.Cmdletprovider.ShouldProcess](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.ShouldProcess) and check its return value before making any changes to the data store.</span></span> <span data-ttu-id="d8740-222">Этот метод используется для подтверждения выполнения операции, при изменении состояния системы, например, переименование файлов.</span><span class="sxs-lookup"><span data-stu-id="d8740-222">This method is used to confirm execution of an operation when a change is made to system state, for example, renaming files.</span></span> <span data-ttu-id="d8740-223">[System.Management.Automation.Provider.Cmdletprovider.ShouldProcess](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.ShouldProcess) отправляет имя ресурса, необходимо изменить на пользователя, в среде выполнения Windows PowerShell, принимая во внимание любые параметры командной строки или привилегированных переменных в Определяет, что должно быть отображено.</span><span class="sxs-lookup"><span data-stu-id="d8740-223">[System.Management.Automation.Provider.Cmdletprovider.ShouldProcess](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.ShouldProcess) sends the name of the resource to be changed to the user, with the Windows PowerShell runtime taking into account any command line settings or preference variables in determining what should be displayed.</span></span>

  <span data-ttu-id="d8740-224">После вызова [System.Management.Automation.Provider.Cmdletprovider.ShouldProcess](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.ShouldProcess) возвращает `true`, [System.Management.Automation.Provider.Containercmdletprovider.Renameitem\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.RenameItem) метод должен вызывать [System.Management.Automation.Provider.Cmdletprovider.ShouldContinue](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.ShouldContinue) метод.</span><span class="sxs-lookup"><span data-stu-id="d8740-224">After the call to [System.Management.Automation.Provider.Cmdletprovider.ShouldProcess](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.ShouldProcess) returns `true`, the [System.Management.Automation.Provider.Containercmdletprovider.Renameitem\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.RenameItem) method should call the [System.Management.Automation.Provider.Cmdletprovider.ShouldContinue](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.ShouldContinue) method.</span></span> <span data-ttu-id="d8740-225">Этот метод отправляет сообщение с подтверждением сообщение пользователю, чтобы разрешить дополнительный отзыв сказать, если операция должна быть продолжено.</span><span class="sxs-lookup"><span data-stu-id="d8740-225">This method sends a message a confirmation message to the user to allow additional feedback to say if the operation should be continued.</span></span> <span data-ttu-id="d8740-226">Поставщик должен вызывать [System.Management.Automation.Provider.Cmdletprovider.ShouldContinue](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.ShouldContinue) как дополнительную проверку для изменения потенциально опасных системы.</span><span class="sxs-lookup"><span data-stu-id="d8740-226">A provider should call [System.Management.Automation.Provider.Cmdletprovider.ShouldContinue](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.ShouldContinue) as an additional check for potentially dangerous system modifications.</span></span>

## <a name="attaching-dynamic-parameters-to-the-rename-item-cmdlet"></a><span data-ttu-id="d8740-227">Присоединение динамических параметров в командлет Rename-Item</span><span class="sxs-lookup"><span data-stu-id="d8740-227">Attaching Dynamic Parameters to the Rename-Item Cmdlet</span></span>

<span data-ttu-id="d8740-228">Иногда `Rename-Item` командлета требуется Дополнительные параметры, заданные динамически во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="d8740-228">Sometimes the `Rename-Item` cmdlet requires additional parameters that are specified dynamically at runtime.</span></span> <span data-ttu-id="d8740-229">Для обеспечения этих динамических параметров, необходимо реализовать поставщик контейнеров Windows PowerShell [System.Management.Automation.Provider.Containercmdletprovider.Renameitemdynamicparameters\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.RenameItemDynamicParameters) метод.</span><span class="sxs-lookup"><span data-stu-id="d8740-229">To provide these dynamic parameters, Windows PowerShell container provider must implement the [System.Management.Automation.Provider.Containercmdletprovider.Renameitemdynamicparameters\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.RenameItemDynamicParameters) method.</span></span> <span data-ttu-id="d8740-230">Этот метод извлекает параметры для элемента в заданный путь и возвращает объект, имеющий свойства и поля с разбор атрибутов, аналогично классу командлета или [System.Management.Automation.Runtimedefinedparameterdictionary ](/dotnet/api/System.Management.Automation.RuntimeDefinedParameterDictionary) объекта.</span><span class="sxs-lookup"><span data-stu-id="d8740-230">This method retrieves the parameters for the item at the indicated path and returns an object that has properties and fields with parsing attributes similar to a cmdlet class or a [System.Management.Automation.Runtimedefinedparameterdictionary](/dotnet/api/System.Management.Automation.RuntimeDefinedParameterDictionary) object.</span></span> <span data-ttu-id="d8740-231">Среда выполнения Windows PowerShell использует возвращенный объект для добавления параметров к `Rename-Item` командлета.</span><span class="sxs-lookup"><span data-stu-id="d8740-231">The Windows PowerShell runtime uses the returned object to add the parameters to the `Rename-Item` cmdlet.</span></span>

<span data-ttu-id="d8740-232">Этот контейнер поставщик не реализует этот метод.</span><span class="sxs-lookup"><span data-stu-id="d8740-232">This container provider does not implement this method.</span></span> <span data-ttu-id="d8740-233">Однако следующий код является реализация по умолчанию этот метод.</span><span class="sxs-lookup"><span data-stu-id="d8740-233">However, the following code is the default implementation of this method.</span></span>

<!-- TODO!!!: review snippet reference  [!CODE [Msh_samplestestcmdlets#testproviderrenameitemdynamicparameters](Msh_samplestestcmdlets#testproviderrenameitemdynamicparameters)]  -->

## <a name="creating-new-items"></a><span data-ttu-id="d8740-234">Создание новых элементов</span><span class="sxs-lookup"><span data-stu-id="d8740-234">Creating New Items</span></span>

<span data-ttu-id="d8740-235">Чтобы создать новые элементы, должен реализовывать поставщик контейнера [System.Management.Automation.Provider.Containercmdletprovider.Newitem\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.NewItem) метод для поддержки вызовов из `New-Item` командлета.</span><span class="sxs-lookup"><span data-stu-id="d8740-235">To create new items, a container provider must implement the [System.Management.Automation.Provider.Containercmdletprovider.Newitem\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.NewItem) method to support calls from the `New-Item` cmdlet.</span></span> <span data-ttu-id="d8740-236">Этот метод создает элемент данных, расположенный по указанному пути.</span><span class="sxs-lookup"><span data-stu-id="d8740-236">This method creates a data item located at the specified path.</span></span> <span data-ttu-id="d8740-237">`type` Параметр командлета содержит тип определяемых поставщиком для нового элемента.</span><span class="sxs-lookup"><span data-stu-id="d8740-237">The `type` parameter of the cmdlet contains the provider-defined type for the new item.</span></span> <span data-ttu-id="d8740-238">Например, используется поставщик FileSystem `type` параметр со значением «файл» или «каталог».</span><span class="sxs-lookup"><span data-stu-id="d8740-238">For example, the FileSystem provider uses a `type` parameter with a value of "file" or "directory".</span></span> <span data-ttu-id="d8740-239">`newItemValue` Параметр командлета указывает значение от поставщика для нового элемента.</span><span class="sxs-lookup"><span data-stu-id="d8740-239">The `newItemValue` parameter of the cmdlet specifies a provider-specific value for the new item.</span></span>

<span data-ttu-id="d8740-240">Вот реализация [System.Management.Automation.Provider.Containercmdletprovider.Newitem\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.NewItem) метода для данного поставщика.</span><span class="sxs-lookup"><span data-stu-id="d8740-240">Here is the implementation of the [System.Management.Automation.Provider.Containercmdletprovider.Newitem\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.NewItem) method for this provider.</span></span>

```csharp
protected override void NewItem( string path, string type,
                                 object newItemValue )
{
    // Create the new item here after
    // performing necessary validations
    //
    // WriteItemObject(newItemValue, path, false);

    // Example
    //
    // if (ShouldProcess(path, "new item"))
    // {
    //      // Create a new item and then call WriteObject
    //      WriteObject(newItemValue, path, false);
    // }

} // NewItem
```

[!code-csharp[AccessDBProviderSample04.cs](../../powershell-sdk-samples/SDK-2.0/csharp/AccessDBProviderSample04/AccessDBProviderSample04.cs#L939-L955 "AccessDBProviderSample04.cs")]

#### <a name="things-to-remember-about-implementing-newitem"></a><span data-ttu-id="d8740-241">О чем следует помнить о реализации NewItem</span><span class="sxs-lookup"><span data-stu-id="d8740-241">Things to Remember About Implementing NewItem</span></span>

<span data-ttu-id="d8740-242">Следующие условия могут относиться к реализации [System.Management.Automation.Provider.Containercmdletprovider.Newitem\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.NewItem):</span><span class="sxs-lookup"><span data-stu-id="d8740-242">The following conditions may apply to your implementation of [System.Management.Automation.Provider.Containercmdletprovider.Newitem\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.NewItem):</span></span>

- <span data-ttu-id="d8740-243">[System.Management.Automation.Provider.Containercmdletprovider.Newitem\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.NewItem) метод должен выполнять сравнение без учета регистра строки, переданной `type` параметра.</span><span class="sxs-lookup"><span data-stu-id="d8740-243">The [System.Management.Automation.Provider.Containercmdletprovider.Newitem\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.NewItem) method should perform a case-insensitive comparison of the string passed in the `type` parameter.</span></span> <span data-ttu-id="d8740-244">Что следует учесть также бы неоднозначным совпадений.</span><span class="sxs-lookup"><span data-stu-id="d8740-244">It should also allow for least ambiguous matches.</span></span> <span data-ttu-id="d8740-245">Например для типов «файл» и «каталог», только первая буква требуется для однозначного определения.</span><span class="sxs-lookup"><span data-stu-id="d8740-245">For example, for the types "file" and "directory", only the first letter is required to disambiguate.</span></span> <span data-ttu-id="d8740-246">Если `type` параметр указывает тип, не удается создать поставщик, [System.Management.Automation.Provider.Containercmdletprovider.Newitem\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.NewItem) метод должен записывать ArgumentException с сообщением указывающее типы можно создать поставщик.</span><span class="sxs-lookup"><span data-stu-id="d8740-246">If the `type` parameter indicates a type your provider cannot create, the [System.Management.Automation.Provider.Containercmdletprovider.Newitem\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.NewItem) method should write an ArgumentException with a message indicating the types the provider can create.</span></span>

- <span data-ttu-id="d8740-247">Для `newItemValue` параметр, реализация [System.Management.Automation.Provider.Containercmdletprovider.Newitem\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.NewItem) рекомендуется принять строки как минимум.</span><span class="sxs-lookup"><span data-stu-id="d8740-247">For the `newItemValue` parameter, the implementation of the [System.Management.Automation.Provider.Containercmdletprovider.Newitem\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.NewItem) method is recommended to accept strings at a minimum.</span></span> <span data-ttu-id="d8740-248">Он также должен принять тип объекта, который извлекается [System.Management.Automation.Provider.Itemcmdletprovider.Getitem\*](/dotnet/api/System.Management.Automation.Provider.ItemCmdletProvider.GetItem) метод тот же путь.</span><span class="sxs-lookup"><span data-stu-id="d8740-248">It should also accept the type of object that is retrieved by the [System.Management.Automation.Provider.Itemcmdletprovider.Getitem\*](/dotnet/api/System.Management.Automation.Provider.ItemCmdletProvider.GetItem) method for the same path.</span></span> <span data-ttu-id="d8740-249">[System.Management.Automation.Provider.Containercmdletprovider.Newitem\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.NewItem) можно использовать метод [System.Management.Automation.Languageprimitives.Convertto\*](/dotnet/api/System.Management.Automation.LanguagePrimitives.ConvertTo) метод для преобразования типов требуемый тип.</span><span class="sxs-lookup"><span data-stu-id="d8740-249">The [System.Management.Automation.Provider.Containercmdletprovider.Newitem\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.NewItem) method can use the [System.Management.Automation.Languageprimitives.Convertto\*](/dotnet/api/System.Management.Automation.LanguagePrimitives.ConvertTo) method to convert types to the desired type.</span></span>

- <span data-ttu-id="d8740-250">Реализация [System.Management.Automation.Provider.Containercmdletprovider.Newitem\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.NewItem) метод должен вызывать [System.Management.Automation.Provider.Cmdletprovider.ShouldProcess](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.ShouldProcess) и проверьте его возвращаемое значение перед внесением любых изменений в хранилище данных.</span><span class="sxs-lookup"><span data-stu-id="d8740-250">Your implementation of the [System.Management.Automation.Provider.Containercmdletprovider.Newitem\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.NewItem) method should call [System.Management.Automation.Provider.Cmdletprovider.ShouldProcess](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.ShouldProcess) and check its return value before making any changes to the data store.</span></span> <span data-ttu-id="d8740-251">После вызова [System.Management.Automation.Provider.Cmdletprovider.ShouldProcess](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.ShouldProcess) возвращает значение true, [System.Management.Automation.Provider.Containercmdletprovider.Newitem\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.NewItem) метод должен вызывать [System.Management.Automation.Provider.Cmdletprovider.ShouldContinue](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.ShouldContinue) метод как дополнительную проверку для изменения потенциально опасных системы.</span><span class="sxs-lookup"><span data-stu-id="d8740-251">After the call to [System.Management.Automation.Provider.Cmdletprovider.ShouldProcess](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.ShouldProcess) returns true, the [System.Management.Automation.Provider.Containercmdletprovider.Newitem\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.NewItem) method should call the [System.Management.Automation.Provider.Cmdletprovider.ShouldContinue](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.ShouldContinue) method as an additional check for potentially dangerous system modifications.</span></span>

## <a name="attaching-dynamic-parameters-to-the-new-item-cmdlet"></a><span data-ttu-id="d8740-252">Присоединение динамических параметров в командлет New-Item</span><span class="sxs-lookup"><span data-stu-id="d8740-252">Attaching Dynamic Parameters to the New-Item Cmdlet</span></span>

<span data-ttu-id="d8740-253">Иногда `New-Item` командлета требуется Дополнительные параметры, заданные динамически во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="d8740-253">Sometimes the `New-Item` cmdlet requires additional parameters that are specified dynamically at runtime.</span></span> <span data-ttu-id="d8740-254">Для обеспечения этих динамических параметров, необходимо реализовать поставщик контейнеров [System.Management.Automation.Provider.Containercmdletprovider.Newitemdynamicparameters\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.NewItemDynamicParameters) метод.</span><span class="sxs-lookup"><span data-stu-id="d8740-254">To provide these dynamic parameters, the container provider must implement the [System.Management.Automation.Provider.Containercmdletprovider.Newitemdynamicparameters\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.NewItemDynamicParameters) method.</span></span> <span data-ttu-id="d8740-255">Этот метод извлекает параметры для элемента в заданный путь и возвращает объект, имеющий свойства и поля с разбор атрибутов, аналогично классу командлета или [System.Management.Automation.Runtimedefinedparameterdictionary ](/dotnet/api/System.Management.Automation.RuntimeDefinedParameterDictionary) объекта.</span><span class="sxs-lookup"><span data-stu-id="d8740-255">This method retrieves the parameters for the item at the indicated path and returns an object that has properties and fields with parsing attributes similar to a cmdlet class or a [System.Management.Automation.Runtimedefinedparameterdictionary](/dotnet/api/System.Management.Automation.RuntimeDefinedParameterDictionary) object.</span></span> <span data-ttu-id="d8740-256">Среда выполнения Windows PowerShell использует возвращенный объект для добавления параметров к `New-Item` командлета.</span><span class="sxs-lookup"><span data-stu-id="d8740-256">The Windows PowerShell runtime uses the returned object to add the parameters to the `New-Item` cmdlet.</span></span>

<span data-ttu-id="d8740-257">Этот поставщик не реализует этот метод.</span><span class="sxs-lookup"><span data-stu-id="d8740-257">This provider does not implement this method.</span></span> <span data-ttu-id="d8740-258">Однако следующий код является реализация по умолчанию этот метод.</span><span class="sxs-lookup"><span data-stu-id="d8740-258">However, the following code is the default implementation of this method.</span></span>

<!-- TODO!!!: review snippet reference  [!CODE [Msh_samplestestcmdlets#testprovidernewitemdynamicparameters](Msh_samplestestcmdlets#testprovidernewitemdynamicparameters)]  -->

## <a name="removing-items"></a><span data-ttu-id="d8740-259">Удаление элементов</span><span class="sxs-lookup"><span data-stu-id="d8740-259">Removing Items</span></span>

<span data-ttu-id="d8740-260">Чтобы удалить элементы, необходимо переопределить поставщика Windows PowerShell [System.Management.Automation.Provider.Containercmdletprovider.Removeitem\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.RemoveItem) метод для поддержки вызовов из `Remove-Item` командлета.</span><span class="sxs-lookup"><span data-stu-id="d8740-260">To remove items, the Windows PowerShell provider must override the [System.Management.Automation.Provider.Containercmdletprovider.Removeitem\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.RemoveItem) method to support calls from the `Remove-Item` cmdlet.</span></span> <span data-ttu-id="d8740-261">Этот метод удаляет элемент из хранилища данных по указанному пути.</span><span class="sxs-lookup"><span data-stu-id="d8740-261">This method deletes an item from the data store at the specified path.</span></span> <span data-ttu-id="d8740-262">Если `recurse` параметр `Remove-Item` командлета задано значение `true`, метод удаляет все дочерние элементы, независимо от их уровня.</span><span class="sxs-lookup"><span data-stu-id="d8740-262">If the `recurse` parameter of the `Remove-Item` cmdlet is set to `true`, the method removes all child items regardless of their level.</span></span> <span data-ttu-id="d8740-263">Если параметр имеет значение `false`, метод удаляет только один элемент по указанному пути.</span><span class="sxs-lookup"><span data-stu-id="d8740-263">If the parameter is set to `false`, the method removes only a single item at the specified path.</span></span>

<span data-ttu-id="d8740-264">Этот поставщик не поддерживает удаление элементов.</span><span class="sxs-lookup"><span data-stu-id="d8740-264">This provider does not support item removal.</span></span> <span data-ttu-id="d8740-265">Тем не менее, следующий код является реализация по умолчанию [System.Management.Automation.Provider.Containercmdletprovider.Removeitem\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.RemoveItem).</span><span class="sxs-lookup"><span data-stu-id="d8740-265">However, the following code is the default implementation of [System.Management.Automation.Provider.Containercmdletprovider.Removeitem\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.RemoveItem).</span></span>

<!-- TODO!!!: review snippet reference  [!CODE [Msh_samplestestcmdlets#testproviderremoveitem](Msh_samplestestcmdlets#testproviderremoveitem)]  -->

#### <a name="things-to-remember-about-implementing-removeitem"></a><span data-ttu-id="d8740-266">О чем следует помнить о реализации RemoveItem</span><span class="sxs-lookup"><span data-stu-id="d8740-266">Things to Remember About Implementing RemoveItem</span></span>

<span data-ttu-id="d8740-267">Следующие условия могут относиться к реализации [System.Management.Automation.Provider.Containercmdletprovider.Newitem\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.NewItem):</span><span class="sxs-lookup"><span data-stu-id="d8740-267">The following conditions may apply to your implementation of [System.Management.Automation.Provider.Containercmdletprovider.Newitem\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.NewItem):</span></span>

- <span data-ttu-id="d8740-268">При определении класса поставщика, поставщик контейнеров Windows PowerShell может объявлять возможностей поставщика ExpandWildcards фильтра, Include и Exclude, из [System.Management.Automation.Provider.Providercapabilities](/dotnet/api/System.Management.Automation.Provider.ProviderCapabilities) перечисления.</span><span class="sxs-lookup"><span data-stu-id="d8740-268">When defining the provider class, a Windows PowerShell container provider might declare provider capabilities of ExpandWildcards, Filter, Include, or Exclude, from the [System.Management.Automation.Provider.Providercapabilities](/dotnet/api/System.Management.Automation.Provider.ProviderCapabilities) enumeration.</span></span> <span data-ttu-id="d8740-269">В этих случаях реализация [System.Management.Automation.Provider.Containercmdletprovider.Getchilditems\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.GetChildItems) метод должен соответствовать требованиям указанного пути, передаваемые методу возможности.</span><span class="sxs-lookup"><span data-stu-id="d8740-269">In these cases, the implementation of the [System.Management.Automation.Provider.Containercmdletprovider.Getchilditems\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.GetChildItems) method needs to ensure that the path passed to the method meets the requirements of the specified capabilities.</span></span> <span data-ttu-id="d8740-270">Чтобы сделать это, метод должен получить доступ к соответствующее свойство, например, [System.Management.Automation.Provider.Cmdletprovider.Exclude\*](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.Exclude) и [ System.Management.Automation.Provider.Cmdletprovider.Include\*](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.Include) свойства.</span><span class="sxs-lookup"><span data-stu-id="d8740-270">To do this, the method should access the appropriate property, for example, the [System.Management.Automation.Provider.Cmdletprovider.Exclude\*](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.Exclude) and [System.Management.Automation.Provider.Cmdletprovider.Include\*](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.Include) properties.</span></span>

- <span data-ttu-id="d8740-271">По умолчанию переопределения этого метода следует удалять объекты, если не [System.Management.Automation.Provider.Cmdletprovider.Force\*](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.Force) задано значение true.</span><span class="sxs-lookup"><span data-stu-id="d8740-271">By default, overrides of this method should not remove objects unless the [System.Management.Automation.Provider.Cmdletprovider.Force\*](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.Force) property is set to true.</span></span> <span data-ttu-id="d8740-272">Если указанный путь указывает на контейнер, [System.Management.Automation.Provider.Cmdletprovider.Force\*](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.Force) свойство не является обязательным.</span><span class="sxs-lookup"><span data-stu-id="d8740-272">If the specified path indicates a container, the [System.Management.Automation.Provider.Cmdletprovider.Force\*](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.Force) property is not required.</span></span>

- <span data-ttu-id="d8740-273">Реализация [System.Management.Automation.Provider.Containercmdletprovider.Removeitem\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.RemoveItem) отвечает за Предотвращение бесконечной рекурсии, при наличии циклических ссылок и т.п.</span><span class="sxs-lookup"><span data-stu-id="d8740-273">Your implementation of [System.Management.Automation.Provider.Containercmdletprovider.Removeitem\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.RemoveItem) is responsible for preventing infinite recursion when there are circular links, and the like.</span></span> <span data-ttu-id="d8740-274">Завершающий соответствующее исключение должно вызываться для отражения таких условий.</span><span class="sxs-lookup"><span data-stu-id="d8740-274">An appropriate terminating exception should be thrown to reflect such a condition.</span></span>

- <span data-ttu-id="d8740-275">Реализация [System.Management.Automation.Provider.Containercmdletprovider.Removeitem\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.RemoveItem) метод должен вызывать [System.Management.Automation.Provider.Cmdletprovider.ShouldProcess](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.ShouldProcess) и проверьте его возвращаемое значение перед внесением любых изменений в хранилище данных.</span><span class="sxs-lookup"><span data-stu-id="d8740-275">Your implementation of the [System.Management.Automation.Provider.Containercmdletprovider.Removeitem\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.RemoveItem) method should call [System.Management.Automation.Provider.Cmdletprovider.ShouldProcess](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.ShouldProcess) and check its return value before making any changes to the data store.</span></span> <span data-ttu-id="d8740-276">После вызова [System.Management.Automation.Provider.Cmdletprovider.ShouldProcess](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.ShouldProcess) возвращает `true`, [System.Management.Automation.Provider.Containercmdletprovider.Removeitem\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.RemoveItem) метод должен вызывать [System.Management.Automation.Provider.Cmdletprovider.ShouldContinue](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.ShouldContinue) метод как дополнительную проверку для изменения потенциально опасных системы.</span><span class="sxs-lookup"><span data-stu-id="d8740-276">After the call to [System.Management.Automation.Provider.Cmdletprovider.ShouldProcess](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.ShouldProcess) returns `true`, the [System.Management.Automation.Provider.Containercmdletprovider.Removeitem\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.RemoveItem) method should call the [System.Management.Automation.Provider.Cmdletprovider.ShouldContinue](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.ShouldContinue) method as an additional check for potentially dangerous system modifications.</span></span>

## <a name="attaching-dynamic-parameters-to-the-remove-item-cmdlet"></a><span data-ttu-id="d8740-277">Присоединение динамических параметров в командлет Remove-Item</span><span class="sxs-lookup"><span data-stu-id="d8740-277">Attaching Dynamic Parameters to the Remove-Item Cmdlet</span></span>

<span data-ttu-id="d8740-278">Иногда `Remove-Item` командлета требуется Дополнительные параметры, заданные динамически во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="d8740-278">Sometimes the `Remove-Item` cmdlet requires additional parameters that are specified dynamically at runtime.</span></span> <span data-ttu-id="d8740-279">Для обеспечения этих динамических параметров, необходимо реализовать поставщик контейнеров [System.Management.Automation.Provider.Containercmdletprovider.Removeitemdynamicparameters\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.RemoveItemDynamicParameters) метод для обработки этих параметров.</span><span class="sxs-lookup"><span data-stu-id="d8740-279">To provide these dynamic parameters, the container provider must implement the [System.Management.Automation.Provider.Containercmdletprovider.Removeitemdynamicparameters\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.RemoveItemDynamicParameters) method to handle these parameters.</span></span> <span data-ttu-id="d8740-280">Этот метод получает динамические параметры для элемента в заданный путь и возвращает объект, имеющий свойства и поля с разбор атрибутов, аналогично классу командлета или [ System.Management.Automation.Runtimedefinedparameterdictionary](/dotnet/api/System.Management.Automation.RuntimeDefinedParameterDictionary) объекта.</span><span class="sxs-lookup"><span data-stu-id="d8740-280">This method retrieves the dynamic parameters for the item at the indicated path and returns an object that has properties and fields with parsing attributes similar to a cmdlet class or a [System.Management.Automation.Runtimedefinedparameterdictionary](/dotnet/api/System.Management.Automation.RuntimeDefinedParameterDictionary) object.</span></span> <span data-ttu-id="d8740-281">Среда выполнения Windows PowerShell использует возвращенный объект для добавления параметров к `Remove-Item` командлета.</span><span class="sxs-lookup"><span data-stu-id="d8740-281">The Windows PowerShell runtime uses the returned object to add the parameters to the `Remove-Item` cmdlet.</span></span>

<span data-ttu-id="d8740-282">Этот контейнер поставщик не реализует этот метод.</span><span class="sxs-lookup"><span data-stu-id="d8740-282">This container provider does not implement this method.</span></span> <span data-ttu-id="d8740-283">Тем не менее, следующий код является реализация по умолчанию [System.Management.Automation.Provider.Containercmdletprovider.Removeitemdynamicparameters\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.RemoveItemDynamicParameters).</span><span class="sxs-lookup"><span data-stu-id="d8740-283">However, the following code is the default implementation of [System.Management.Automation.Provider.Containercmdletprovider.Removeitemdynamicparameters\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.RemoveItemDynamicParameters).</span></span>

<!-- TODO!!!: review snippet reference  [!CODE [Msh_samplestestcmdlets#testproviderremoveitemdynamicparameters](Msh_samplestestcmdlets#testproviderremoveitemdynamicparameters)]  -->

## <a name="querying-for-child-items"></a><span data-ttu-id="d8740-284">Запрос для дочерних элементов</span><span class="sxs-lookup"><span data-stu-id="d8740-284">Querying for Child Items</span></span>

<span data-ttu-id="d8740-285">Для проверки существования дочерних элементов по указанному пути, необходимо переопределить поставщик контейнеров Windows PowerShell [System.Management.Automation.Provider.Containercmdletprovider.Haschilditems\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.HasChildItems) метод.</span><span class="sxs-lookup"><span data-stu-id="d8740-285">To check to see if child items exist at the specified path, the Windows PowerShell container provider must override the [System.Management.Automation.Provider.Containercmdletprovider.Haschilditems\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.HasChildItems) method.</span></span> <span data-ttu-id="d8740-286">Этот метод возвращает `true` Если элемент имеет дочерние элементы, и `false` в противном случае.</span><span class="sxs-lookup"><span data-stu-id="d8740-286">This method returns `true` if the item has children, and `false` otherwise.</span></span> <span data-ttu-id="d8740-287">Значение null или пустой путь к, метод считает, что все элементы в хранилище данных как дочерние элементы и возвращает `true`.</span><span class="sxs-lookup"><span data-stu-id="d8740-287">For a null or empty path, the method considers any items in the data store to be children and returns `true`.</span></span>

<span data-ttu-id="d8740-288">Вот переопределение для [System.Management.Automation.Provider.Containercmdletprovider.Haschilditems\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.HasChildItems) метод.</span><span class="sxs-lookup"><span data-stu-id="d8740-288">Here is the override for the [System.Management.Automation.Provider.Containercmdletprovider.Haschilditems\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.HasChildItems) method.</span></span> <span data-ttu-id="d8740-289">Если существует более двух частей пути, созданным с помощью вспомогательного метода ChunkPath, метод возвращает `false`, поскольку определяются только контейнер базы данных и таблицы.</span><span class="sxs-lookup"><span data-stu-id="d8740-289">If there are more than two path parts created by the ChunkPath helper method, the method returns `false`, since only a database container and a table container are defined.</span></span> <span data-ttu-id="d8740-290">Дополнительные сведения о этот вспомогательный метод, см. в статье рассматривается метод ChunkPath [Создание поставщика Windows PowerShell элемента](./creating-a-windows-powershell-item-provider.md).</span><span class="sxs-lookup"><span data-stu-id="d8740-290">For more information about this helper method, see the ChunkPath method is discussed in [Creating a Windows PowerShell Item Provider](./creating-a-windows-powershell-item-provider.md).</span></span>

```csharp
protected override bool HasChildItems( string path )
{
    return false;
} // HasChildItems
```

[!code-csharp[AccessDBProviderSample04.cs](../../powershell-sdk-samples/SDK-2.0/csharp/AccessDBProviderSample04/AccessDBProviderSample04.cs#L1094-L1097 "AccessDBProviderSample04.cs")]

#### <a name="things-to-remember-about-implementing-haschilditems"></a><span data-ttu-id="d8740-291">О чем следует помнить о реализации HasChildItems</span><span class="sxs-lookup"><span data-stu-id="d8740-291">Things to Remember About Implementing HasChildItems</span></span>

<span data-ttu-id="d8740-292">Следующие условия могут относиться к реализации [System.Management.Automation.Provider.Containercmdletprovider.Haschilditems\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.HasChildItems):</span><span class="sxs-lookup"><span data-stu-id="d8740-292">The following conditions may apply to your implementation of [System.Management.Automation.Provider.Containercmdletprovider.Haschilditems\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.HasChildItems):</span></span>

- <span data-ttu-id="d8740-293">Если поставщик контейнер предоставляет корневой элемент, содержащий интересные точки подключения, реализация [System.Management.Automation.Provider.Containercmdletprovider.Haschilditems\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.HasChildItems) метод должен возвращать `true`когда значение null или пустая строка передается в для пути.</span><span class="sxs-lookup"><span data-stu-id="d8740-293">If the container provider exposes a root that contains interesting mount points, the implementation of the [System.Management.Automation.Provider.Containercmdletprovider.Haschilditems\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.HasChildItems) method should return `true` when a null or an empty string is passed in for the path.</span></span>

## <a name="copying-items"></a><span data-ttu-id="d8740-294">Копирование элементов</span><span class="sxs-lookup"><span data-stu-id="d8740-294">Copying Items</span></span>

<span data-ttu-id="d8740-295">Копирование элементов, необходимо реализовать поставщик контейнеров [System.Management.Automation.Provider.ContainerCmdletProvider.CopyItem](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.CopyItem) метод для поддержки вызовов из `Copy-Item` командлета.</span><span class="sxs-lookup"><span data-stu-id="d8740-295">To copy items, the container provider must implement the [System.Management.Automation.Provider.ContainerCmdletProvider.CopyItem](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.CopyItem) method to support calls from the `Copy-Item` cmdlet.</span></span> <span data-ttu-id="d8740-296">Этот метод копирует элемент данных из местоположения, указанного параметром `path` параметр командлета для местоположения, указанного параметром `copyPath` параметр.</span><span class="sxs-lookup"><span data-stu-id="d8740-296">This method copies a data item from the location indicated by the `path` parameter of the cmdlet to the location indicated by the `copyPath` parameter.</span></span> <span data-ttu-id="d8740-297">Если `recurse` параметр указан, метод копирует всех вложенных контейнерах.</span><span class="sxs-lookup"><span data-stu-id="d8740-297">If the `recurse` parameter is specified, the method copies all sub-containers.</span></span> <span data-ttu-id="d8740-298">Если этот параметр не указан, метод копирует только один уровень элементов.</span><span class="sxs-lookup"><span data-stu-id="d8740-298">If the parameter is not specified, the method copies only a single level of items.</span></span>

<span data-ttu-id="d8740-299">Этот поставщик не реализует этот метод.</span><span class="sxs-lookup"><span data-stu-id="d8740-299">This provider does not implement this method.</span></span> <span data-ttu-id="d8740-300">Тем не менее, следующий код является реализация по умолчанию [System.Management.Automation.Provider.ContainerCmdletProvider.CopyItem](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.CopyItem).</span><span class="sxs-lookup"><span data-stu-id="d8740-300">However, the following code is the default implementation of [System.Management.Automation.Provider.ContainerCmdletProvider.CopyItem](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.CopyItem).</span></span>

<!-- TODO!!!: review snippet reference  [!CODE [Msh_samplestestcmdlets#testprovidercopyitem](Msh_samplestestcmdlets#testprovidercopyitem)]  -->

#### <a name="things-to-remember-about-implementing-copyitem"></a><span data-ttu-id="d8740-301">О чем следует помнить о реализации CopyItem</span><span class="sxs-lookup"><span data-stu-id="d8740-301">Things to Remember About Implementing CopyItem</span></span>

<span data-ttu-id="d8740-302">Следующие условия могут относиться к реализации [System.Management.Automation.Provider.ContainerCmdletProvider.CopyItem](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.CopyItem):</span><span class="sxs-lookup"><span data-stu-id="d8740-302">The following conditions may apply to your implementation of [System.Management.Automation.Provider.ContainerCmdletProvider.CopyItem](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.CopyItem):</span></span>

- <span data-ttu-id="d8740-303">При определении класса поставщика, поставщик контейнеров Windows PowerShell может объявлять возможностей поставщика ExpandWildcards фильтра, Include и Exclude, из [System.Management.Automation.Provider.Providercapabilities](/dotnet/api/System.Management.Automation.Provider.ProviderCapabilities) перечисления.</span><span class="sxs-lookup"><span data-stu-id="d8740-303">When defining the provider class, a Windows PowerShell container provider might declare provider capabilities of ExpandWildcards, Filter, Include, or Exclude, from the [System.Management.Automation.Provider.Providercapabilities](/dotnet/api/System.Management.Automation.Provider.ProviderCapabilities) enumeration.</span></span> <span data-ttu-id="d8740-304">В этих случаях реализация [System.Management.Automation.Provider.Containercmdletprovider.Getchilditems\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.GetChildItems) метод должен соответствовать требованиям указанного пути, передаваемые методу возможности.</span><span class="sxs-lookup"><span data-stu-id="d8740-304">In these cases, the implementation of the [System.Management.Automation.Provider.Containercmdletprovider.Getchilditems\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.GetChildItems) method needs to ensure that the path passed to the method meets the requirements of the specified capabilities.</span></span> <span data-ttu-id="d8740-305">Чтобы сделать это, метод должен получить доступ к соответствующее свойство, например, [System.Management.Automation.Provider.Cmdletprovider.Exclude\*](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.Exclude) и [ System.Management.Automation.Provider.Cmdletprovider.Include\*](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.Include) свойства.</span><span class="sxs-lookup"><span data-stu-id="d8740-305">To do this, the method should access the appropriate property, for example, the [System.Management.Automation.Provider.Cmdletprovider.Exclude\*](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.Exclude) and [System.Management.Automation.Provider.Cmdletprovider.Include\*](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.Include) properties.</span></span>

- <span data-ttu-id="d8740-306">По умолчанию переопределения этого метода не следует копировать объекты через существующие объекты Если [System.Management.Automation.Provider.Cmdletprovider.Force\*](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.Force) свойству `true`.</span><span class="sxs-lookup"><span data-stu-id="d8740-306">By default, overrides of this method should not copy objects over existing objects unless the [System.Management.Automation.Provider.Cmdletprovider.Force\*](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.Force) property is set to `true`.</span></span> <span data-ttu-id="d8740-307">Например, поставщик FileSystem не будет копировать c:\temp\abc.txt через существующий файл c:\abc.txt Если [System.Management.Automation.Provider.Cmdletprovider.Force\*](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.Force) свойству `true`.</span><span class="sxs-lookup"><span data-stu-id="d8740-307">For example, the FileSystem provider will not copy c:\temp\abc.txt over an existing c:\abc.txt file unless the [System.Management.Automation.Provider.Cmdletprovider.Force\*](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.Force) property is set to `true`.</span></span> <span data-ttu-id="d8740-308">Если путь, указанный в `copyPath` параметр существует и указывает контейнер, [System.Management.Automation.Provider.Cmdletprovider.Force\*](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.Force) свойство не является обязательным.</span><span class="sxs-lookup"><span data-stu-id="d8740-308">If the path specified in the `copyPath` parameter exists and indicates a container, the [System.Management.Automation.Provider.Cmdletprovider.Force\*](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.Force) property is not required.</span></span> <span data-ttu-id="d8740-309">В этом случае [System.Management.Automation.Provider.ContainerCmdletProvider.CopyItem](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.CopyItem) следует скопировать элемент обозначается `path` параметр в контейнер обозначается `copyPath` параметр как дочерний элемент.</span><span class="sxs-lookup"><span data-stu-id="d8740-309">In this case, [System.Management.Automation.Provider.ContainerCmdletProvider.CopyItem](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.CopyItem) should copy the item indicated by the `path` parameter to the container indicated by the `copyPath` parameter as a child.</span></span>

- <span data-ttu-id="d8740-310">Реализация [System.Management.Automation.Provider.ContainerCmdletProvider.CopyItem](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.CopyItem) отвечает за Предотвращение бесконечной рекурсии, при наличии циклических ссылок и т.п.</span><span class="sxs-lookup"><span data-stu-id="d8740-310">Your implementation of [System.Management.Automation.Provider.ContainerCmdletProvider.CopyItem](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.CopyItem) is responsible for preventing infinite recursion when there are circular links, and the like.</span></span> <span data-ttu-id="d8740-311">Завершающий соответствующее исключение должно вызываться для отражения таких условий.</span><span class="sxs-lookup"><span data-stu-id="d8740-311">An appropriate terminating exception should be thrown to reflect such a condition.</span></span>

- <span data-ttu-id="d8740-312">Реализация [System.Management.Automation.Provider.ContainerCmdletProvider.CopyItem](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.CopyItem) метод должен вызывать [System.Management.Automation.Provider.Cmdletprovider.ShouldProcess](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.ShouldProcess) и проверьте его возвращаемое значение перед внесением любых изменений в хранилище данных.</span><span class="sxs-lookup"><span data-stu-id="d8740-312">Your implementation of the [System.Management.Automation.Provider.ContainerCmdletProvider.CopyItem](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.CopyItem) method should call [System.Management.Automation.Provider.Cmdletprovider.ShouldProcess](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.ShouldProcess) and check its return value before making any changes to the data store.</span></span> <span data-ttu-id="d8740-313">После вызова [System.Management.Automation.Provider.Cmdletprovider.ShouldProcess](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.ShouldProcess) возвращает значение true, [System.Management.Automation.Provider.ContainerCmdletProvider.CopyItem](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.CopyItem) метод должен вызывать [System.Management.Automation.Provider.Cmdletprovider.ShouldContinue](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.ShouldContinue) метод как дополнительную проверку для изменения потенциально опасных системы.</span><span class="sxs-lookup"><span data-stu-id="d8740-313">After the call to [System.Management.Automation.Provider.Cmdletprovider.ShouldProcess](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.ShouldProcess) returns true, the [System.Management.Automation.Provider.ContainerCmdletProvider.CopyItem](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.CopyItem) method should call the [System.Management.Automation.Provider.Cmdletprovider.ShouldContinue](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.ShouldContinue) method as an additional check for potentially dangerous system modifications.</span></span> <span data-ttu-id="d8740-314">Дополнительные сведения о вызове этих методов, см. в разделе [переименование элементов](#Renaming-Items).</span><span class="sxs-lookup"><span data-stu-id="d8740-314">For more information about calling these methods, see [Rename Items](#Renaming-Items).</span></span>

## <a name="attaching-dynamic-parameters-to-the-copy-item-cmdlet"></a><span data-ttu-id="d8740-315">Присоединение динамических параметров в командлет Copy-Item</span><span class="sxs-lookup"><span data-stu-id="d8740-315">Attaching Dynamic Parameters to the Copy-Item Cmdlet</span></span>

<span data-ttu-id="d8740-316">Иногда `Copy-Item` командлета требуется Дополнительные параметры, заданные динамически во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="d8740-316">Sometimes the `Copy-Item` cmdlet requires additional parameters that are specified dynamically at runtime.</span></span> <span data-ttu-id="d8740-317">Для обеспечения этих динамических параметров, необходимо реализовать поставщик контейнеров Windows PowerShell [System.Management.Automation.Provider.Containercmdletprovider.Copyitemdynamicparameters\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.CopyItemDynamicParameters) метод для обработки этих параметры.</span><span class="sxs-lookup"><span data-stu-id="d8740-317">To provide these dynamic parameters, the Windows PowerShell container provider must implement the [System.Management.Automation.Provider.Containercmdletprovider.Copyitemdynamicparameters\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.CopyItemDynamicParameters) method to handle these parameters.</span></span> <span data-ttu-id="d8740-318">Этот метод извлекает параметры для элемента в заданный путь и возвращает объект, имеющий свойства и поля с разбор атрибутов, аналогично классу командлета или [System.Management.Automation.Runtimedefinedparameterdictionary ](/dotnet/api/System.Management.Automation.RuntimeDefinedParameterDictionary) объекта.</span><span class="sxs-lookup"><span data-stu-id="d8740-318">This method retrieves the parameters for the item at the indicated path and returns an object that has properties and fields with parsing attributes similar to a cmdlet class or a [System.Management.Automation.Runtimedefinedparameterdictionary](/dotnet/api/System.Management.Automation.RuntimeDefinedParameterDictionary) object.</span></span> <span data-ttu-id="d8740-319">Среда выполнения Windows PowerShell использует возвращенный объект для добавления параметров к `Copy-Item` командлета.</span><span class="sxs-lookup"><span data-stu-id="d8740-319">The Windows PowerShell runtime uses the returned object to add the parameters to the `Copy-Item` cmdlet.</span></span>

<span data-ttu-id="d8740-320">Этот поставщик не реализует этот метод.</span><span class="sxs-lookup"><span data-stu-id="d8740-320">This provider does not implement this method.</span></span> <span data-ttu-id="d8740-321">Тем не менее, следующий код является реализация по умолчанию [System.Management.Automation.Provider.Containercmdletprovider.Copyitemdynamicparameters\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.CopyItemDynamicParameters).</span><span class="sxs-lookup"><span data-stu-id="d8740-321">However, the following code is the default implementation of [System.Management.Automation.Provider.Containercmdletprovider.Copyitemdynamicparameters\*](/dotnet/api/System.Management.Automation.Provider.ContainerCmdletProvider.CopyItemDynamicParameters).</span></span>

<!-- TODO!!!: review snippet reference  [!CODE [Msh_samplestestcmdlets#testprovidercopyitemdynamicparameters](Msh_samplestestcmdlets#testprovidercopyitemdynamicparameters)]  -->

## <a name="code-sample"></a><span data-ttu-id="d8740-322">Пример кода</span><span class="sxs-lookup"><span data-stu-id="d8740-322">Code Sample</span></span>

<span data-ttu-id="d8740-323">Полный пример кода см. в разделе [пример кода AccessDbProviderSample04](./accessdbprovidersample04-code-sample.md).</span><span class="sxs-lookup"><span data-stu-id="d8740-323">For complete sample code, see [AccessDbProviderSample04 Code Sample](./accessdbprovidersample04-code-sample.md).</span></span>

## <a name="building-the-windows-powershell-provider"></a><span data-ttu-id="d8740-324">Создание поставщика Windows PowerShell</span><span class="sxs-lookup"><span data-stu-id="d8740-324">Building the Windows PowerShell Provider</span></span>

<span data-ttu-id="d8740-325">См. в разделе [регистрация командлетов, поставщиков и размещения приложений](http://msdn.microsoft.com/en-us/a41e9054-29c8-40ab-bf2b-8ce4e7ec1c8c).</span><span class="sxs-lookup"><span data-stu-id="d8740-325">See [How to Register Cmdlets, Providers, and Host Applications](http://msdn.microsoft.com/en-us/a41e9054-29c8-40ab-bf2b-8ce4e7ec1c8c).</span></span>

## <a name="testing-the-windows-powershell-provider"></a><span data-ttu-id="d8740-326">Проверка поставщика в Windows PowerShell</span><span class="sxs-lookup"><span data-stu-id="d8740-326">Testing the Windows PowerShell Provider</span></span>

<span data-ttu-id="d8740-327">При регистрации поставщика Windows PowerShell с помощью Windows PowerShell можно проверить его с помощью командлетов поддерживаемых в командной строке.</span><span class="sxs-lookup"><span data-stu-id="d8740-327">When your Windows PowerShell provider has been registered with Windows PowerShell, you can test it by running the supported cmdlets on the command line.</span></span> <span data-ttu-id="d8740-328">Имейте в виду, что в следующем примере выходных данных используется вымышленная базы данных Access.</span><span class="sxs-lookup"><span data-stu-id="d8740-328">Be aware that the following example output uses a fictitious Access database.</span></span>

1. <span data-ttu-id="d8740-329">Запустите `Get-ChildItem` командлет, чтобы получить список дочерних элементов из таблицы Customers в базе данных Access.</span><span class="sxs-lookup"><span data-stu-id="d8740-329">Run the `Get-ChildItem` cmdlet to retrieve the list of child items from a Customers table in the Access database.</span></span>

   ```powershell
   Get-ChildItem mydb:customers
   ```

   <span data-ttu-id="d8740-330">Появляется следующий результат.</span><span class="sxs-lookup"><span data-stu-id="d8740-330">The following output appears.</span></span>

   ```output
   PSPath        : AccessDB::customers
   PSDrive       : mydb
   PSProvider    : System.Management.Automation.ProviderInfo
   PSIsContainer : True
   Data          : System.Data.DataRow
   Name          : Customers
   RowCount      : 91
   Columns       :
   ```

2. <span data-ttu-id="d8740-331">Запустите `Get-ChildItem` еще раз, чтобы получить данные из таблицы.</span><span class="sxs-lookup"><span data-stu-id="d8740-331">Run the `Get-ChildItem` cmdlet again to retrieve the data of a table.</span></span>

   ```powershell
   (Get-ChildItem mydb:customers).data
   ```

   <span data-ttu-id="d8740-332">Появляется следующий результат.</span><span class="sxs-lookup"><span data-stu-id="d8740-332">The following output appears.</span></span>

   ```output
   TABLE_CAT   : c:\PS\northwind
   TABLE_SCHEM :
   TABLE_NAME  : Customers
   TABLE_TYPE  : TABLE
   REMARKS     :
   ```

3. <span data-ttu-id="d8740-333">Теперь с помощью `Get-Item` командлет для получения элементов в строке 0 в таблице данных.</span><span class="sxs-lookup"><span data-stu-id="d8740-333">Now use the `Get-Item` cmdlet to retrieve the items at row 0 in the data table.</span></span>

   ```powershell
   Get-Item mydb:\customers\0
   ```

   <span data-ttu-id="d8740-334">Появляется следующий результат.</span><span class="sxs-lookup"><span data-stu-id="d8740-334">The following output appears.</span></span>

   ```output
   PSPath        : AccessDB::customers\0
   PSDrive       : mydb
   PSProvider    : System.Management.Automation.ProviderInfo
   PSIsContainer : False
   Data          : System.Data.DataRow
   RowNumber     : 0
   ```

4. <span data-ttu-id="d8740-335">Повторно использовать `Get-Item` для получения данных для элементов в строке 0.</span><span class="sxs-lookup"><span data-stu-id="d8740-335">Reuse `Get-Item` to retrieve the data for the items in row 0.</span></span>

   ```powershell
   (Get-Item mydb:\customers\0).data
   ```

   <span data-ttu-id="d8740-336">Появляется следующий результат.</span><span class="sxs-lookup"><span data-stu-id="d8740-336">The following output appears.</span></span>

   ```output
   CustomerID   : 1234
   CompanyName  : Fabrikam
   ContactName  : Eric Gruber
   ContactTitle : President
   Address      : 4567 Main Street
   City         : Buffalo
   Region       : NY
   PostalCode   : 98052
   Country      : USA
   Phone        : (425) 555-0100
   Fax          : (425) 555-0101
   ```

5. <span data-ttu-id="d8740-337">Теперь с помощью `New-Item` командлет, чтобы добавить строку в существующую таблицу.</span><span class="sxs-lookup"><span data-stu-id="d8740-337">Now use the `New-Item` cmdlet to add a row to an existing table.</span></span> <span data-ttu-id="d8740-338">`Path` Определяет полный путь к строке и необходимо указать номер строки, больше, чем существующего количества строк в таблице.</span><span class="sxs-lookup"><span data-stu-id="d8740-338">The `Path` parameter specifies the full path to the row, and must indicate a row number that is greater than the existing number of rows in the table.</span></span> <span data-ttu-id="d8740-339">`Type` Задаёт «row», для указания типа добавляемого элемента.</span><span class="sxs-lookup"><span data-stu-id="d8740-339">The `Type` parameter indicates "row" to specify that type of item to add.</span></span> <span data-ttu-id="d8740-340">Наконец `Value` параметр задает разделенный запятыми список значений столбцов для строки.</span><span class="sxs-lookup"><span data-stu-id="d8740-340">Finally, the `Value` parameter specifies a comma-delimited list of column values for the row.</span></span>

   ```powershell
   New-Item -Path mydb:\Customers\3 -ItemType "row" -Value "3,CustomerFirstName,CustomerLastName,CustomerEmailAddress,CustomerTitle,CustomerCompany,CustomerPhone, CustomerAddress,CustomerCity,CustomerState,CustomerZip,CustomerCountry"
   ```

6. <span data-ttu-id="d8740-341">Проверьте правильность работы нового элемента следующим образом.</span><span class="sxs-lookup"><span data-stu-id="d8740-341">Verify the correctness of the new item operation as follows.</span></span>

   ```none
   PS mydb:\> cd Customers
   PS mydb:\Customers> (Get-Item 3).data
   ```

   <span data-ttu-id="d8740-342">Появляется следующий результат.</span><span class="sxs-lookup"><span data-stu-id="d8740-342">The following output appears.</span></span>

   ```output
   ID        : 3
   FirstName : Eric
   LastName  : Gruber
   Email     : ericgruber@fabrikam.com
   Title     : President
   Company   : Fabrikam
   WorkPhone : (425) 555-0100
   Address   : 4567 Main Street
   City      : Buffalo
   State     : NY
   Zip       : 98052
   Country   : USA
   ```

## <a name="see-also"></a><span data-ttu-id="d8740-343">См. также</span><span class="sxs-lookup"><span data-stu-id="d8740-343">See Also</span></span>

[<span data-ttu-id="d8740-344">Создание поставщиков Windows PowerShell</span><span class="sxs-lookup"><span data-stu-id="d8740-344">Creating Windows PowerShell Providers</span></span>](./how-to-create-a-windows-powershell-provider.md)

[<span data-ttu-id="d8740-345">Разработка поставщика Windows PowerShell</span><span class="sxs-lookup"><span data-stu-id="d8740-345">Designing Your Windows PowerShell Provider</span></span>](./designing-your-windows-powershell-provider.md)

[<span data-ttu-id="d8740-346">Реализация поставщика элементов Windows PowerShell</span><span class="sxs-lookup"><span data-stu-id="d8740-346">Implementing an Item Windows PowerShell Provider</span></span>](./creating-a-windows-powershell-item-provider.md)

[<span data-ttu-id="d8740-347">Реализация поставщика навигации Windows PowerShell</span><span class="sxs-lookup"><span data-stu-id="d8740-347">Implementing a Navigation Windows PowerShell Provider</span></span>](./creating-a-windows-powershell-navigation-provider.md)

[<span data-ttu-id="d8740-348">Регистрация командлетов, поставщиков и ведущих приложений</span><span class="sxs-lookup"><span data-stu-id="d8740-348">How to Register Cmdlets, Providers, and Host Applications</span></span>](http://msdn.microsoft.com/en-us/a41e9054-29c8-40ab-bf2b-8ce4e7ec1c8c)

[<span data-ttu-id="d8740-349">Пакет SDK для Windows PowerShell</span><span class="sxs-lookup"><span data-stu-id="d8740-349">Windows PowerShell SDK</span></span>](../windows-powershell-reference.md)

[<span data-ttu-id="d8740-350">Руководство программиста Windows PowerShell</span><span class="sxs-lookup"><span data-stu-id="d8740-350">Windows PowerShell Programmer's Guide</span></span>](./windows-powershell-programmer-s-guide.md)