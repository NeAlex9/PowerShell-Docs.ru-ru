---
title: Настоятельно рекомендуется рекомендации по разработке | Документация Майкрософт
ms.custom: ''
ms.date: 09/13/2016
ms.reviewer: ''
ms.suite: ''
ms.tgt_pltfrm: ''
ms.topic: article
ms.assetid: 4d68a8f3-fba0-44c5-97b9-9fc191d269a5
caps.latest.revision: 13
ms.openlocfilehash: 0906d0d37c66b8c1538a0b2e9e0f1ff2fba12ac0
ms.sourcegitcommit: e7445ba8203da304286c591ff513900ad1c244a4
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "62067371"
---
# <a name="strongly-encouraged-development-guidelines"></a>Настоятельные рекомендации по разработке

В этом разделе описываются рекомендации, которым необходимо следовать при написании командлетов. Они разделяются на рекомендации по разработке командлетов и рекомендации по написанию кода командлета. Может оказаться, что эти рекомендации не применяются для всех сценариев. Тем не менее если они применяются и не следовать рекомендациям, у пользователей могут быть слишком ограничивать возможности при использовании командлетов.

## <a name="design-guidelines"></a>Рекомендации по проектированию

- [Использовать специальное существительное для имени командлета (SD01)](./strongly-encouraged-development-guidelines.md#use-a-specific-noun-for-a-cmdlet-name-sd01)

- [Вариант использования Pascal для имен командлетов (SD02)](./strongly-encouraged-development-guidelines.md#use-pascal-case-for-cmdlet-names-sd02)

- [Рекомендации по проектированию параметра (SD03)](./strongly-encouraged-development-guidelines.md#parameter-design-guidelines-sd03)

- [Отзыв для пользователя (SD04)](./strongly-encouraged-development-guidelines.md#provide-feedback-to-the-user-sd04)

- [Создайте файл справки по командлетам (SD05)](./strongly-encouraged-development-guidelines.md#create-a-cmdlet-help-file-sd05)

## <a name="code-guidelines"></a>Руководствам по кодам

- [Параметры кодирования (SC01)](./strongly-encouraged-development-guidelines.md#coding-parameters-sc01)

- [Поддерживает входные данные из хорошо определенного конвейера (SC02)](./strongly-encouraged-development-guidelines.md#support-well-defined-pipeline-input-sc02)

- [Одной записи в конвейер (SC03)](./strongly-encouraged-development-guidelines.md#write-single-records-to-the-pipeline-sc03)

- [Сделать командлеты без учета регистра и меняющее регистр (SC04)](./strongly-encouraged-development-guidelines.md#make-cmdlets-case-insensitive-and-case-preserving-sc04)

## <a name="design-guidelines"></a>Рекомендации по проектированию

Следующие рекомендации необходимо соблюдать при разработке командлетов, чтобы обеспечить согласованность пользовательского интерфейса между использованием командлетов и другие командлеты. Когда вы найдете рекомендации разработки для этого применяется в вашей ситуации, убедитесь, что рассмотрим руководствам по кодам аналогичные инструкции.

### <a name="use-a-specific-noun-for-a-cmdlet-name-sd01"></a>Использовать специальное существительное для имени командлета (SD01)

Существительные, используемый в названии командлета должны быть предельно точным, таким образом, пользователь может обнаруживать командлеты. Префикс универсального существительные, например «server» с сокращенную версию имя продукта. Например если существительное ссылается на сервер, на котором выполняется экземпляр Microsoft SQL Server, используйте существительное, например «SQLServer». Сочетание определенных существительные и краткий список утвержденных глаголов пользователи могли быстро обнаруживать и обеспечивает их функциональность, избегая дублирование между именами командлетов.

Чтобы повысить удобство работы пользователей, существительное, выбранный для имени командлета должно быть единственного числа. Например, используйте имя `Get-Process` вместо **процессы Get**. Лучше всего исключением из этого правила для все имена командлетов, даже в том случае, если командлет является скорее всего, с которым выполняется действие более одного элемента.

### <a name="use-pascal-case-for-cmdlet-names-sd02"></a>Вариант использования Pascal для имен командлетов (SD02)

Используйте верхнего регистра для имен параметров. Другими словами преобразование первой буквы команды и всех терминов, используемых в существительное. Например "`Clear-ItemProperty`«.

### <a name="parameter-design-guidelines-sd03"></a>Рекомендации по проектированию параметра (SD03)

Командлет должен параметров, которые получают данные, на котором она должна работать, и параметры, которые указывают сведения, используемые для определения характеристик операции. Например, командлет может иметь `Name` может иметь параметр, который получает данные из конвейера и командлет `Force` параметр, чтобы указать, что командлет можно заставить его выполнения. Число параметров, определяющих командлет не ограничено.

#### <a name="use-standard-parameter-names"></a>Использовать имена стандартных параметров

Таким образом, пользователь может быстро определить, что определенный параметр, командлет следует использовать имена стандартных параметров. Если требуется более конкретное имя, используйте имя стандартных параметров и укажите в качестве псевдонима более конкретное имя. Например `Get-Service` командлет имеет параметр, который имеет универсальное имя (`Name`) и более конкретные псевдоним (`ServiceName`). Оба условия можно использовать для указания параметра.

Дополнительные сведения о имена параметров и их типы данных, см. в разделе [имя параметра командлета и функциональные возможности инструкции](./standard-cmdlet-parameter-names-and-types.md).

#### <a name="use-singular-parameter-names"></a>Использовать имена параметров в единственном числе

Старайтесь не использовать имена во множественном числе для параметров, значение которого является одиночным элементом. Это включает в себя параметры, которые принимают массивов или списков так, как пользователь может предоставить массив или список с единственным элементом.

Имена во множественном числе параметров следует использовать только в тех случаях, где значение параметра всегда является значение несколько элемента. В этих случаях командлет проверяют, предоставляются несколько элементов, что командлет должен отображаться предупреждение для пользователя, если не указаны несколько элементов.

#### <a name="use-pascal-case-for-parameter-names"></a>Вариант использования языка Pascal, для определения имен параметров

Используйте верхнего регистра для имен параметров. Другими словами преобразование первой буквы каждого слова в имени параметра, включая первую букву имени. Например, имя параметра `ErrorAction` использует правильный регистр. Следующие имена параметров используйте неправильный регистр символов:

- `errorAction`

- `erroraction`

#### <a name="parameters-that-take-a-list-of-options"></a>Параметры, которые принимают список параметров

Чтобы создать параметр, значение которого могут быть выбраны из набора параметров двумя способами.

- Определение типа перечисления (или использовать существующий тип перечисления), указывающий допустимые значения. Затем применение типа перечисления, чтобы создать параметр этого типа.

- Добавить **ValidateSet** для объявления параметра атрибута. Дополнительные сведения об этом атрибуте см. в разделе [объявление атрибута ValidateSet](./validateset-attribute-declaration.md).

#### <a name="use-standard-types-for-parameters"></a>Используйте стандартные типы для параметров

Чтобы обеспечить согласованность с другими командлетами, там, где каждый раз можно используйте стандартные типы для параметров. Дополнительные сведения о типах, которые должны использоваться для различных параметров см. в разделе [стандартные имена параметров командлета и типы](./standard-cmdlet-parameter-names-and-types.md). В этом разделе содержит ссылки на разделы, описывающие имена и типы .NET Framework для групп стандартные параметры, такие как «параметры действий».

#### <a name="use-strongly-typed-net-framework-types"></a>Использование типов со строгой типизацией .NET Framework

Параметры должны быть определены как типы .NET Framework для обеспечения лучшей проверки параметра. Например параметры, которые доступны только для одного значения из набора значений должен быть определен как тип перечисления. Чтобы обеспечить поддержку значение универсального кода ресурса (URI), определите параметр как [System.Uri](/dotnet/api/System.Uri) типа. Избегайте основных строковых параметров для свойств все, кроме текста в свободной форме.

#### <a name="use-consistent-parameter-types"></a>Использовать согласованные параметры типов

При использовании этого параметра с несколькими командлетами всегда используете один и тот же тип параметра.  Например если `Process` параметр [System.Int16](/dotnet/api/System.Int16) введите для одного командлета, не устанавливайте `Process` параметра другого командлета [System.Uint16](/dotnet/api/System.UInt16) типа.

#### <a name="parameters-that-take-true-and-false"></a>Параметры, которые принимают значение True и False

Если параметр принимает только `true` и `false`, определите параметр как тип [System.Management.Automation.SwitchParameter](/dotnet/api/System.Management.Automation.SwitchParameter). Параметр-переключатель, считается `true` когда он указан в команде. Если параметр не включен в команду, Windows PowerShell считает, что значение параметра быть `false`. Не следует определять логических параметров.

Если требуется различать три значения параметра: $true, $false и «unspecified», затем определить параметр типа Nullable\<bool >.  Потребность в сторонней, «unspecified» обычно появляется, когда командлета можно изменить логическое свойство объекта. В данном случае «unspecified» означает, чтобы не изменить текущее значение свойства.

#### <a name="support-arrays-for-parameters"></a>Поддерживает массивы параметров

Часто пользователи должны выполнять той же операции для нескольких аргументов. Для этих пользователей командлет должен принимать массив как параметр ввода, таким образом, пользователь может передать аргументы в качестве параметра, как это переменная Windows PowerShell. Например [Get-Process](/powershell/module/Microsoft.PowerShell.Management/Get-Process) командлет использует массив для строк, которые определяют имена процессов для извлечения.

#### <a name="support-the-passthru-parameter"></a>Поддерживает параметр PassThru

По умолчанию многие командлеты, вносят изменения в систему, такие как [Stop-Process](/powershell/module/Microsoft.PowerShell.Management/Stop-Process) командлета, выступать в роли «приемники» для объектов и не возвращать результат. Необходимо реализовать эти командлет `PassThru` параметр Force вызывает командлет для возвращения объекта. Когда `PassThru` параметр указан, командлет возвращает объект с помощью вызова [System.Management.Automation.Cmdlet.WriteObject](/dotnet/api/System.Management.Automation.Cmdlet.WriteObject) метод. Например следующая команда останавливает процесс Calc и передает результирующий процесс в конвейер.

```powershell
Stop-Process calc -passthru
```

В большинстве случаев должен поддерживать командлеты Add, Set и создать `PassThru` параметра.

#### <a name="support-parameter-sets"></a>Поддержка наборов параметров

Командлет предназначен для выполнения одной цели. Тем не менее часто есть более одного способа для описания операции или цели операции. Например процесс может быть определено по его имени, по его идентификатору или с помощью объекта процесса. Командлет должен поддерживать все разумные представления из его целевых объектов. Командлет, как правило, удовлетворяющее данному требованию, указав наборы параметров (которые называют наборов параметров), которые работают совместно. Один параметр может принадлежать к любому количеству наборов параметров. Дополнительные сведения о наборах параметров см. в разделе [командлет задает параметр](./cmdlet-parameter-sets.md).

При указании наборов параметров, задаются только один параметр в наборе для ValueFromPipeline. Дополнительные сведения о том, как объявить **параметр** атрибут, см. в разделе [ParameterAttribute объявление](./parameter-attribute-declaration.md).

При использовании наборов параметров, набор параметров по умолчанию определяется **командлет** атрибута. Набор параметров по умолчанию должен включать параметры, наиболее часто используемых в интерактивном сеансе Windows PowerShell. Дополнительные сведения о том, как объявить **командлет** атрибут, см. в разделе [объявление CmdletAttribute](./cmdlet-attribute-declaration.md).

### <a name="provide-feedback-to-the-user-sd04"></a>Отзыв для пользователя (SD04)

Используйте рекомендации в этом разделе для предоставления отзыва пользователю. Ваши отзывы позволяет пользователю, имейте в виду, происходящих в системе и принятия лучше административных решений.

Среда выполнения Windows PowerShell позволяет пользователю указать способ обработки выходных данных из каждого вызова к `Write` метод, задав привилегированной переменной. Пользователь может задать несколько привилегированных переменных, включая переменную, которая определяет, следует ли отображать системы, сведения и переменную, которая определяет, должна ли система запроса у пользователя, прежде чем выполнять другие действия.

#### <a name="support-the-writewarning-writeverbose-and-writedebug-methods"></a>Поддерживает WriteWarning WriteVerbose методов и метод WriteDebug

Необходимо вызвать командлет [System.Management.Automation.Cmdlet.WriteWarning](/dotnet/api/System.Management.Automation.Cmdlet.WriteWarning) метод, когда командлет собирается выполнить операцию, которую может иметь непредвиденные результаты. Например командлет необходимо вызвать этот метод, если командлет является перезаписать файл, доступный только для чтения.

Необходимо вызвать командлет [System.Management.Automation.Cmdlet.WriteVerbose](/dotnet/api/System.Management.Automation.Cmdlet.WriteVerbose) метод, когда пользователь необходимы некоторые подробные данные о действиях командлета. Например командлет необходимо вызвать эту информацию, если автор командлет полагает, что существуют сценарии, которые могут потребовать Дополнительные сведения о действиях командлета.

Необходимо вызвать командлет [System.Management.Automation.Cmdlet.WriteDebug](/dotnet/api/System.Management.Automation.Cmdlet.WriteDebug) метод при инженеру службы поддержки разработчиков или продукта, необходимо понимать, что повреждены и операции командлет. Это необязательно для командлета для вызова [System.Management.Automation.Cmdlet.WriteDebug](/dotnet/api/System.Management.Automation.Cmdlet.WriteDebug) метод в тот же код, который вызывает [System.Management.Automation.Cmdlet.WriteVerbose](/dotnet/api/System.Management.Automation.Cmdlet.WriteVerbose) метод так как `Debug` параметр представляется обоим наборам данных.

#### <a name="support-writeprogress-for-operations-that-take-a-long-time"></a>Поддержка WriteProgress операций, которые занимают много времени

Командлет операций, которые принимают много времени и, не могут работать в фоновом режиме должен поддерживать о ходе выполнения периодических вызовов [System.Management.Automation.Cmdlet.WriteProgress](/dotnet/api/System.Management.Automation.Cmdlet.WriteProgress) метод.

#### <a name="use-the-host-interfaces"></a>Используйте интерфейсы узла

В некоторых случаях командлет должны взаимодействовать непосредственно с пользователем, а не с помощью различных записи, или следует методов, поддерживаемых [System.Management.Automation.Cmdlet](/dotnet/api/System.Management.Automation.Cmdlet) класса. В этом случае командлет должен быть производным от [System.Management.Automation.PSCmdlet](/dotnet/api/System.Management.Automation.PSCmdlet) и использовать [System.Management.Automation.PSCmdlet.Host*](/dotnet/api/System.Management.Automation.PSCmdlet.Host) свойство. Это свойство поддерживает разные уровни типа связи, включая типы PromptForChoice, приглашения и WriteLine/ReadLine. На самом определенный уровень также предоставляет способы для чтения и записи отдельные ключи и иметь дело с буферами.

Если командлет специально разработан для создания графического интерфейса (GUI), его нужно не пропустить узла с помощью [System.Management.Automation.PSCmdlet.Host*](/dotnet/api/System.Management.Automation.PSCmdlet.Host) свойство. Например, командлет, который предназначен для создания графического пользовательского интерфейса [Out-GridView](/powershell/module/Microsoft.PowerShell.Utility/Out-GridView) командлета.

> [!NOTE]
> Не следует использовать командлеты [System.Console](/dotnet/api/System.Console) API.

### <a name="create-a-cmdlet-help-file-sd05"></a>Создайте файл справки по командлетам (SD05)

Для каждой сборки, командлет создайте файл Help.xml, содержащий сведения о командлете. Эти сведения включают описание командлета, описания параметров командлета, примеры использования командлета и многое другое.

## <a name="code-guidelines"></a>Руководствам по кодам

Следующие рекомендации необходимо соблюдать при написании кода командлетов, чтобы обеспечить согласованность пользовательского интерфейса между использованием командлетов и другие командлеты. Когда вы найдете рекомендации код для этого применяется в вашей ситуации, убедитесь, что рассмотрим рекомендации по проектированию аналогичные инструкции.

### <a name="coding-parameters-sc01"></a>Параметры кодирования (SC01)

Определение параметра, объявив открытым свойством класса cmdlet, который обозначается атрибутом **параметр** атрибута. Параметры больше не нужно быть статическими членами производного класса .NET Framework для командлета. Дополнительные сведения о том, как объявить **параметр** атрибут, см. в разделе [объявление атрибута параметра](./parameter-attribute-declaration.md).

#### <a name="support-windows-powershell-paths"></a>Поддержка Windows PowerShell пути

Путь Windows PowerShell — это механизм для нормализации доступа к пространствам имен. Когда вы назначаете пути Windows PowerShell для параметра в командлете, пользователь может определить пользовательский «диск», который выступает в качестве ярлыка для определенного пути. Когда пользователь назначает такой диск, хранимых данных, таких как данные в реестре, можно использовать согласованным образом.

Если командлет позволяет пользователю указать файл или источник данных, его следует определить тип параметра [System.String](/dotnet/api/System.String). Если поддерживается только один диск, тип должен быть массивом. Имя параметра должно быть `Path`, с псевдонимом `PSPath`. Кроме того `Path` параметр должен поддерживать подстановочные знаки. Если поддержка подстановочных знаков не является обязательным, определить `LiteralPath` параметра.

Если есть командлет считывает или записывает данные в файл, командлет должен принимать входные данные путь Windows PowerShell и командлет следует использовать [System.Management.Automation.Sessionstate.Path](/dotnet/api/System.Management.Automation.SessionState.Path) свойства Windows Пути PowerShell в путях, распознаваемых в файловой системе. Определенные механизмы включают в себя следующие методы:

- [System.Management.Automation.PSCmdlet.GetResolvedProviderPathFromPSPath](/dotnet/api/System.Management.Automation.PSCmdlet.GetResolvedProviderPathFromPSPath)

- [System.Management.Automation.PSCmdlet.GetUnresolvedProviderPathFromPSPath](/dotnet/api/System.Management.Automation.PSCmdlet.GetUnresolvedProviderPathFromPSPath)

- [System.Management.Automation.PathIntrinsics.GetResolvedProviderPathFromPSPath](/dotnet/api/System.Management.Automation.PathIntrinsics.GetResolvedProviderPathFromPSPath)

- [System.Management.Automation.PathIntrinsics.GetUnresolvedProviderPathFromPSPath](/dotnet/api/System.Management.Automation.PathIntrinsics.GetUnresolvedProviderPathFromPSPath)

Если командлет считывает или записывает данные только является набор строк, а не файлом, этот командлет следует использовать сведения о содержимом поставщика (`Content` член) для чтения и записи. Эти сведения будут получены из [System.Management.Automation.Provider.CmdletProvider.InvokeProvider](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.InvokeProvider) свойство. Эти механизмы позволяют другие хранилища данных для участия в режиме чтения и записи данных.

#### <a name="support-wildcard-characters"></a>Поддерживает символы-шаблоны

Командлет должен по возможности поддерживает символы-шаблоны. Поддержка подстановочных знаков возникает во многих местах в командлете (особенно если параметр принимает строку, идентифицирующую один объект из набора объектов). Например, образец **Stop-Proc** командлета из [руководстве StopProc](./stopproc-tutorial.md) определяет `Name` параметра для обработки строк, представляющих имена процессов. Этот параметр поддерживает подстановочные знаки, поэтому пользователь может легко указать процессы, чтобы остановить.

Если поддержка подстановочных символов доступен, операция командлет обычно создает массив. В некоторых случаях не смысла для поддержки массива, так как пользователь может использовать только одного элемента за раз. Например [Set-Location](/powershell/module/Microsoft.PowerShell.Management/Set-Location) командлет должен поддерживать массива, так как пользователь устанавливает в одном месте. В этом случае командлет по-прежнему поддерживает подстановочные знаки, но он заставляет разрешения в одном месте.

Дополнительные сведения о шаблонах подстановочный знак, см. в разделе [Поддержка подстановочных знаков в параметры командлета](./supporting-wildcard-characters-in-cmdlet-parameters.md).

#### <a name="defining-objects"></a>Определение объектов

Этот раздел содержит рекомендации для определения объектов для командлетов, а также для расширения существующих объектов.

##### <a name="define-standard-members"></a>Определения стандартных элементов

Определения стандартных элементов расширить тип объекта в пользовательский файл Types.ps1xml (использования файла Windows PowerShell Types.ps1xml как шаблон). Стандартные методы определяются в виде узла с именем PSStandardMembers. Эти определения разрешить другие командлеты и среды выполнения Windows PowerShell для работы с объектом согласованным образом.

##### <a name="define-objectmembers-to-be-used-as-parameters"></a>Определение ObjectMembers для использования в качестве параметров

При создании объекта для командлета, убедитесь, что его члены непосредственно сопоставляются с параметрами командлетов, в котором они будут использоваться. Это сопоставление позволяет объекту легко отправить в конвейер и передаваться от одного командлета к другому.

Ранее существовавших объекты .NET Framework, возвращаемые командлетами часто отсутствуют некоторые важные или удобный члены, необходимые разработчику скриптов или пользователем. Эти отсутствующие элементы могут быть особенно важно для отображения, а также для создания имен соответствующему члену, таким образом, объект можно правильно передать в конвейер. Создание пользовательского файла Types.ps1xml для документирования эти обязательные члены. При создании этого файла, мы рекомендуем следующее соглашение об именовании: *< Your_Product_Name >*. Types.ps1xml.

Например, можно добавить `Mode` свойство скрипта [System.IO.FileInfo](/dotnet/api/System.IO.FileInfo) для более четкого отображения атрибутов файла. Кроме того, можно добавить `Count` свойства псевдонима к [System.Array](/dotnet/api/System.Array) типа разрешенного согласованное использование этого имени свойства (вместо `Length`).

##### <a name="implement-the-icomparable-interface"></a>Реализовать интерфейс IComparable

Реализуйте [System.IComparable](/dotnet/api/System.IComparable) интерфейс для всех объектов выходных данных. Это позволяет легко передавать в различные командлеты, сортировки и анализа объектов выходных данных.

##### <a name="update-display-information"></a>Обновить отображаемые сведения

Если отображаемое для объекта не предоставляет ожидаемые результаты, создавать пользовательские  *\<YourProductName >*. Файле Format.ps1xml для этого объекта.

### <a name="support-well-defined-pipeline-input-sc02"></a>Поддерживает входные данные из хорошо определенного конвейера (SC02)

#### <a name="implement-for-the-middle-of-a-pipeline"></a>Реализуйте для в середине конвейера

Реализовать при условии, что он будет вызываться из середины конвейер командлета (то есть другие командлеты будут передачи входных данных или использования его выходные данные). Например, можно предположить, что `Get-Process` командлет, так как он создает данные, используется только как первый командлет в конвейере. Тем не менее так как этот командлет предназначен для в середине конвейера, этот командлет позволяет приведенных выше командлетов значение или данных в конвейере для указания процессов для извлечения.

#### <a name="support-input-from-the-pipeline"></a>Поддержка ввода из конвейера

В каждый набор параметров для командлета включать хотя бы один параметр, который поддерживает ввод из конвейера. Поддержка входные данные конвейера позволяет пользователю извлекать данные или объекты, для отправки их в набор правильный параметр и передать результаты в командлет.

Параметр может принимать входные данные из конвейера, если **параметр** включает атрибут `ValueFromPipeline` ключевое слово, `ValueFromPipelineByPropertyName` атрибута ключевое слово, или оба ключевых слова в его объявлении. Если ни один из параметров в параметре поддержка набора `ValueFromPipeline` или `ValueFromPipelineByPropertyName` ключевые слова, командлет значимо не может следовать за другой командлет, так как оно игнорирует любые входные данные конвейера.

#### <a name="support-the-processrecord-method"></a>Поддерживает метод ProcessRecord

Чтобы принять все записи из предыдущего командлета в конвейере, необходимо реализовать командлета [System.Management.Automation.Cmdlet.ProcessRecord](/dotnet/api/System.Management.Automation.Cmdlet.ProcessRecord) метод. Windows PowerShell этот метод вызывается несколько раз, один раз для каждой записи, которая отправляется в командлет.

### <a name="write-single-records-to-the-pipeline-sc03"></a>Одной записи в конвейер (SC03)

Если командлет возвращает объекты, командлет должен записывать объекты сразу же, как они создаются. Командлет не должен содержать их для буферизации их в объединенный массив. Командлеты, которые получают объекты в качестве входных данных будет возможность обработки, отображения, или обрабатывать и отображать выходных объектов без задержки. Командлет, который создает выходные данные объекты по одному должен вызывать [System.Management.Automation.Cmdlet.WriteObject](/dotnet/api/System.Management.Automation.Cmdlet.WriteObject) метод. Командлет, который создает выходные объекты в пакетах (например, поскольку нижележащим интерфейсом API возвращает массив объектов выходных данных) должны вызывать [System.Management.Automation.Cmdlet.WriteObject](/dotnet/api/System.Management.Automation.Cmdlet.WriteObject) метод с ее второй параметр Чтобы `true`.

### <a name="make-cmdlets-case-insensitive-and-case-preserving-sc04"></a>Сделать командлеты без учета регистра и меняющее регистр (SC04)

По умолчанию самой Windows PowerShell не учитывает регистр. Тем не менее так как он имеет дело с во многих существующих системах, Windows PowerShell сохраняет регистр для упрощения операции и совместимость. Другими словами Если символ в прописные буквы, Windows PowerShell сохраняется в прописные буквы. Чтобы хорошо работают системы командлет необходимо следуют соглашению. Если это возможно его следует эксплуатировать без учета регистра. Он должен тем не менее, сохранить исходный вариант для командлетов, которые происходят позже в команде или в конвейере.

## <a name="see-also"></a>См. также

[Рекомендации по разработке требуется](./required-development-guidelines.md)

[Рекомендации по разработке рекомендаций](./advisory-development-guidelines.md)

[Запись командлета Windows PowerShell](./writing-a-windows-powershell-cmdlet.md)
