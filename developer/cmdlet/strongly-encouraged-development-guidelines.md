---
title: Настоятельно рекомендуется рекомендации по разработке | Документация Майкрософт
ms.custom: ''
ms.date: 09/13/2016
ms.reviewer: ''
ms.suite: ''
ms.tgt_pltfrm: ''
ms.topic: article
ms.assetid: 4d68a8f3-fba0-44c5-97b9-9fc191d269a5
caps.latest.revision: 13
ms.openlocfilehash: 2bf2447eba07b74f8cc14c9820fc1c1774370b2f
ms.sourcegitcommit: b6871f21bd666f9cd71dd336bb3f844cf472b56c
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/03/2019
ms.locfileid: "56854010"
---
# <a name="strongly-encouraged-development-guidelines"></a><span data-ttu-id="18deb-102">Настоятельные рекомендации по разработке</span><span class="sxs-lookup"><span data-stu-id="18deb-102">Strongly Encouraged Development Guidelines</span></span>

<span data-ttu-id="18deb-103">В этом разделе описываются рекомендации, которым необходимо следовать при написании командлетов.</span><span class="sxs-lookup"><span data-stu-id="18deb-103">This section describes guidelines that you should follow when you write your cmdlets.</span></span> <span data-ttu-id="18deb-104">Они разделяются на рекомендации по разработке командлетов и рекомендации по написанию кода командлета.</span><span class="sxs-lookup"><span data-stu-id="18deb-104">They are separated into guidelines for designing cmdlets and guidelines for writing your cmdlet code.</span></span> <span data-ttu-id="18deb-105">Может оказаться, что эти рекомендации не применяются для всех сценариев.</span><span class="sxs-lookup"><span data-stu-id="18deb-105">You might find that these guidelines are not applicable for every scenario.</span></span> <span data-ttu-id="18deb-106">Тем не менее если они применяются и не следовать рекомендациям, у пользователей могут быть слишком ограничивать возможности при использовании командлетов.</span><span class="sxs-lookup"><span data-stu-id="18deb-106">However, if they do apply and you do not follow these guidelines, your users might have a poor experience when they use your cmdlets.</span></span>

## <a name="design-guidelines"></a><span data-ttu-id="18deb-107">Рекомендации по проектированию</span><span class="sxs-lookup"><span data-stu-id="18deb-107">Design Guidelines</span></span>

- [<span data-ttu-id="18deb-108">Использовать специальное существительное для имени командлета (SD01)</span><span class="sxs-lookup"><span data-stu-id="18deb-108">Use a Specific Noun for a Cmdlet Name (SD01)</span></span>](./strongly-encouraged-development-guidelines.md#use-a-specific-noun-for-a-cmdlet-name-sd01)

- [<span data-ttu-id="18deb-109">Вариант использования Pascal для имен командлетов (SD02)</span><span class="sxs-lookup"><span data-stu-id="18deb-109">Use Pascal Case for Cmdlet Names (SD02)</span></span>](./strongly-encouraged-development-guidelines.md#use-pascal-case-for-cmdlet-names-sd02)

- [<span data-ttu-id="18deb-110">Рекомендации по проектированию параметра (SD03)</span><span class="sxs-lookup"><span data-stu-id="18deb-110">Parameter Design Guidelines (SD03)</span></span>](./strongly-encouraged-development-guidelines.md#parameter-design-guidelines-sd03)

- [<span data-ttu-id="18deb-111">Отзыв для пользователя (SD04)</span><span class="sxs-lookup"><span data-stu-id="18deb-111">Provide Feedback to the User (SD04)</span></span>](./strongly-encouraged-development-guidelines.md#provide-feedback-to-the-user-sd04)

- [<span data-ttu-id="18deb-112">Создайте файл справки по командлетам (SD05)</span><span class="sxs-lookup"><span data-stu-id="18deb-112">Create a Cmdlet Help File (SD05)</span></span>](./strongly-encouraged-development-guidelines.md#create-a-cmdlet-help-file-sd05)

## <a name="code-guidelines"></a><span data-ttu-id="18deb-113">Руководствам по кодам</span><span class="sxs-lookup"><span data-stu-id="18deb-113">Code Guidelines</span></span>

- [<span data-ttu-id="18deb-114">Параметры кодирования (SC01)</span><span class="sxs-lookup"><span data-stu-id="18deb-114">Coding Parameters (SC01)</span></span>](./strongly-encouraged-development-guidelines.md#coding-parameters-sc01)

- [<span data-ttu-id="18deb-115">Поддерживает входные данные из хорошо определенного конвейера (SC02)</span><span class="sxs-lookup"><span data-stu-id="18deb-115">Support Well Defined Pipeline Input (SC02)</span></span>](./strongly-encouraged-development-guidelines.md#support-well-defined-pipeline-input-sc02)

- [<span data-ttu-id="18deb-116">Одной записи в конвейер (SC03)</span><span class="sxs-lookup"><span data-stu-id="18deb-116">Write Single Records to the Pipeline (SC03)</span></span>](./strongly-encouraged-development-guidelines.md#write-single-records-to-the-pipeline-sc03)

- [<span data-ttu-id="18deb-117">Сделать командлеты без учета регистра и меняющее регистр (SC04)</span><span class="sxs-lookup"><span data-stu-id="18deb-117">Make Cmdlets Case-Insensitive and Case-Preserving (SC04)</span></span>](./strongly-encouraged-development-guidelines.md#make-cmdlets-case-insensitive-and-case-preserving-sc04)

## <a name="design-guidelines"></a><span data-ttu-id="18deb-118">Рекомендации по проектированию</span><span class="sxs-lookup"><span data-stu-id="18deb-118">Design Guidelines</span></span>

<span data-ttu-id="18deb-119">Следующие рекомендации необходимо соблюдать при разработке командлетов, чтобы обеспечить согласованность пользовательского интерфейса между использованием командлетов и другие командлеты.</span><span class="sxs-lookup"><span data-stu-id="18deb-119">The following guidelines should be followed when designing cmdlets to ensure a consistent user experience between using your cmdlets and other cmdlets.</span></span> <span data-ttu-id="18deb-120">Когда вы найдете рекомендации разработки для этого применяется в вашей ситуации, убедитесь, что рассмотрим руководствам по кодам аналогичные инструкции.</span><span class="sxs-lookup"><span data-stu-id="18deb-120">When you find a Design guideline that applies to your situation, be sure to look at the Code guidelines for similar guidelines.</span></span>

### <a name="use-a-specific-noun-for-a-cmdlet-name-sd01"></a><span data-ttu-id="18deb-121">Использовать специальное существительное для имени командлета (SD01)</span><span class="sxs-lookup"><span data-stu-id="18deb-121">Use a Specific Noun for a Cmdlet Name (SD01)</span></span>

<span data-ttu-id="18deb-122">Существительные, используемый в названии командлета должны быть предельно точным, таким образом, пользователь может обнаруживать командлеты.</span><span class="sxs-lookup"><span data-stu-id="18deb-122">Nouns used in cmdlet naming need to be very specific so that the user can discover your cmdlets.</span></span> <span data-ttu-id="18deb-123">Префикс универсального существительные, например «server» с сокращенную версию имя продукта.</span><span class="sxs-lookup"><span data-stu-id="18deb-123">Prefix generic nouns such as "server" with a shortened version of the product name.</span></span> <span data-ttu-id="18deb-124">Например если существительное ссылается на сервер, на котором выполняется экземпляр Microsoft SQL Server, используйте существительное, например «SQLServer».</span><span class="sxs-lookup"><span data-stu-id="18deb-124">For example, if a noun refers to a server that is running an instance of Microsoft SQL Server, use a noun such as "SQLServer".</span></span> <span data-ttu-id="18deb-125">Сочетание определенных существительные и краткий список утвержденных глаголов пользователи могли быстро обнаруживать и обеспечивает их функциональность, избегая дублирование между именами командлетов.</span><span class="sxs-lookup"><span data-stu-id="18deb-125">The combination of specific nouns and the short list of approved verbs enable the user to quickly discover and anticipate functionality while avoiding duplication among cmdlet names.</span></span>

<span data-ttu-id="18deb-126">Чтобы повысить удобство работы пользователей, существительное, выбранный для имени командлета должно быть единственного числа.</span><span class="sxs-lookup"><span data-stu-id="18deb-126">To enhance the user experience, the noun that you choose for a cmdlet name should be singular.</span></span> <span data-ttu-id="18deb-127">Например, используйте имя `Get-Process` вместо **процессы Get**.</span><span class="sxs-lookup"><span data-stu-id="18deb-127">For example, use the name `Get-Process` instead of **Get-Processes**.</span></span> <span data-ttu-id="18deb-128">Лучше всего исключением из этого правила для все имена командлетов, даже в том случае, если командлет является скорее всего, с которым выполняется действие более одного элемента.</span><span class="sxs-lookup"><span data-stu-id="18deb-128">It is best to follow this rule for all cmdlet names, even when a cmdlet is likely to act upon more than one item.</span></span>

### <a name="use-pascal-case-for-cmdlet-names-sd02"></a><span data-ttu-id="18deb-129">Вариант использования Pascal для имен командлетов (SD02)</span><span class="sxs-lookup"><span data-stu-id="18deb-129">Use Pascal Case for Cmdlet Names (SD02)</span></span>

<span data-ttu-id="18deb-130">Используйте верхнего регистра для имен параметров.</span><span class="sxs-lookup"><span data-stu-id="18deb-130">Use Pascal case for parameter names.</span></span> <span data-ttu-id="18deb-131">Другими словами преобразование первой буквы команды и всех терминов, используемых в существительное.</span><span class="sxs-lookup"><span data-stu-id="18deb-131">In other words, capitalize the first letter of verb and all terms used in the noun.</span></span> <span data-ttu-id="18deb-132">Например "`Clear-ItemProperty`«.</span><span class="sxs-lookup"><span data-stu-id="18deb-132">For example, "`Clear-ItemProperty`".</span></span>

### <a name="parameter-design-guidelines-sd03"></a><span data-ttu-id="18deb-133">Рекомендации по проектированию параметра (SD03)</span><span class="sxs-lookup"><span data-stu-id="18deb-133">Parameter Design Guidelines (SD03)</span></span>

<span data-ttu-id="18deb-134">Командлет должен параметров, которые получают данные, на котором она должна работать, и параметры, которые указывают сведения, используемые для определения характеристик операции.</span><span class="sxs-lookup"><span data-stu-id="18deb-134">A cmdlet needs parameters that receive the data on which it must operate, and parameters that indicate information that is used to determine the characteristics of the operation.</span></span> <span data-ttu-id="18deb-135">Например, командлет может иметь `Name` может иметь параметр, который получает данные из конвейера и командлет `Force` параметр, чтобы указать, что командлет можно заставить его выполнения.</span><span class="sxs-lookup"><span data-stu-id="18deb-135">For example, a cmdlet might have a `Name` parameter that receives data from the pipeline, and the cmdlet might have a `Force` parameter to indicate that the cmdlet can be forced to perform its operation.</span></span> <span data-ttu-id="18deb-136">Число параметров, определяющих командлет не ограничено.</span><span class="sxs-lookup"><span data-stu-id="18deb-136">There is no limit to the number of parameters that a cmdlet can define.</span></span>

#### <a name="use-standard-parameter-names"></a><span data-ttu-id="18deb-137">Использовать имена стандартных параметров</span><span class="sxs-lookup"><span data-stu-id="18deb-137">Use Standard Parameter Names</span></span>

<span data-ttu-id="18deb-138">Таким образом, пользователь может быстро определить, что определенный параметр, командлет следует использовать имена стандартных параметров.</span><span class="sxs-lookup"><span data-stu-id="18deb-138">Your cmdlet should use standard parameter names so that the user can quickly determine what a particular parameter means.</span></span> <span data-ttu-id="18deb-139">Если требуется более конкретное имя, используйте имя стандартных параметров и укажите в качестве псевдонима более конкретное имя.</span><span class="sxs-lookup"><span data-stu-id="18deb-139">If a more specific name is required, use a standard parameter name, and then specify a more specific name as an alias.</span></span> <span data-ttu-id="18deb-140">Например `Get-Service` командлет имеет параметр, который имеет универсальное имя (`Name`) и более конкретные псевдоним (`ServiceName`).</span><span class="sxs-lookup"><span data-stu-id="18deb-140">For example, the `Get-Service` cmdlet has a  parameter that has a generic name (`Name`) and a more specific alias (`ServiceName`).</span></span> <span data-ttu-id="18deb-141">Оба условия можно использовать для указания параметра.</span><span class="sxs-lookup"><span data-stu-id="18deb-141">Both terms can be used to specify the parameter.</span></span>

<span data-ttu-id="18deb-142">Дополнительные сведения о имена параметров и их типы данных, см. в разделе [имя параметра командлета и функциональные возможности инструкции](./standard-cmdlet-parameter-names-and-types.md).</span><span class="sxs-lookup"><span data-stu-id="18deb-142">For more information about parameter names and their data types, see [Cmdlet Parameter Name and Functionality Guidelines](./standard-cmdlet-parameter-names-and-types.md).</span></span>

#### <a name="use-singular-parameter-names"></a><span data-ttu-id="18deb-143">Использовать имена параметров в единственном числе</span><span class="sxs-lookup"><span data-stu-id="18deb-143">Use Singular Parameter Names</span></span>

<span data-ttu-id="18deb-144">Старайтесь не использовать имена во множественном числе для параметров, значение которого является одиночным элементом.</span><span class="sxs-lookup"><span data-stu-id="18deb-144">Avoid using plural names for parameters whose value is a single element.</span></span> <span data-ttu-id="18deb-145">Это включает в себя параметры, которые принимают массивов или списков так, как пользователь может предоставить массив или список с единственным элементом.</span><span class="sxs-lookup"><span data-stu-id="18deb-145">This includes parameters that take arrays or lists because the user might supply an array or list with only one element.</span></span>

<span data-ttu-id="18deb-146">Имена во множественном числе параметров следует использовать только в тех случаях, где значение параметра всегда является значение несколько элемента.</span><span class="sxs-lookup"><span data-stu-id="18deb-146">Plural parameter names should be used only in those cases where the value of the parameter is always a multiple-element value.</span></span> <span data-ttu-id="18deb-147">В этих случаях командлет проверяют, предоставляются несколько элементов, что командлет должен отображаться предупреждение для пользователя, если не указаны несколько элементов.</span><span class="sxs-lookup"><span data-stu-id="18deb-147">In these cases, the cmdlet should verify that multiple elements are supplied, and the cmdlet should display a warning to the user if multiple elements are not supplied.</span></span>

#### <a name="use-pascal-case-for-parameter-names"></a><span data-ttu-id="18deb-148">Вариант использования языка Pascal, для определения имен параметров</span><span class="sxs-lookup"><span data-stu-id="18deb-148">Use Pascal Case for Parameter Names</span></span>

<span data-ttu-id="18deb-149">Используйте верхнего регистра для имен параметров.</span><span class="sxs-lookup"><span data-stu-id="18deb-149">Use Pascal case for parameter names.</span></span> <span data-ttu-id="18deb-150">Другими словами преобразование первой буквы каждого слова в имени параметра, включая первую букву имени.</span><span class="sxs-lookup"><span data-stu-id="18deb-150">In other words, capitalize the first letter of each word in the parameter name, including the first letter of the name.</span></span> <span data-ttu-id="18deb-151">Например, имя параметра `ErrorAction` использует правильный регистр.</span><span class="sxs-lookup"><span data-stu-id="18deb-151">For example, the parameter name `ErrorAction` uses the correct capitalization.</span></span> <span data-ttu-id="18deb-152">Следующие имена параметров используйте неправильный регистр символов:</span><span class="sxs-lookup"><span data-stu-id="18deb-152">The following parameter names use incorrect capitalization:</span></span>

- `errorAction`

- `erroraction`

#### <a name="parameters-that-take-a-list-of-options"></a><span data-ttu-id="18deb-153">Параметры, которые принимают список параметров</span><span class="sxs-lookup"><span data-stu-id="18deb-153">Parameters That Take a List of Options</span></span>

<span data-ttu-id="18deb-154">Чтобы создать параметр, значение которого могут быть выбраны из набора параметров двумя способами.</span><span class="sxs-lookup"><span data-stu-id="18deb-154">There are two ways to create a parameter whose value can be selected from a set of options.</span></span>

- <span data-ttu-id="18deb-155">Определение типа перечисления (или использовать существующий тип перечисления), указывающий допустимые значения.</span><span class="sxs-lookup"><span data-stu-id="18deb-155">Define an enumeration type (or use an existing enumeration type) that specifies the valid values.</span></span> <span data-ttu-id="18deb-156">Затем применение типа перечисления, чтобы создать параметр этого типа.</span><span class="sxs-lookup"><span data-stu-id="18deb-156">Then, use the enumeration type to create a parameter of that type.</span></span>

- <span data-ttu-id="18deb-157">Добавить **ValidateSet** для объявления параметра атрибута.</span><span class="sxs-lookup"><span data-stu-id="18deb-157">Add the **ValidateSet** attribute to the parameter declaration.</span></span> <span data-ttu-id="18deb-158">Дополнительные сведения об этом атрибуте см. в разделе [объявление атрибута ValidateSet](./validateset-attribute-declaration.md).</span><span class="sxs-lookup"><span data-stu-id="18deb-158">For more information about this attribute, see [ValidateSet Attribute Declaration](./validateset-attribute-declaration.md).</span></span>

#### <a name="use-standard-types-for-parameters"></a><span data-ttu-id="18deb-159">Используйте стандартные типы для параметров</span><span class="sxs-lookup"><span data-stu-id="18deb-159">Use Standard Types for Parameters</span></span>

<span data-ttu-id="18deb-160">Чтобы обеспечить согласованность с другими командлетами, там, где каждый раз можно используйте стандартные типы для параметров.</span><span class="sxs-lookup"><span data-stu-id="18deb-160">To ensure consistency with other cmdlets, use standard types for parameters where ever possible.</span></span> <span data-ttu-id="18deb-161">Дополнительные сведения о типах, которые должны использоваться для различных параметров см. в разделе [стандартные имена параметров командлета и типы](./standard-cmdlet-parameter-names-and-types.md).</span><span class="sxs-lookup"><span data-stu-id="18deb-161">For more information about the types that should be used for different parameter, see [Standard Cmdlet Parameter Names and Types](./standard-cmdlet-parameter-names-and-types.md).</span></span> <span data-ttu-id="18deb-162">В этом разделе содержит ссылки на разделы, описывающие имена и типы .NET Framework для групп стандартные параметры, такие как «параметры действий».</span><span class="sxs-lookup"><span data-stu-id="18deb-162">This topic provides links to several topics that describe the names and .NET Framework types for groups of standard parameters, such as the "activity parameters".</span></span>

#### <a name="use-strongly-typed-net-framework-types"></a><span data-ttu-id="18deb-163">Использование типов со строгой типизацией .NET Framework</span><span class="sxs-lookup"><span data-stu-id="18deb-163">Use Strongly-Typed .NET Framework Types</span></span>

<span data-ttu-id="18deb-164">Параметры должны быть определены как типы .NET Framework для обеспечения лучшей проверки параметра.</span><span class="sxs-lookup"><span data-stu-id="18deb-164">Parameters should be defined as .NET Framework types to provide better parameter validation.</span></span> <span data-ttu-id="18deb-165">Например параметры, которые доступны только для одного значения из набора значений должен быть определен как тип перечисления.</span><span class="sxs-lookup"><span data-stu-id="18deb-165">For example, parameters that are restricted to one value from a set of values should be defined as an enumeration type.</span></span> <span data-ttu-id="18deb-166">Чтобы обеспечить поддержку значение универсального кода ресурса (URI), определите параметр как [System.Uri](/dotnet/api/System.Uri) типа.</span><span class="sxs-lookup"><span data-stu-id="18deb-166">To support a Uniform Resource Identifier (URI) value, define the parameter as a [System.Uri](/dotnet/api/System.Uri) type.</span></span> <span data-ttu-id="18deb-167">Избегайте основных строковых параметров для свойств все, кроме текста в свободной форме.</span><span class="sxs-lookup"><span data-stu-id="18deb-167">Avoid basic string parameters for all but free-form text properties.</span></span>

#### <a name="use-consistent-parameter-types"></a><span data-ttu-id="18deb-168">Использовать согласованные параметры типов</span><span class="sxs-lookup"><span data-stu-id="18deb-168">Use Consistent Parameter Types</span></span>

<span data-ttu-id="18deb-169">При использовании этого параметра с несколькими командлетами всегда используете один и тот же тип параметра.</span><span class="sxs-lookup"><span data-stu-id="18deb-169">When the same parameter is used by multiple cmdlets, always use the same parameter type.</span></span>  <span data-ttu-id="18deb-170">Например если `Process` параметр [System.Int16](/dotnet/api/System.Int16) введите для одного командлета, не устанавливайте `Process` параметра другого командлета [System.Uint16](/dotnet/api/System.UInt16) типа.</span><span class="sxs-lookup"><span data-stu-id="18deb-170">For example, if the `Process` parameter is an [System.Int16](/dotnet/api/System.Int16) type for one cmdlet, do not make the `Process` parameter for another cmdlet a [System.Uint16](/dotnet/api/System.UInt16) type.</span></span>

#### <a name="parameters-that-take-true-and-false"></a><span data-ttu-id="18deb-171">Параметры, которые принимают значение True и False</span><span class="sxs-lookup"><span data-stu-id="18deb-171">Parameters That Take True and False</span></span>

<span data-ttu-id="18deb-172">Если параметр принимает только `true` и `false`, определите параметр как тип [System.Management.Automation.Switchparameter](/dotnet/api/System.Management.Automation.SwitchParameter).</span><span class="sxs-lookup"><span data-stu-id="18deb-172">If your parameter takes only `true` and `false`, define the parameter as type [System.Management.Automation.Switchparameter](/dotnet/api/System.Management.Automation.SwitchParameter).</span></span> <span data-ttu-id="18deb-173">Параметр-переключатель, считается `true` когда он указан в команде.</span><span class="sxs-lookup"><span data-stu-id="18deb-173">A switch parameter is treated as `true` when it is specified in a command.</span></span> <span data-ttu-id="18deb-174">Если параметр не включен в команду, Windows PowerShell считает, что значение параметра быть `false`.</span><span class="sxs-lookup"><span data-stu-id="18deb-174">If the parameter is not included in a command, Windows PowerShell considers the value of the parameter to be `false`.</span></span> <span data-ttu-id="18deb-175">Не следует определять логических параметров.</span><span class="sxs-lookup"><span data-stu-id="18deb-175">Do not define Boolean parameters.</span></span>

<span data-ttu-id="18deb-176">Если требуется различать три значения параметра: $true, $false и «unspecified», затем определить параметр типа Nullable\<bool >.</span><span class="sxs-lookup"><span data-stu-id="18deb-176">If your parameter needs to differentiate between 3 values: $true, $false and "unspecified", then define a parameter of type Nullable\<bool>.</span></span>  <span data-ttu-id="18deb-177">Потребность в сторонней, «unspecified» обычно появляется, когда командлета можно изменить логическое свойство объекта.</span><span class="sxs-lookup"><span data-stu-id="18deb-177">The need for a 3rd, "unspecified" value typically occurs when the cmdlet can modify a Boolean property of an object.</span></span> <span data-ttu-id="18deb-178">В данном случае «unspecified» означает, чтобы не изменить текущее значение свойства.</span><span class="sxs-lookup"><span data-stu-id="18deb-178">In this case "unspecified" means to not change the current value of the property.</span></span>

#### <a name="support-arrays-for-parameters"></a><span data-ttu-id="18deb-179">Поддерживает массивы параметров</span><span class="sxs-lookup"><span data-stu-id="18deb-179">Support Arrays for Parameters</span></span>

<span data-ttu-id="18deb-180">Часто пользователи должны выполнять той же операции для нескольких аргументов.</span><span class="sxs-lookup"><span data-stu-id="18deb-180">Frequently, users must perform the same operation against multiple arguments.</span></span> <span data-ttu-id="18deb-181">Для этих пользователей командлет должен принимать массив как параметр ввода, таким образом, пользователь может передать аргументы в качестве параметра, как это переменная Windows PowerShell.</span><span class="sxs-lookup"><span data-stu-id="18deb-181">For these users, a cmdlet should accept an array as parameter input so that a user can pass the arguments into the parameter as a Windows PowerShell variable.</span></span> <span data-ttu-id="18deb-182">Например [Get-Process](/powershell/module/Microsoft.PowerShell.Management/Get-Process) командлет использует массив для строк, которые определяют имена процессов для извлечения.</span><span class="sxs-lookup"><span data-stu-id="18deb-182">For example, the [Get-Process](/powershell/module/Microsoft.PowerShell.Management/Get-Process) cmdlet uses an array for the strings that identify the names of the processes to retrieve.</span></span>
<span data-ttu-id="18deb-183">Часто пользователи должны выполнять той же операции для нескольких аргументов.</span><span class="sxs-lookup"><span data-stu-id="18deb-183">Frequently, users must perform the same operation against multiple arguments.</span></span> <span data-ttu-id="18deb-184">Для этих пользователей командлет должен принимать массив как параметр ввода, таким образом, пользователь может передать аргументы в качестве параметра, как это переменная Windows PowerShell.</span><span class="sxs-lookup"><span data-stu-id="18deb-184">For these users, a cmdlet should accept an array as parameter input so that a user can pass the arguments into the parameter as a Windows PowerShell variable.</span></span> <span data-ttu-id="18deb-185">Например [Get-Process](/powershell/module/Microsoft.PowerShell.Management/Get-Process) командлет использует массив для строк, которые определяют имена процессов для извлечения.</span><span class="sxs-lookup"><span data-stu-id="18deb-185">For example, the [Get-Process](/powershell/module/Microsoft.PowerShell.Management/Get-Process) cmdlet uses an array for the strings that identify the names of the processes to retrieve.</span></span>

#### <a name="support-the-passthru-parameter"></a><span data-ttu-id="18deb-186">Поддерживает параметр PassThru</span><span class="sxs-lookup"><span data-stu-id="18deb-186">Support the PassThru Parameter</span></span>

<span data-ttu-id="18deb-187">По умолчанию многие командлеты, вносят изменения в систему, такие как [Stop-Process](/powershell/module/Microsoft.PowerShell.Management/Stop-Process) командлета, выступать в роли «приемники» для объектов и не возвращать результат.</span><span class="sxs-lookup"><span data-stu-id="18deb-187">By default, many cmdlets that modify the system, such as the [Stop-Process](/powershell/module/Microsoft.PowerShell.Management/Stop-Process) cmdlet, act as "sinks" for objects and do not return a result.</span></span> <span data-ttu-id="18deb-188">Необходимо реализовать эти командлет `PassThru` параметр Force вызывает командлет для возвращения объекта.</span><span class="sxs-lookup"><span data-stu-id="18deb-188">These cmdlet should implement the `PassThru` parameter to force the cmdlet to return an object.</span></span> <span data-ttu-id="18deb-189">Когда `PassThru` параметр указан, командлет возвращает объект с помощью вызова [System.Management.Automation.Cmdlet.Writeobject\*](/dotnet/api/System.Management.Automation.Cmdlet.WriteObject) метод.</span><span class="sxs-lookup"><span data-stu-id="18deb-189">When the `PassThru` parameter is specified, the cmdlet returns an object by using a call to the [System.Management.Automation.Cmdlet.Writeobject\*](/dotnet/api/System.Management.Automation.Cmdlet.WriteObject) method.</span></span> <span data-ttu-id="18deb-190">Например следующая команда останавливает процесс Calc и передает результирующий процесс в конвейер.</span><span class="sxs-lookup"><span data-stu-id="18deb-190">For example, the following command stops the Calc process and passes the resultant process to the pipeline.</span></span>

```powershell
Stop-Process calc -passthru
```

<span data-ttu-id="18deb-191">В большинстве случаев должен поддерживать командлеты Add, Set и создать `PassThru` параметра.</span><span class="sxs-lookup"><span data-stu-id="18deb-191">In most cases, Add, Set, and New cmdlets should support a `PassThru` parameter.</span></span>

#### <a name="support-parameter-sets"></a><span data-ttu-id="18deb-192">Поддержка наборов параметров</span><span class="sxs-lookup"><span data-stu-id="18deb-192">Support Parameter Sets</span></span>

<span data-ttu-id="18deb-193">Командлет предназначен для выполнения одной цели.</span><span class="sxs-lookup"><span data-stu-id="18deb-193">A cmdlet is intended to accomplish a single purpose.</span></span> <span data-ttu-id="18deb-194">Тем не менее часто есть более одного способа для описания операции или цели операции.</span><span class="sxs-lookup"><span data-stu-id="18deb-194">However, there is frequently more than one way to describe the operation or the operation target.</span></span> <span data-ttu-id="18deb-195">Например процесс может быть определено по его имени, по его идентификатору или с помощью объекта процесса.</span><span class="sxs-lookup"><span data-stu-id="18deb-195">For example, a process might be identified by its name, by its identifier, or by a process object.</span></span> <span data-ttu-id="18deb-196">Командлет должен поддерживать все разумные представления из его целевых объектов.</span><span class="sxs-lookup"><span data-stu-id="18deb-196">The cmdlet should support all the reasonable representations of its targets.</span></span> <span data-ttu-id="18deb-197">Командлет, как правило, удовлетворяющее данному требованию, указав наборы параметров (которые называют наборов параметров), которые работают совместно.</span><span class="sxs-lookup"><span data-stu-id="18deb-197">Normally, the cmdlet satisfies this requirement by specifying sets of parameters (referred to as parameter sets) that operate together.</span></span> <span data-ttu-id="18deb-198">Один параметр может принадлежать к любому количеству наборов параметров.</span><span class="sxs-lookup"><span data-stu-id="18deb-198">A single parameter can belong to any number of parameter sets.</span></span> <span data-ttu-id="18deb-199">Дополнительные сведения о наборах параметров см. в разделе [командлет задает параметр](./cmdlet-parameter-sets.md).</span><span class="sxs-lookup"><span data-stu-id="18deb-199">For more information about parameter sets, see [Cmdlet Parameter Sets](./cmdlet-parameter-sets.md).</span></span>

<span data-ttu-id="18deb-200">При указании наборов параметров, задаются только один параметр в наборе для ValueFromPipeline.</span><span class="sxs-lookup"><span data-stu-id="18deb-200">When you specify parameter sets, set only one parameter in the set to ValueFromPipeline.</span></span> <span data-ttu-id="18deb-201">Дополнительные сведения о том, как объявить **параметр** атрибут, см. в разделе [ParameterAttribute объявление](./parameter-attribute-declaration.md).</span><span class="sxs-lookup"><span data-stu-id="18deb-201">For more information about how to declare the **Parameter** attribute, see [ParameterAttribute Declaration](./parameter-attribute-declaration.md).</span></span>

<span data-ttu-id="18deb-202">При использовании наборов параметров, набор параметров по умолчанию определяется **командлет** атрибута.</span><span class="sxs-lookup"><span data-stu-id="18deb-202">When parameter sets are used, the default parameter set is defined by the **Cmdlet** attribute.</span></span> <span data-ttu-id="18deb-203">Набор параметров по умолчанию должен включать параметры, наиболее часто используемых в интерактивном сеансе Windows PowerShell.</span><span class="sxs-lookup"><span data-stu-id="18deb-203">The default parameter set should include the parameters most likely to be used in an interactive Windows PowerShell session.</span></span> <span data-ttu-id="18deb-204">Дополнительные сведения о том, как объявить **командлет** атрибут, см. в разделе [объявление CmdletAttribute](./cmdlet-attribute-declaration.md).</span><span class="sxs-lookup"><span data-stu-id="18deb-204">For more information about how to declare the **Cmdlet** attribute, see [CmdletAttribute Declaration](./cmdlet-attribute-declaration.md).</span></span>

### <a name="provide-feedback-to-the-user-sd04"></a><span data-ttu-id="18deb-205">Отзыв для пользователя (SD04)</span><span class="sxs-lookup"><span data-stu-id="18deb-205">Provide Feedback to the User (SD04)</span></span>

<span data-ttu-id="18deb-206">Используйте рекомендации в этом разделе для предоставления отзыва пользователю.</span><span class="sxs-lookup"><span data-stu-id="18deb-206">Use the guidelines in this section to provide feedback to the user.</span></span> <span data-ttu-id="18deb-207">Ваши отзывы позволяет пользователю, имейте в виду, происходящих в системе и принятия лучше административных решений.</span><span class="sxs-lookup"><span data-stu-id="18deb-207">This feedback allows the user to be aware of what is occurring in the system and to make better administrative decisions.</span></span>

<span data-ttu-id="18deb-208">Среда выполнения Windows PowerShell позволяет пользователю указать способ обработки выходных данных из каждого вызова к `Write` метод, задав привилегированной переменной.</span><span class="sxs-lookup"><span data-stu-id="18deb-208">The Windows PowerShell runtime allows a user to specify how to handle output from each call to the `Write` method by setting a preference variable.</span></span> <span data-ttu-id="18deb-209">Пользователь может задать несколько привилегированных переменных, включая переменную, которая определяет, следует ли отображать системы, сведения и переменную, которая определяет, должна ли система запроса у пользователя, прежде чем выполнять другие действия.</span><span class="sxs-lookup"><span data-stu-id="18deb-209">The user can set several preference variables, including a variable that determines whether the system should display information and a variable that determines whether the system should query the user before taking further action.</span></span>

#### <a name="support-the-writewarning-writeverbose-and-writedebug-methods"></a><span data-ttu-id="18deb-210">Поддерживает WriteWarning WriteVerbose методов и метод WriteDebug</span><span class="sxs-lookup"><span data-stu-id="18deb-210">Support the WriteWarning, WriteVerbose, and WriteDebug Methods</span></span>

<span data-ttu-id="18deb-211">Необходимо вызвать командлет [System.Management.Automation.Cmdlet.Writewarning\*](/dotnet/api/System.Management.Automation.Cmdlet.WriteWarning) метод, когда командлет собирается выполнить операцию, которую может иметь непредвиденные результаты.</span><span class="sxs-lookup"><span data-stu-id="18deb-211">A cmdlet should call the [System.Management.Automation.Cmdlet.Writewarning\*](/dotnet/api/System.Management.Automation.Cmdlet.WriteWarning) method when the cmdlet is about to perform an operation that might have an unintended result.</span></span> <span data-ttu-id="18deb-212">Например командлет необходимо вызвать этот метод, если командлет является перезаписать файл, доступный только для чтения.</span><span class="sxs-lookup"><span data-stu-id="18deb-212">For example, a cmdlet should call this method if the cmdlet is about to overwrite a read-only file.</span></span>

<span data-ttu-id="18deb-213">Необходимо вызвать командлет [System.Management.Automation.Cmdlet.Writeverbose\*](/dotnet/api/System.Management.Automation.Cmdlet.WriteVerbose) метод, когда пользователь необходимы некоторые подробные данные о действиях командлета.</span><span class="sxs-lookup"><span data-stu-id="18deb-213">A cmdlet should call the [System.Management.Automation.Cmdlet.Writeverbose\*](/dotnet/api/System.Management.Automation.Cmdlet.WriteVerbose) method when the user requires some detail about what the cmdlet is doing.</span></span> <span data-ttu-id="18deb-214">Например командлет необходимо вызвать эту информацию, если автор командлет полагает, что существуют сценарии, которые могут потребовать Дополнительные сведения о действиях командлета.</span><span class="sxs-lookup"><span data-stu-id="18deb-214">For example, a cmdlet should call this information if the cmdlet author feels that there are scenarios that might require more information about what the cmdlet is doing.</span></span>

<span data-ttu-id="18deb-215">Необходимо вызвать командлет [System.Management.Automation.Cmdlet.Writedebug\*](/dotnet/api/System.Management.Automation.Cmdlet.WriteDebug) метод при инженеру службы поддержки разработчиков или продукта, необходимо понимать, что повреждены и операции командлет.</span><span class="sxs-lookup"><span data-stu-id="18deb-215">The cmdlet should call the [System.Management.Automation.Cmdlet.Writedebug\*](/dotnet/api/System.Management.Automation.Cmdlet.WriteDebug) method when a developer or product support engineer must understand what has corrupted the cmdlet operation.</span></span> <span data-ttu-id="18deb-216">Это необязательно для командлета для вызова [System.Management.Automation.Cmdlet.Writedebug\*](/dotnet/api/System.Management.Automation.Cmdlet.WriteDebug) метод в тот же код, который вызывает [System.Management.Automation.Cmdlet.Writeverbose\*](/dotnet/api/System.Management.Automation.Cmdlet.WriteVerbose) метод поскольку `Debug` параметр представляется обоим наборам данных.</span><span class="sxs-lookup"><span data-stu-id="18deb-216">It is not necessary for the cmdlet to call the [System.Management.Automation.Cmdlet.Writedebug\*](/dotnet/api/System.Management.Automation.Cmdlet.WriteDebug) method in the same code that calls the [System.Management.Automation.Cmdlet.Writeverbose\*](/dotnet/api/System.Management.Automation.Cmdlet.WriteVerbose) method because the `Debug` parameter presents both sets of information.</span></span>

#### <a name="support-writeprogress-for-operations-that-take-a-long-time"></a><span data-ttu-id="18deb-217">Поддержка WriteProgress операций, которые занимают много времени</span><span class="sxs-lookup"><span data-stu-id="18deb-217">Support WriteProgress for Operations that take a Long Time</span></span>

<span data-ttu-id="18deb-218">Командлет операций, которые принимают много времени и, не могут работать в фоновом режиме должен поддерживать о ходе выполнения периодических вызовов [System.Management.Automation.Cmdlet.Writeprogress\*](/dotnet/api/System.Management.Automation.Cmdlet.WriteProgress) метод.</span><span class="sxs-lookup"><span data-stu-id="18deb-218">Cmdlet operations that take a long time to complete and that cannot run in the background should support progress reporting through periodic calls to the [System.Management.Automation.Cmdlet.Writeprogress\*](/dotnet/api/System.Management.Automation.Cmdlet.WriteProgress) method.</span></span>

#### <a name="use-the-host-interfaces"></a><span data-ttu-id="18deb-219">Используйте интерфейсы узла</span><span class="sxs-lookup"><span data-stu-id="18deb-219">Use the Host Interfaces</span></span>

<span data-ttu-id="18deb-220">В некоторых случаях командлет должны взаимодействовать непосредственно с пользователем, а не с помощью различных записи, или следует методов, поддерживаемых [System.Management.Automation.Cmdlet](/dotnet/api/System.Management.Automation.Cmdlet) класса.</span><span class="sxs-lookup"><span data-stu-id="18deb-220">Occasionally, a cmdlet must communicate directly with the user instead of by using the various Write or Should methods supported by the [System.Management.Automation.Cmdlet](/dotnet/api/System.Management.Automation.Cmdlet) class.</span></span> <span data-ttu-id="18deb-221">В этом случае командлет должен быть производным от [System.Management.Automation.Pscmdlet](/dotnet/api/System.Management.Automation.PSCmdlet) и использовать [System.Management.Automation.Pscmdlet.Host\*](/dotnet/api/System.Management.Automation.PSCmdlet.Host) свойство.</span><span class="sxs-lookup"><span data-stu-id="18deb-221">In this case, the cmdlet should derive from the [System.Management.Automation.Pscmdlet](/dotnet/api/System.Management.Automation.PSCmdlet) class and use the [System.Management.Automation.Pscmdlet.Host\*](/dotnet/api/System.Management.Automation.PSCmdlet.Host) property.</span></span> <span data-ttu-id="18deb-222">Это свойство поддерживает разные уровни типа связи, включая типы PromptForChoice, приглашения и WriteLine/ReadLine.</span><span class="sxs-lookup"><span data-stu-id="18deb-222">This property supports different levels of communication type, including the PromptForChoice, Prompt, and WriteLine/ReadLine types.</span></span> <span data-ttu-id="18deb-223">На самом определенный уровень также предоставляет способы для чтения и записи отдельные ключи и иметь дело с буферами.</span><span class="sxs-lookup"><span data-stu-id="18deb-223">At the most specific level, it also provides ways to read and write individual keys and to deal with buffers.</span></span>

<span data-ttu-id="18deb-224">Если командлет специально разработан для создания графического интерфейса (GUI), его нужно не пропустить узла с помощью [System.Management.Automation.Pscmdlet.Host\*](/dotnet/api/System.Management.Automation.PSCmdlet.Host) свойство.</span><span class="sxs-lookup"><span data-stu-id="18deb-224">Unless a cmdlet is specifically designed to generate a graphical user interface (GUI), it should not bypass the host by using the [System.Management.Automation.Pscmdlet.Host\*](/dotnet/api/System.Management.Automation.PSCmdlet.Host) property.</span></span> <span data-ttu-id="18deb-225">Например, командлет, который предназначен для создания графического пользовательского интерфейса [Out-GridView](/powershell/module/Microsoft.PowerShell.Utility/Out-GridView) командлета.</span><span class="sxs-lookup"><span data-stu-id="18deb-225">An example of a cmdlet that is designed to generate a GUI is the [Out-GridView](/powershell/module/Microsoft.PowerShell.Utility/Out-GridView) cmdlet.</span></span>

> [!NOTE]
> <span data-ttu-id="18deb-226">Не следует использовать командлеты [System.Console](/dotnet/api/System.Console) API.</span><span class="sxs-lookup"><span data-stu-id="18deb-226">Cmdlets should not use the [System.Console](/dotnet/api/System.Console) API.</span></span>

### <a name="create-a-cmdlet-help-file-sd05"></a><span data-ttu-id="18deb-227">Создайте файл справки по командлетам (SD05)</span><span class="sxs-lookup"><span data-stu-id="18deb-227">Create a Cmdlet Help File (SD05)</span></span>

<span data-ttu-id="18deb-228">Для каждой сборки, командлет создайте файл Help.xml, содержащий сведения о командлете.</span><span class="sxs-lookup"><span data-stu-id="18deb-228">For each cmdlet assembly, create a Help.xml file that contains information about the cmdlet.</span></span> <span data-ttu-id="18deb-229">Эти сведения включают описание командлета, описания параметров командлета, примеры использования командлета и многое другое.</span><span class="sxs-lookup"><span data-stu-id="18deb-229">This information includes a description of the cmdlet, descriptions of the cmdlet's parameters, examples of the cmdlet's use, and more.</span></span>

## <a name="code-guidelines"></a><span data-ttu-id="18deb-230">Руководствам по кодам</span><span class="sxs-lookup"><span data-stu-id="18deb-230">Code Guidelines</span></span>

<span data-ttu-id="18deb-231">Следующие рекомендации необходимо соблюдать при написании кода командлетов, чтобы обеспечить согласованность пользовательского интерфейса между использованием командлетов и другие командлеты.</span><span class="sxs-lookup"><span data-stu-id="18deb-231">The following guidelines should be followed when coding cmdlets to ensure a consistent user experience between using your cmdlets and other cmdlets.</span></span> <span data-ttu-id="18deb-232">Когда вы найдете рекомендации код для этого применяется в вашей ситуации, убедитесь, что рассмотрим рекомендации по проектированию аналогичные инструкции.</span><span class="sxs-lookup"><span data-stu-id="18deb-232">When you find a Code guideline that applies to your situation, be sure to look at the Design guidelines for similar guidelines.</span></span>

### <a name="coding-parameters-sc01"></a><span data-ttu-id="18deb-233">Параметры кодирования (SC01)</span><span class="sxs-lookup"><span data-stu-id="18deb-233">Coding Parameters (SC01)</span></span>

<span data-ttu-id="18deb-234">Определение параметра, объявив открытым свойством класса cmdlet, который обозначается атрибутом **параметр** атрибута.</span><span class="sxs-lookup"><span data-stu-id="18deb-234">Define a parameter by declaring a public property of the cmdlet class that is decorated with the **Parameter** attribute.</span></span> <span data-ttu-id="18deb-235">Параметры больше не нужно быть статическими членами производного класса .NET Framework для командлета.</span><span class="sxs-lookup"><span data-stu-id="18deb-235">Parameters do not have to be static members of the derived .NET Framework class for the cmdlet.</span></span> <span data-ttu-id="18deb-236">Дополнительные сведения о том, как объявить **параметр** атрибут, см. в разделе [объявление атрибута параметра](./parameter-attribute-declaration.md).</span><span class="sxs-lookup"><span data-stu-id="18deb-236">For more information about how to declare the **Parameter** attribute, see [Parameter Attribute Declaration](./parameter-attribute-declaration.md).</span></span>

#### <a name="support-windows-powershell-paths"></a><span data-ttu-id="18deb-237">Поддержка Windows PowerShell пути</span><span class="sxs-lookup"><span data-stu-id="18deb-237">Support Windows PowerShell Paths</span></span>

<span data-ttu-id="18deb-238">Путь Windows PowerShell — это механизм для нормализации доступа к пространствам имен.</span><span class="sxs-lookup"><span data-stu-id="18deb-238">The Windows PowerShell path is the mechanism for normalizing access to namespaces.</span></span> <span data-ttu-id="18deb-239">Когда вы назначаете пути Windows PowerShell для параметра в командлете, пользователь может определить пользовательский «диск», который выступает в качестве ярлыка для определенного пути.</span><span class="sxs-lookup"><span data-stu-id="18deb-239">When you assign a Windows PowerShell path to a parameter in the cmdlet, the user can define a custom "drive" that acts as a shortcut to a specific path.</span></span> <span data-ttu-id="18deb-240">Когда пользователь назначает такой диск, хранимых данных, таких как данные в реестре, можно использовать согласованным образом.</span><span class="sxs-lookup"><span data-stu-id="18deb-240">When a user designates such a drive, stored data, such as data in the Registry, can be used in a consistent way.</span></span>

<span data-ttu-id="18deb-241">Если командлет позволяет пользователю указать файл или источник данных, его следует определить тип параметра [System.String](/dotnet/api/System.String).</span><span class="sxs-lookup"><span data-stu-id="18deb-241">If your cmdlet allows the user to specify a file or a data source, it should define a parameter of type [System.String](/dotnet/api/System.String).</span></span> <span data-ttu-id="18deb-242">Если поддерживается только один диск, тип должен быть массивом.</span><span class="sxs-lookup"><span data-stu-id="18deb-242">If more than one drive is supported, the type should be an array.</span></span> <span data-ttu-id="18deb-243">Имя параметра должно быть `Path`, с псевдонимом `PSPath`.</span><span class="sxs-lookup"><span data-stu-id="18deb-243">The name of the parameter should be `Path`, with an alias of `PSPath`.</span></span> <span data-ttu-id="18deb-244">Кроме того `Path` параметр должен поддерживать подстановочные знаки.</span><span class="sxs-lookup"><span data-stu-id="18deb-244">Additionally, the `Path` parameter should support wildcard characters.</span></span> <span data-ttu-id="18deb-245">Если поддержка подстановочных знаков не является обязательным, определить `LiteralPath` параметра.</span><span class="sxs-lookup"><span data-stu-id="18deb-245">If support for wildcard characters is not required, define a `LiteralPath` parameter.</span></span>

<span data-ttu-id="18deb-246">Если есть командлет считывает или записывает данные в файл, командлет должен принимать входные данные путь Windows PowerShell и командлет следует использовать [System.Management.Automation.Sessionstate.Path](/dotnet/api/System.Management.Automation.SessionState.Path) свойства Windows Пути PowerShell в путях, распознаваемых в файловой системе.</span><span class="sxs-lookup"><span data-stu-id="18deb-246">If the data that the cmdlet reads or writes has to be a file, the cmdlet should accept Windows PowerShell path input, and the cmdlet should use the [System.Management.Automation.Sessionstate.Path](/dotnet/api/System.Management.Automation.SessionState.Path) property to translate the Windows PowerShell paths into paths that the file system recognizes.</span></span> <span data-ttu-id="18deb-247">Определенные механизмы включают в себя следующие методы:</span><span class="sxs-lookup"><span data-stu-id="18deb-247">The specific mechanisms include the following methods:</span></span>

- [<span data-ttu-id="18deb-248">System.Management.Automation.Pscmdlet.Getresolvedproviderpathfrompspath</span><span class="sxs-lookup"><span data-stu-id="18deb-248">System.Management.Automation.Pscmdlet.Getresolvedproviderpathfrompspath</span></span>](/dotnet/api/System.Management.Automation.PSCmdlet.GetResolvedProviderPathFromPSPath)

- [<span data-ttu-id="18deb-249">System.Management.Automation.Pscmdlet.Getunresolvedproviderpathfrompspath</span><span class="sxs-lookup"><span data-stu-id="18deb-249">System.Management.Automation.Pscmdlet.Getunresolvedproviderpathfrompspath</span></span>](/dotnet/api/System.Management.Automation.PSCmdlet.GetUnresolvedProviderPathFromPSPath)

- [<span data-ttu-id="18deb-250">System.Management.Automation.Pathintrinsics.Getresolvedproviderpathfrompspath</span><span class="sxs-lookup"><span data-stu-id="18deb-250">System.Management.Automation.Pathintrinsics.Getresolvedproviderpathfrompspath</span></span>](/dotnet/api/System.Management.Automation.PathIntrinsics.GetResolvedProviderPathFromPSPath)

- [<span data-ttu-id="18deb-251">System.Management.Automation.Pathintrinsics.Getunresolvedproviderpathfrompspath</span><span class="sxs-lookup"><span data-stu-id="18deb-251">System.Management.Automation.Pathintrinsics.Getunresolvedproviderpathfrompspath</span></span>](/dotnet/api/System.Management.Automation.PathIntrinsics.GetUnresolvedProviderPathFromPSPath)

<span data-ttu-id="18deb-252">Если командлет считывает или записывает данные только является набор строк, а не файлом, этот командлет следует использовать сведения о содержимом поставщика (`Content` член) для чтения и записи.</span><span class="sxs-lookup"><span data-stu-id="18deb-252">If the data that the cmdlet reads or writes is only a set of strings instead of a file, the cmdlet should use the provider content information (`Content` member) to read and write.</span></span> <span data-ttu-id="18deb-253">Эти сведения будут получены из [System.Management.Automation.Provider.Cmdletprovider.Invokeprovider\*](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.InvokeProvider) свойство.</span><span class="sxs-lookup"><span data-stu-id="18deb-253">This information is obtained from the [System.Management.Automation.Provider.Cmdletprovider.Invokeprovider\*](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.InvokeProvider) property.</span></span> <span data-ttu-id="18deb-254">Эти механизмы позволяют другие хранилища данных для участия в режиме чтения и записи данных.</span><span class="sxs-lookup"><span data-stu-id="18deb-254">These mechanisms allow other data stores to participate in the reading and writing of data.</span></span>

#### <a name="support-wildcard-characters"></a><span data-ttu-id="18deb-255">Поддерживает символы-шаблоны</span><span class="sxs-lookup"><span data-stu-id="18deb-255">Support Wildcard Characters</span></span>

<span data-ttu-id="18deb-256">Командлет должен по возможности поддерживает символы-шаблоны.</span><span class="sxs-lookup"><span data-stu-id="18deb-256">A cmdlet should support wildcard characters if possible.</span></span> <span data-ttu-id="18deb-257">Поддержка подстановочных знаков возникает во многих местах в командлете (особенно если параметр принимает строку, идентифицирующую один объект из набора объектов).</span><span class="sxs-lookup"><span data-stu-id="18deb-257">Support for wildcard characters occurs in many places in a cmdlet (especially when a parameter takes a string to identify one object from a set of objects).</span></span> <span data-ttu-id="18deb-258">Например, образец **Stop-Proc** командлета из [руководстве StopProc](./stopproc-tutorial.md) определяет `Name` параметра для обработки строк, представляющих имена процессов.</span><span class="sxs-lookup"><span data-stu-id="18deb-258">For example, the sample **Stop-Proc** cmdlet from the [StopProc Tutorial](./stopproc-tutorial.md) defines a `Name` parameter to handle strings that represent process names.</span></span> <span data-ttu-id="18deb-259">Этот параметр поддерживает подстановочные знаки, поэтому пользователь может легко указать процессы, чтобы остановить.</span><span class="sxs-lookup"><span data-stu-id="18deb-259">This parameter supports wildcard characters so that the user can easily specify the processes to stop.</span></span>

<span data-ttu-id="18deb-260">Если поддержка подстановочных символов доступен, операция командлет обычно создает массив.</span><span class="sxs-lookup"><span data-stu-id="18deb-260">When support for wildcard characters is available, a cmdlet operation usually produces an array.</span></span> <span data-ttu-id="18deb-261">В некоторых случаях не смысла для поддержки массива, так как пользователь может использовать только одного элемента за раз.</span><span class="sxs-lookup"><span data-stu-id="18deb-261">Occasionally, it does not make sense to support an array because the user might use only a single item at a time.</span></span> <span data-ttu-id="18deb-262">Например [Set-Location](/powershell/module/Microsoft.PowerShell.Management/Set-Location) командлет должен поддерживать массива, так как пользователь устанавливает в одном месте.</span><span class="sxs-lookup"><span data-stu-id="18deb-262">For example, the [Set-Location](/powershell/module/Microsoft.PowerShell.Management/Set-Location) cmdlet does not need to support an array because the user is setting only a single location.</span></span> <span data-ttu-id="18deb-263">В этом случае командлет по-прежнему поддерживает подстановочные знаки, но он заставляет разрешения в одном месте.</span><span class="sxs-lookup"><span data-stu-id="18deb-263">In this instance, the cmdlet still supports wildcard characters, but it forces resolution to a single location.</span></span>

<span data-ttu-id="18deb-264">Дополнительные сведения о шаблонах подстановочный знак, см. в разделе [Поддержка подстановочных знаков в параметры командлета](./supporting-wildcard-characters-in-cmdlet-parameters.md).</span><span class="sxs-lookup"><span data-stu-id="18deb-264">For more information about wildcard-character patterns, see [Supporting Wildcard Characters in Cmdlet Parameters](./supporting-wildcard-characters-in-cmdlet-parameters.md).</span></span>

#### <a name="defining-objects"></a><span data-ttu-id="18deb-265">Определение объектов</span><span class="sxs-lookup"><span data-stu-id="18deb-265">Defining Objects</span></span>

<span data-ttu-id="18deb-266">Этот раздел содержит рекомендации для определения объектов для командлетов, а также для расширения существующих объектов.</span><span class="sxs-lookup"><span data-stu-id="18deb-266">This section contains guidelines for defining objects for cmdlets and for extending existing objects.</span></span>

##### <a name="define-standard-members"></a><span data-ttu-id="18deb-267">Определения стандартных элементов</span><span class="sxs-lookup"><span data-stu-id="18deb-267">Define Standard Members</span></span>

<span data-ttu-id="18deb-268">Определения стандартных элементов расширить тип объекта в пользовательский файл Types.ps1xml (использования файла Windows PowerShell Types.ps1xml как шаблон).</span><span class="sxs-lookup"><span data-stu-id="18deb-268">Define standard members to extend an object type in a custom Types.ps1xml file (use the Windows PowerShell Types.ps1xml file as a template).</span></span> <span data-ttu-id="18deb-269">Стандартные методы определяются в виде узла с именем PSStandardMembers.</span><span class="sxs-lookup"><span data-stu-id="18deb-269">Standard members are defined by a node with the name PSStandardMembers.</span></span> <span data-ttu-id="18deb-270">Эти определения разрешить другие командлеты и среды выполнения Windows PowerShell для работы с объектом согласованным образом.</span><span class="sxs-lookup"><span data-stu-id="18deb-270">These definitions allow other cmdlets and the Windows PowerShell runtime to work with your object in a consistent way.</span></span>

##### <a name="define-objectmembers-to-be-used-as-parameters"></a><span data-ttu-id="18deb-271">Определение ObjectMembers для использования в качестве параметров</span><span class="sxs-lookup"><span data-stu-id="18deb-271">Define ObjectMembers to Be Used as Parameters</span></span>

<span data-ttu-id="18deb-272">При создании объекта для командлета, убедитесь, что его члены непосредственно сопоставляются с параметрами командлетов, в котором они будут использоваться.</span><span class="sxs-lookup"><span data-stu-id="18deb-272">If you are designing an object for a cmdlet, ensure that its members map directly to the parameters of the cmdlets that will use it.</span></span> <span data-ttu-id="18deb-273">Это сопоставление позволяет объекту легко отправить в конвейер и передаваться от одного командлета к другому.</span><span class="sxs-lookup"><span data-stu-id="18deb-273">This mapping allows the object to be easily sent to the pipeline and to be passed from one cmdlet to another.</span></span>

<span data-ttu-id="18deb-274">Ранее существовавших объекты .NET Framework, возвращаемые командлетами часто отсутствуют некоторые важные или удобный члены, необходимые разработчику скриптов или пользователем.</span><span class="sxs-lookup"><span data-stu-id="18deb-274">Preexisting .NET Framework objects that are returned by cmdlets are frequently missing some important or convenient members that are needed by the script developer or user.</span></span> <span data-ttu-id="18deb-275">Эти отсутствующие элементы могут быть особенно важно для отображения, а также для создания имен соответствующему члену, таким образом, объект можно правильно передать в конвейер.</span><span class="sxs-lookup"><span data-stu-id="18deb-275">These missing members can be particularly important for display and for creating the correct member names so that the object can be correctly passed to the pipeline.</span></span> <span data-ttu-id="18deb-276">Создание пользовательского файла Types.ps1xml для документирования эти обязательные члены.</span><span class="sxs-lookup"><span data-stu-id="18deb-276">Create a custom Types.ps1xml file to document these required members.</span></span> <span data-ttu-id="18deb-277">При создании этого файла, мы рекомендуем следующее соглашение об именовании: *< Your_Product_Name >*. Types.ps1xml.</span><span class="sxs-lookup"><span data-stu-id="18deb-277">When you create this file, we recommend the following naming convention: *<Your_Product_Name>*.Types.ps1xml.</span></span>

<span data-ttu-id="18deb-278">Например, можно добавить `Mode` свойство скрипта [System.IO.Fileinfo](/dotnet/api/System.IO.FileInfo) для более четкого отображения атрибутов файла.</span><span class="sxs-lookup"><span data-stu-id="18deb-278">For example, you could add a `Mode` script property to the [System.IO.Fileinfo](/dotnet/api/System.IO.FileInfo) type to display the attributes of a file more clearly.</span></span> <span data-ttu-id="18deb-279">Кроме того, можно добавить `Count` свойства псевдонима к [System.Array](/dotnet/api/System.Array) типа разрешенного согласованное использование этого имени свойства (вместо `Length`).</span><span class="sxs-lookup"><span data-stu-id="18deb-279">Additionally, you could add a `Count` alias property to the [System.Array](/dotnet/api/System.Array) type to allow the consistent use of that property name (instead of `Length`).</span></span>

##### <a name="implement-the-icomparable-interface"></a><span data-ttu-id="18deb-280">Реализовать интерфейс IComparable</span><span class="sxs-lookup"><span data-stu-id="18deb-280">Implement the IComparable Interface</span></span>

<span data-ttu-id="18deb-281">Реализуйте [System.Icomparable](/dotnet/api/System.IComparable) интерфейс для всех объектов выходных данных.</span><span class="sxs-lookup"><span data-stu-id="18deb-281">Implement a [System.Icomparable](/dotnet/api/System.IComparable) interface on all output objects.</span></span> <span data-ttu-id="18deb-282">Это позволяет легко передавать в различные командлеты, сортировки и анализа объектов выходных данных.</span><span class="sxs-lookup"><span data-stu-id="18deb-282">This allows the output objects to be easily piped to various sorting and analysis cmdlets.</span></span>

##### <a name="update-display-information"></a><span data-ttu-id="18deb-283">Обновить отображаемые сведения</span><span class="sxs-lookup"><span data-stu-id="18deb-283">Update Display Information</span></span>

<span data-ttu-id="18deb-284">Если отображаемое для объекта не предоставляет ожидаемые результаты, создавать пользовательские  *\<YourProductName >*. Файле Format.ps1xml для этого объекта.</span><span class="sxs-lookup"><span data-stu-id="18deb-284">If the display for an object does not provide the expected results, create a custom *\<YourProductName>*.Format.ps1xml file for that object.</span></span>

### <a name="support-well-defined-pipeline-input-sc02"></a><span data-ttu-id="18deb-285">Поддерживает входные данные из хорошо определенного конвейера (SC02)</span><span class="sxs-lookup"><span data-stu-id="18deb-285">Support Well Defined Pipeline Input (SC02)</span></span>

#### <a name="implement-for-the-middle-of-a-pipeline"></a><span data-ttu-id="18deb-286">Реализуйте для в середине конвейера</span><span class="sxs-lookup"><span data-stu-id="18deb-286">Implement for the Middle of a Pipeline</span></span>

<span data-ttu-id="18deb-287">Реализовать при условии, что он будет вызываться из середины конвейер командлета (то есть другие командлеты будут передачи входных данных или использования его выходные данные).</span><span class="sxs-lookup"><span data-stu-id="18deb-287">Implement a cmdlet assuming that it will be called from the middle of a pipeline (that is, other cmdlets will produce its input or consume its output).</span></span> <span data-ttu-id="18deb-288">Например, можно предположить, что `Get-Process` командлет, так как он создает данные, используется только как первый командлет в конвейере.</span><span class="sxs-lookup"><span data-stu-id="18deb-288">For example, you might assume that the `Get-Process` cmdlet, because it generates data, is used only as the first cmdlet in a pipeline.</span></span> <span data-ttu-id="18deb-289">Тем не менее так как этот командлет предназначен для в середине конвейера, этот командлет позволяет приведенных выше командлетов значение или данных в конвейере для указания процессов для извлечения.</span><span class="sxs-lookup"><span data-stu-id="18deb-289">However, because this cmdlet is designed for the middle of a pipeline, this cmdlet allows previous cmdlets or data in the pipeline to specify the processes to retrieve.</span></span>

#### <a name="support-input-from-the-pipeline"></a><span data-ttu-id="18deb-290">Поддержка ввода из конвейера</span><span class="sxs-lookup"><span data-stu-id="18deb-290">Support Input from the Pipeline</span></span>

<span data-ttu-id="18deb-291">В каждый набор параметров для командлета включать хотя бы один параметр, который поддерживает ввод из конвейера.</span><span class="sxs-lookup"><span data-stu-id="18deb-291">In each parameter set for a cmdlet, include at least one parameter that supports input from the pipeline.</span></span> <span data-ttu-id="18deb-292">Поддержка входные данные конвейера позволяет пользователю извлекать данные или объекты, для отправки их в набор правильный параметр и передать результаты в командлет.</span><span class="sxs-lookup"><span data-stu-id="18deb-292">Support for pipeline input allows the user to retrieve data or objects, to send them to the correct parameter set, and to pass the results directly to a cmdlet.</span></span>

<span data-ttu-id="18deb-293">Параметр может принимать входные данные из конвейера, если **параметр** включает атрибут `ValueFromPipeline` ключевое слово, `ValueFromPipelineByPropertyName` атрибута ключевое слово, или оба ключевых слова в его объявлении.</span><span class="sxs-lookup"><span data-stu-id="18deb-293">A parameter accepts input from the pipeline if the **Parameter** attribute includes the `ValueFromPipeline` keyword, the `ValueFromPipelineByPropertyName` keyword attribute, or both keywords in its  declaration.</span></span> <span data-ttu-id="18deb-294">Если ни один из параметров в параметре поддержка набора `ValueFromPipeline` или `ValueFromPipelineByPropertyName` ключевые слова, командлет значимо не может следовать за другой командлет, так как оно игнорирует любые входные данные конвейера.</span><span class="sxs-lookup"><span data-stu-id="18deb-294">If none of the parameters in a parameter set support the `ValueFromPipeline` or `ValueFromPipelineByPropertyName` keywords, the cmdlet cannot meaningfully be placed after another cmdlet because it will ignore any pipeline input.</span></span>

#### <a name="support-the-processrecord-method"></a><span data-ttu-id="18deb-295">Поддерживает метод ProcessRecord</span><span class="sxs-lookup"><span data-stu-id="18deb-295">Support the ProcessRecord Method</span></span>

<span data-ttu-id="18deb-296">Чтобы принять все записи из предыдущего командлета в конвейере, необходимо реализовать командлета [System.Management.Automation.Cmdlet.Processrecord\*](/dotnet/api/System.Management.Automation.Cmdlet.ProcessRecord) метод.</span><span class="sxs-lookup"><span data-stu-id="18deb-296">To accept all the records from the preceding cmdlet in the pipeline, your cmdlet must implement the [System.Management.Automation.Cmdlet.Processrecord\*](/dotnet/api/System.Management.Automation.Cmdlet.ProcessRecord) method.</span></span> <span data-ttu-id="18deb-297">Windows PowerShell этот метод вызывается несколько раз, один раз для каждой записи, которая отправляется в командлет.</span><span class="sxs-lookup"><span data-stu-id="18deb-297">Windows PowerShell calls this method multiple times, once for every record that is sent to your cmdlet.</span></span>

### <a name="write-single-records-to-the-pipeline-sc03"></a><span data-ttu-id="18deb-298">Одной записи в конвейер (SC03)</span><span class="sxs-lookup"><span data-stu-id="18deb-298">Write Single Records to the Pipeline (SC03)</span></span>

<span data-ttu-id="18deb-299">Если командлет возвращает объекты, командлет должен записывать объекты сразу же, как они создаются.</span><span class="sxs-lookup"><span data-stu-id="18deb-299">When a cmdlet returns objects, the cmdlet should write the objects immediately as they are generated.</span></span> <span data-ttu-id="18deb-300">Командлет не должен содержать их для буферизации их в объединенный массив.</span><span class="sxs-lookup"><span data-stu-id="18deb-300">The cmdlet should not hold them in order to buffer them into a combined array.</span></span> <span data-ttu-id="18deb-301">Командлеты, которые получают объекты в качестве входных данных будет возможность обработки, отображения, или обрабатывать и отображать выходных объектов без задержки.</span><span class="sxs-lookup"><span data-stu-id="18deb-301">The cmdlets that receive the objects as input will then be able to process, display, or process and display the output objects without delay.</span></span> <span data-ttu-id="18deb-302">Командлет, который создает выходные данные объекты по одному должен вызывать [System.Management.Automation.Cmdlet.Writeobject](/dotnet/api/System.Management.Automation.Cmdlet.WriteObject) метод.</span><span class="sxs-lookup"><span data-stu-id="18deb-302">A cmdlet that generates output objects one at a time should call the [System.Management.Automation.Cmdlet.Writeobject](/dotnet/api/System.Management.Automation.Cmdlet.WriteObject) method.</span></span> <span data-ttu-id="18deb-303">Командлет, который создает выходные объекты в пакетах (например, поскольку нижележащим интерфейсом API возвращает массив объектов выходных данных) должны вызывать [System.Managemet.Automation.Cmdlet.Writeobject](/dotnet/api/System.Managemet.Automation.Cmdlet.WriteObject) метод с ее второй параметр Чтобы `true`.</span><span class="sxs-lookup"><span data-stu-id="18deb-303">A cmdlet that generates output objects in batches (for example, because an underlying API returns an array of output objects) should call the [System.Managemet.Automation.Cmdlet.Writeobject](/dotnet/api/System.Managemet.Automation.Cmdlet.WriteObject) Method with its second parameter set to `true`.</span></span>

### <a name="make-cmdlets-case-insensitive-and-case-preserving-sc04"></a><span data-ttu-id="18deb-304">Сделать командлеты без учета регистра и меняющее регистр (SC04)</span><span class="sxs-lookup"><span data-stu-id="18deb-304">Make Cmdlets Case-Insensitive and Case-Preserving (SC04)</span></span>

<span data-ttu-id="18deb-305">По умолчанию самой Windows PowerShell не учитывает регистр.</span><span class="sxs-lookup"><span data-stu-id="18deb-305">By default, Windows PowerShell itself is case-insensitive.</span></span> <span data-ttu-id="18deb-306">Тем не менее так как он имеет дело с во многих существующих системах, Windows PowerShell сохраняет регистр для упрощения операции и совместимость.</span><span class="sxs-lookup"><span data-stu-id="18deb-306">However, because it deals with many preexisting systems, Windows PowerShell does preserve case for ease of operation and compatibility.</span></span> <span data-ttu-id="18deb-307">Другими словами Если символ в прописные буквы, Windows PowerShell сохраняется в прописные буквы.</span><span class="sxs-lookup"><span data-stu-id="18deb-307">In other words, if a character is supplied in uppercase letters, Windows PowerShell keeps it in uppercase letters.</span></span> <span data-ttu-id="18deb-308">Чтобы хорошо работают системы командлет необходимо следуют соглашению.</span><span class="sxs-lookup"><span data-stu-id="18deb-308">For systems to work well, a cmdlet needs to follow this convention.</span></span> <span data-ttu-id="18deb-309">Если это возможно его следует эксплуатировать без учета регистра.</span><span class="sxs-lookup"><span data-stu-id="18deb-309">If possible, it should operate in a case-insensitive way.</span></span> <span data-ttu-id="18deb-310">Он должен тем не менее, сохранить исходный вариант для командлетов, которые происходят позже в команде или в конвейере.</span><span class="sxs-lookup"><span data-stu-id="18deb-310">It should, however, preserve the original case for cmdlets that occur later in a command or in the pipeline.</span></span>

## <a name="see-also"></a><span data-ttu-id="18deb-311">См. также</span><span class="sxs-lookup"><span data-stu-id="18deb-311">See Also</span></span>

[<span data-ttu-id="18deb-312">Рекомендации по разработке требуется</span><span class="sxs-lookup"><span data-stu-id="18deb-312">Required Development Guidelines</span></span>](./required-development-guidelines.md)

[<span data-ttu-id="18deb-313">Рекомендации по разработке рекомендаций</span><span class="sxs-lookup"><span data-stu-id="18deb-313">Advisory Development Guidelines</span></span>](./advisory-development-guidelines.md)

[<span data-ttu-id="18deb-314">Запись командлета Windows PowerShell</span><span class="sxs-lookup"><span data-stu-id="18deb-314">Writing a Windows PowerShell Cmdlet</span></span>](./writing-a-windows-powershell-cmdlet.md)
